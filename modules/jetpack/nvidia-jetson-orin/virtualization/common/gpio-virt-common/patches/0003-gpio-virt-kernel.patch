diff --git a/drivers/gpio/gpio-tegra.c b/drivers/gpio/gpio-tegra.c
index f66fc17faee4..37adc552495d 100644
--- a/drivers/gpio/gpio-tegra.c
+++ b/drivers/gpio/gpio-tegra.c
@@ -58,13 +58,35 @@
 #define GPIO_INT_LVL_LEVEL_HIGH		0x000001
 #define GPIO_INT_LVL_LEVEL_LOW		0x000000
 
+// #define GPIO_DEBUG
+// #define GPIO_DEBUG_VERBOSE
+
+#ifdef GPIO_DEBUG
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+#else
+  #define deb_info(fmt, ...)
+  #define deb_debug(fmt, ...)
+#endif
+
+#ifdef GPIO_DEBUG_VERBOSE
+  #define deb_verbose           deb_debug
+#else
+  #define deb_verbose(fmt, ...)
+#endif
+
+/*
+#if defined(CONFIG_TEGRA_GPIO_GUEST_PROXY) || defined(CONFIG_TEGRA_GPIO_HOST_PROXY)
+#include <gpio-proxy.h> // low level hooks for readl_x and writel_x
+#endif // CONFIG_TEGRA_GPIO_GUEST_PROXY and CONFIG_TEGRA_GPIO_HOST_PROXY
+*/
 struct tegra_gpio_info;
 
 struct tegra_gpio_bank {
 	unsigned int bank;
 	unsigned int irq;
 	spinlock_t gpio_lock[4];
-#ifdef CONFIG_PM_SLEEP
+    #ifdef CONFIG_PM_SLEEP
 	u32 cnf[4];
 	u32 out[4];
 	u32 oe[4];
@@ -72,7 +94,7 @@ struct tegra_gpio_bank {
 	u32 int_lvl[4];
 	u32 wake_enb[4];
 	u32 dbc_enb[4];
-#endif
+    #endif
 	u32 dbc_cnt[4];
 	u32 cnf_init[4];
 	u32 out_init[4];
@@ -101,17 +123,23 @@ static struct tegra_gpio_info *gpio_info;
 static inline void tegra_gpio_writel(struct tegra_gpio_info *tgi,
 				     u32 val, u32 reg)
 {
+	deb_verbose("\n");
+
 	writel_relaxed(val, tgi->regs + reg);
 }
 
 static inline u32 tegra_gpio_readl(struct tegra_gpio_info *tgi, u32 reg)
 {
+	deb_verbose("\n");
+
 	return readl_relaxed(tgi->regs + reg);
 }
 
 static unsigned int tegra_gpio_compose(unsigned int bank, unsigned int port,
 				       unsigned int bit)
 {
+	deb_verbose("\n");
+
 	return (bank << 5) | ((port & 0x3) << 3) | (bit & 0x7);
 }
 
@@ -120,6 +148,8 @@ static void tegra_gpio_mask_write(struct tegra_gpio_info *tgi, u32 reg,
 {
 	u32 val;
 
+	deb_verbose("\n");
+
 	val = 0x100 << GPIO_BIT(gpio);
 	if (value)
 		val |= 1 << GPIO_BIT(gpio);
@@ -135,6 +165,8 @@ static void tegra_gpio_save_gpio_state(unsigned int gpio)
 	u32 mask = BIT(GPIO_BIT(gpio));
 	unsigned long flags;
 
+	deb_verbose("\n");
+
 	spin_lock_irqsave(&bank->gpio_lock[p], flags);
 
 	bank->cnf_init[p] &= ~mask;
@@ -206,17 +238,23 @@ static void tegra_gpio_restore_gpio_state(unsigned int gpio)
 
 static void tegra_gpio_enable(struct tegra_gpio_info *tgi, unsigned int gpio)
 {
+	deb_verbose("\n");
+
 	tegra_gpio_mask_write(tgi, GPIO_MSK_CNF(tgi, gpio), gpio, 1);
 }
 
 static int tegra_gpio_request(struct gpio_chip *chip, unsigned int offset)
 {
+	deb_verbose("\n");
+
 	tegra_gpio_save_gpio_state(offset);
 	return pinctrl_gpio_request(chip->base + offset);
 }
 
 static void tegra_gpio_free(struct gpio_chip *chip, unsigned int offset)
 {
+	deb_verbose("\n");
+
 	pinctrl_gpio_free(chip->base + offset);
 	tegra_gpio_restore_gpio_state(offset);
 }
@@ -226,6 +264,8 @@ static void tegra_gpio_set(struct gpio_chip *chip, unsigned int offset,
 {
 	struct tegra_gpio_info *tgi = gpiochip_get_data(chip);
 
+	deb_verbose("\n");
+
 	tegra_gpio_mask_write(tgi, GPIO_MSK_OUT(tgi, offset), offset, value);
 }
 
@@ -247,6 +287,8 @@ static int tegra_gpio_direction_input(struct gpio_chip *chip,
 	struct tegra_gpio_info *tgi = gpiochip_get_data(chip);
 	int ret;
 
+	deb_verbose("\n");
+
 	tegra_gpio_mask_write(tgi, GPIO_MSK_OE(tgi, offset), offset, 0);
 	tegra_gpio_enable(tgi, offset);
 
@@ -266,6 +308,8 @@ static int tegra_gpio_direction_output(struct gpio_chip *chip,
 	struct tegra_gpio_info *tgi = gpiochip_get_data(chip);
 	int ret;
 
+	deb_verbose("\n");
+
 	tegra_gpio_set(chip, offset, value);
 	tegra_gpio_mask_write(tgi, GPIO_MSK_OE(tgi, offset), offset, 1);
 	tegra_gpio_enable(tgi, offset);
@@ -286,6 +330,8 @@ static int tegra_gpio_get_direction(struct gpio_chip *chip,
 	u32 pin_mask = BIT(GPIO_BIT(offset));
 	u32 cnf, oe;
 
+	deb_verbose("\n");
+
 	cnf = tegra_gpio_readl(tgi, GPIO_CNF(tgi, offset));
 	if (!(cnf & pin_mask))
 		return -EINVAL;
@@ -337,6 +383,8 @@ static int tegra_gpio_set_config(struct gpio_chip *chip, unsigned int offset,
 {
 	u32 debounce;
 
+	deb_verbose("\n");
+
 	if (pinconf_to_config_param(config) != PIN_CONFIG_INPUT_DEBOUNCE)
 		return -ENOTSUPP;
 
@@ -348,6 +396,8 @@ static int tegra_gpio_to_irq(struct gpio_chip *chip, unsigned int offset)
 {
 	struct tegra_gpio_info *tgi = gpiochip_get_data(chip);
 
+	deb_verbose("\n");
+
 	return irq_find_mapping(tgi->irq_domain, offset);
 }
 
@@ -386,6 +436,8 @@ static int tegra_gpio_irq_set_type(struct irq_data *d, unsigned int type)
 	unsigned long flags;
 	u32 val;
 	int ret;
+	
+	deb_verbose("\n");
 
 	switch (type & IRQ_TYPE_SENSE_MASK) {
 	case IRQ_TYPE_EDGE_RISING:
@@ -448,6 +500,8 @@ static void tegra_gpio_irq_shutdown(struct irq_data *d)
 	struct tegra_gpio_bank *bank = irq_data_get_irq_chip_data(d);
 	struct tegra_gpio_info *tgi = bank->tgi;
 	unsigned int gpio = d->hwirq;
+	
+	deb_verbose("\n");
 
 	tegra_gpio_irq_mask(d);
 	gpiochip_unlock_as_irq(&tgi->gc, gpio);
@@ -495,7 +549,7 @@ static void tegra_gpio_irq_handler(struct irq_desc *desc)
 
 }
 
-#ifdef CONFIG_PM_SLEEP
+    #ifdef CONFIG_PM_SLEEP
 static void tegra_gpio_resume(void)
 {
 	struct tegra_gpio_info *tgi = gpio_info;
@@ -593,7 +647,7 @@ static int tegra_gpio_irq_set_wake(struct irq_data *d, unsigned int enable)
 #else
 #define tegra_gpio_suspend NULL
 #define tegra_gpio_resume NULL
-#endif
+    #endif
 
 static struct syscore_ops tegra_gpio_syscore_ops = {
 	.suspend = tegra_gpio_suspend,
@@ -602,7 +656,7 @@ static struct syscore_ops tegra_gpio_syscore_ops = {
 	.restore = tegra_gpio_resume,
 };
 
-#ifdef	CONFIG_DEBUG_FS
+    #ifdef	CONFIG_DEBUG_FS
 
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
@@ -616,6 +670,8 @@ static int tegra_dbg_gpio_show(struct seq_file *s, void *unused)
 	x = ' ';
 	y = 'A';
 
+	deb_verbose("\n");
+
 	seq_printf(s, "Name:Bank:Port CNF OE OUT IN INT_STA INT_ENB INT_LVL\n");
 	for (i = 0; i < tgi->bank_count; i++) {
 		for (j = 0; j < 4; j++) {
@@ -649,6 +705,8 @@ DEFINE_SHOW_ATTRIBUTE(tegra_dbg_gpio);
 
 static void tegra_gpio_debuginit(struct tegra_gpio_info *tgi)
 {
+	deb_verbose("\n");
+
 	debugfs_create_file("tegra_gpio", 0444, NULL, tgi,
 			    &tegra_dbg_gpio_fops);
 }
@@ -659,7 +717,7 @@ static inline void tegra_gpio_debuginit(struct tegra_gpio_info *tgi)
 {
 }
 
-#endif
+    #endif
 
 static int tegra_gpio_probe(struct platform_device *pdev)
 {
@@ -668,6 +726,8 @@ static int tegra_gpio_probe(struct platform_device *pdev)
 	unsigned int gpio, i, j;
 	int ret;
 
+	deb_verbose("\n");
+
 	tgi = devm_kzalloc(&pdev->dev, sizeof(*tgi), GFP_KERNEL);
 	if (!tgi)
 		return -ENODEV;
@@ -707,9 +767,9 @@ static int tegra_gpio_probe(struct platform_device *pdev)
 	tgi->ic.irq_unmask		= tegra_gpio_irq_unmask;
 	tgi->ic.irq_set_type		= tegra_gpio_irq_set_type;
 	tgi->ic.irq_shutdown		= tegra_gpio_irq_shutdown;
-#ifdef CONFIG_PM_SLEEP
+    #ifdef CONFIG_PM_SLEEP
 	tgi->ic.irq_set_wake		= tegra_gpio_irq_set_wake;
-#endif
+    #endif
 
 	platform_set_drvdata(pdev, tgi);
 
@@ -724,6 +784,7 @@ static int tegra_gpio_probe(struct platform_device *pdev)
 	tgi->irq_domain = irq_domain_add_linear(pdev->dev.of_node,
 						tgi->gc.ngpio,
 						&irq_domain_simple_ops, NULL);
+	deb_debug("irq_domain=%p\n", tgi->irq_domain);
 	if (!tgi->irq_domain)
 		return -ENODEV;
 
@@ -816,6 +877,7 @@ static struct platform_driver tegra_gpio_driver = {
 
 static int __init tegra_gpio_init(void)
 {
+	deb_verbose("\n");
 	return platform_driver_register(&tegra_gpio_driver);
 }
 subsys_initcall(tegra_gpio_init);
diff --git a/drivers/gpio/gpio-tegra186.c b/drivers/gpio/gpio-tegra186.c
index 5e57824b283e..0968b15d56d4 100644
--- a/drivers/gpio/gpio-tegra186.c
+++ b/drivers/gpio/gpio-tegra186.c
@@ -20,28 +20,152 @@
 #include <dt-bindings/gpio/tegra234-gpio.h>
 #include <dt-bindings/gpio/tegra239-gpio.h>
 
+// #define GPIO_DEBUG
+// #define GPIO_DEBUG_VERBOSE
+// #define GPIO_DEBUG_EXCEPTIONS
+
+// Compiler error directive
+#if defined(GPIO_DEBUG_EXCEPTIONS) && \
+    !(defined(CONFIG_TEGRA_GPIO_GUEST_PROXY) || defined(CONFIG_TEGRA_GPIO_HOST_PROXY))
+    #error "GPIO_DEBUG_EXCEPTIONS is defined, but neither CONFIG_TEGRA_GPIO_GUEST_PROXY nor CONFIG_TEGRA_GPIO_HOST_PROXY is defined."
+#endif
+
+#ifdef GPIO_DEBUG
+  /*
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+  #define deb_error(fmt, ...)    printk(KERN_ERR "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__ , kbasename(__FILE__), ##__VA_ARGS__)
+  */
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' -- " fmt, __func__, ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' -- " fmt, __func__, ##__VA_ARGS__)
+  #define deb_error(fmt, ...)    printk(KERN_ERR "GPIO func \'%s\' -- " fmt, __func__ , ##__VA_ARGS__)
+#else
+  #define deb_info(fmt, ...)
+  #define deb_debug(fmt, ...)
+  #define deb_error(fmt, ...)
+#endif
+
+#ifdef GPIO_DEBUG_VERBOSE
+  #define deb_verbose           deb_debug
+#else
+  #define deb_verbose(fmt, ...)
+#endif
+
+#if defined(GPIO_DEBUG_EXCEPTIONS)
+
+// starting at first byte
+// #define GPIO_NOPT_TEST0 0			// pmx_readl pmx_writel - defined in pinctrl-tegra.c
+#define GPIO_NOPT_TEST1 1			// tegra_gte_read tegra_gte_writel -- Note shared with pinctrl-tegra.c
+#define GPIO_NOPT_TEST2 2			// tegra186_gpio_probe gpio->base (when true, i.e. exception; no-pt)
+#define GPIO_NOPT_TEST3 3			// tegra186_gpio_init_route_mapping
+#define GPIO_NOPT_TEST4 4			// tegra186_gpio_probe (enable config part)
+#define GPIO_NOPT_TEST5 5			// tegra_gpio_resume_early
+#define GPIO_NOPT_TEST6 6			// gpio_is_accessible
+#define GPIO_NOPT_TEST7 7     // tegra186_gpio_probe gpio->secure (when true, i.e. exception; no-pt)
+
+// starting at second byte
+// if NOFUNC_TEST2 is set; error setting the GPIO line values: Operation not permitted
+#define GPIO_NOFUNC_TEST0A 0+8  // request				  // unset, passthrough ?	
+#define GPIO_NOFUNC_TEST0B 0+8  // free						  // unset, passthrough ?	
+#define GPIO_NOFUNC_TEST1 1+8   // get_direction	  // unset, passthrough ?
+#define GPIO_NOFUNC_TEST2A 2+8  // direction_input	// unset, passthrough ?
+#define GPIO_NOFUNC_TEST2B 2+8  // direction_output	// unset, passthrough ?	
+#define GPIO_NOFUNC_TEST3A 3+8  // get
+#define GPIO_NOFUNC_TEST3B 3+8  // set
+#define GPIO_NOFUNC_TEST4 4+8   // set_config
+#define GPIO_NOFUNC_TEST5A 5+8  // timestamp_control
+#define GPIO_NOFUNC_TEST5B 5+8  // timestamp_read
+#define GPIO_NOFUNC_TEST6 6+8   // suspend_configure
+#define GPIO_NOFUNC_TEST7 7+8   // add pin_ranges
+
+// GPIO_NOFUNC_TEST8-16 defined in gpio-tegra.c
+
+#define GPIO_BOTH_TEST 1+24      // allows setting 'both' test	
+#define GPIO_BOTHFUNC_TEST2 2+24  // get_direction
+#define GPIO_BOTHFUNC_TEST3 3+24  // direction_input
+#define GPIO_BOTHFUNC_TEST4 4+24  // direction_output
+
+/* note further declarations in gpio-proxy.c and pinctrl-tegra.c
+ * #define GPIO_RW_TEST31 31
+ * #define GPIO_NOPT_TEST0 0 
+ * 
+ * // continuing in second part of second section (third byte)
+ * #define TEST_OFFSET      8
+ * // third byte (offset starts at second byte)
+ * #define GPIO_NOPT_TEST8  8+TEST_OFFSET      // tegra_pinctrl_set_mux
+ * #define GPIO_NOPT_TEST9  9+TEST_OFFSET      // tegra_pinctrl_gpio_save_config
+ * #define GPIO_NOPT_TEST10 10+TEST_OFFSET     // tegra_pinctrl_gpio_restore_config
+ * #define GPIO_NOPT_TEST11 11+TEST_OFFSET     // tegra_pinctrl_gpio_request_enable
+ * #define GPIO_NOPT_TEST12 12+TEST_OFFSET     // tegra_pinctrl_gpio_set_input
+ * #define GPIO_NOPT_TEST13 13+TEST_OFFSET     // tegra_pinctrl_gpio_set_tristate
+ * #define GPIO_NOPT_TEST14 14+TEST_OFFSET     // tegra_pinconf_group_set
+ * #define GPIO_NOPT_TEST15 15+TEST_OFFSET     // tegra_pinctrl_clear_parked_bits
+ * // in fourth byte
+ * #define GPIO_NOPT_TEST16 16+TEST_OFFSET     // tegra_pinctrl_resume
+ */
+
+/* the value of debug_exceptions can be set with
+ * gpio_tegra186.debug_exceptions=0x81fffaff as
+ * kernel boot parameter
+ */
+
+static uint32_t debug_exceptions=0x81fff8ff;    // alternative guess for correct value,
+// static uint32_t debug_exceptions=0x81ff00ff;    // alternativr guess for correct value,
+// static uint32_t debug_exceptions=0x81ff88ff;    // alternative guess for correct value,
+																								
+// Declare debug_exceptions as a module parameter
+module_param(debug_exceptions, uint, S_IRUGO);
+MODULE_PARM_DESC(debug_exceptions, "Debug boot parameter for setting exeptions to handling of GPIO passthrough");
+
+// construct to ease debugging. if bit is set -> then debug exception is active
+inline bool is_debug_exception(int off) { return (debug_exceptions >> off) & 0x00000001;  }
+void set_debug_exceptions(uint32_t exceptions) {
+  debug_exceptions = exceptions;
+}
+#else
+#define is_debug_exception(...) false
+#endif  // GPIO_DEBUG_EXCEPTIONS
+
+// low level inline hooks for readl and writel
+#include <gpio-proxy.h>  // note: compile directives set in this file are used in gpio-proxy.h
+
+#if defined(CONFIG_TEGRA_GPIO_GUEST_PROXY) || \
+    defined(CONFIG_TEGRA_GPIO_HOST_PROXY)
+  #include "gpiolib.h"
+  #include <linux/delay.h>
+
+  int gpio_outloud = 0;
+  EXPORT_SYMBOL_GPL(gpio_outloud);
+
+  bool kernel_is_on_guest = false;
+  uint64_t gpio_vpa = 0;
+
+  extern struct gpio_chip *find_chip_by_name(const char *name);
+  extern const char **tegra_chiplabel;
+#endif
+
 /* security registers */
 #define TEGRA186_GPIO_CTL_SCR 0x0c
-#define  TEGRA186_GPIO_CTL_SCR_SEC_WEN BIT(28)
-#define  TEGRA186_GPIO_CTL_SCR_SEC_REN BIT(27)
+#define TEGRA186_GPIO_CTL_SCR_SEC_WEN BIT(28)
+#define TEGRA186_GPIO_CTL_SCR_SEC_REN BIT(27)
 
 #define TEGRA186_GPIO_INT_ROUTE_MAPPING(p, x) (0x14 + (p) * 0x20 + (x) * 4)
 
-#define GPIO_VM_REG				0x00
-#define GPIO_VM_RW				0x03
-#define GPIO_SCR_REG				0x04
-#define GPIO_SCR_DIFF				0x08
-#define GPIO_SCR_BASE_DIFF			0x40
-#define GPIO_SCR_SEC_WEN			BIT(28)
-#define GPIO_SCR_SEC_REN			BIT(27)
-#define GPIO_SCR_SEC_G1W			BIT(9)
-#define GPIO_SCR_SEC_G1R			BIT(1)
-#define GPIO_FULL_ACCESS			(GPIO_SCR_SEC_WEN | \
-						 GPIO_SCR_SEC_REN | \
-						 GPIO_SCR_SEC_G1R | \
-						 GPIO_SCR_SEC_G1W)
-#define GPIO_SCR_SEC_ENABLE			(GPIO_SCR_SEC_WEN | \
-						 GPIO_SCR_SEC_REN)
+#define GPIO_VM_REG       0x00
+#define GPIO_VM_RW        0x03
+#define GPIO_SCR_REG        0x04
+#define GPIO_SCR_DIFF       0x08
+#define GPIO_SCR_BASE_DIFF      0x40
+#define GPIO_SCR_SEC_WEN      BIT(28)
+#define GPIO_SCR_SEC_REN      BIT(27)
+#define GPIO_SCR_SEC_G1W      BIT(9)
+#define GPIO_SCR_SEC_G1R      BIT(1)
+#define GPIO_FULL_ACCESS      (GPIO_SCR_SEC_WEN | \
+             GPIO_SCR_SEC_REN | \
+             GPIO_SCR_SEC_G1R | \
+             GPIO_SCR_SEC_G1W)
+#define GPIO_SCR_SEC_ENABLE     (GPIO_SCR_SEC_WEN | \
+             GPIO_SCR_SEC_REN)
 
 /* control registers */
 #define TEGRA186_GPIO_ENABLE_CONFIG 0x00
@@ -75,45 +199,45 @@
 
 /******************** GTE Registers ******************************/
 
-#define GTE_GPIO_TECTRL				0x0
-#define GTE_GPIO_TETSCH				0x4
-#define GTE_GPIO_TETSCL				0x8
-#define GTE_GPIO_TESRC				0xC
-#define GTE_GPIO_TECCV				0x10
-#define GTE_GPIO_TEPCV				0x14
-#define GTE_GPIO_TEENCV				0x18
-#define GTE_GPIO_TECMD				0x1C
-#define GTE_GPIO_TESTATUS			0x20
-#define GTE_GPIO_SLICE0_TETEN			0x40
-#define GTE_GPIO_SLICE0_TETDIS			0x44
-#define GTE_GPIO_SLICE1_TETEN			0x60
-#define GTE_GPIO_SLICE1_TETDIS			0x64
-#define GTE_GPIO_SLICE2_TETEN			0x80
-#define GTE_GPIO_SLICE2_TETDIS			0x84
-
-#define GTE_GPIO_TECTRL_ENABLE_SHIFT		0
-#define GTE_GPIO_TECTRL_ENABLE_MASK		0x1
-#define GTE_GPIO_TECTRL_ENABLE_DISABLE		0x0
-#define GTE_GPIO_TECTRL_ENABLE_ENABLE		0x1
-
-#define GTE_GPIO_TESRC_SLICE_SHIFT		16
-#define GTE_GPIO_TESRC_SLICE_DEFAULT_MASK	0xFF
-
-#define GTE_GPIO_TECMD_CMD_POP			0x1
-
-#define GTE_GPIO_TESTATUS_OCCUPANCY_SHIFT	8
-#define GTE_GPIO_TESTATUS_OCCUPANCY_MASK	0xFF
-
-#define AON_GPIO_SLICE1_MAP			0x3000
-#define AON_GPIO_SLICE2_MAP			0xFFFFFFF
-#define AON_GPIO_SLICE1_INDEX			1
-#define AON_GPIO_SLICE2_INDEX			2
-#define BASE_ADDRESS_GTE_GPIO_SLICE0		0x40
-#define BASE_ADDRESS_GTE_GPIO_SLICE1		0x60
-#define BASE_ADDRESS_GTE_GPIO_SLICE2		0x80
+#define GTE_GPIO_TECTRL       0x0
+#define GTE_GPIO_TETSCH       0x4
+#define GTE_GPIO_TETSCL       0x8
+#define GTE_GPIO_TESRC        0xC
+#define GTE_GPIO_TECCV        0x10
+#define GTE_GPIO_TEPCV        0x14
+#define GTE_GPIO_TEENCV       0x18
+#define GTE_GPIO_TECMD        0x1C
+#define GTE_GPIO_TESTATUS     0x20
+#define GTE_GPIO_SLICE0_TETEN     0x40
+#define GTE_GPIO_SLICE0_TETDIS      0x44
+#define GTE_GPIO_SLICE1_TETEN     0x60
+#define GTE_GPIO_SLICE1_TETDIS      0x64
+#define GTE_GPIO_SLICE2_TETEN     0x80
+#define GTE_GPIO_SLICE2_TETDIS      0x84
+
+#define GTE_GPIO_TECTRL_ENABLE_SHIFT    0
+#define GTE_GPIO_TECTRL_ENABLE_MASK   0x1
+#define GTE_GPIO_TECTRL_ENABLE_DISABLE    0x0
+#define GTE_GPIO_TECTRL_ENABLE_ENABLE   0x1
+
+#define GTE_GPIO_TESRC_SLICE_SHIFT    16
+#define GTE_GPIO_TESRC_SLICE_DEFAULT_MASK 0xFF
+
+#define GTE_GPIO_TECMD_CMD_POP      0x1
+
+#define GTE_GPIO_TESTATUS_OCCUPANCY_SHIFT 8
+#define GTE_GPIO_TESTATUS_OCCUPANCY_MASK  0xFF
+
+#define AON_GPIO_SLICE1_MAP     0x3000
+#define AON_GPIO_SLICE2_MAP     0xFFFFFFF
+#define AON_GPIO_SLICE1_INDEX     1
+#define AON_GPIO_SLICE2_INDEX     2
+#define BASE_ADDRESS_GTE_GPIO_SLICE0    0x40
+#define BASE_ADDRESS_GTE_GPIO_SLICE1    0x60
+#define BASE_ADDRESS_GTE_GPIO_SLICE2    0x80
 
 #define GTE_GPIO_SLICE_SIZE (BASE_ADDRESS_GTE_GPIO_SLICE1 - \
-			     BASE_ADDRESS_GTE_GPIO_SLICE0)
+           BASE_ADDRESS_GTE_GPIO_SLICE0)
 
 /* AON GPIOS are mapped to only slice 1 and slice 2 */
 /* GTE Interrupt connections. For slice 1 */
@@ -180,235 +304,253 @@
 /**************************************************************/
 
 struct tegra_gpio_port {
-	const char *name;
-	unsigned int bank;
-	unsigned int port;
-	unsigned int pins;
+  const char *name;
+  unsigned int bank;
+  unsigned int port;
+  unsigned int pins;
 };
 
 struct tegra186_pin_range {
-	unsigned int offset;
-	const char *group;
+  unsigned int offset;
+  const char *group;
 };
 
 struct tegra_gpio_soc {
-	const struct tegra_gpio_port *ports;
-	unsigned int num_ports;
-	const char *name;
-	unsigned int instance;
-	unsigned int num_irqs_per_bank;
-	bool is_hw_ts_sup;
-	bool do_vm_check;
-	const struct tegra186_pin_range *pin_ranges;
-	unsigned int num_pin_ranges;
-	const char *pinmux;
-	const struct tegra_gte_info *gte_info;
-	int gte_npins;
+       const struct tegra_gpio_port *ports;
+       unsigned int num_ports;
+       const char *name;
+       unsigned int instance;
+       unsigned int num_irqs_per_bank;
+       bool is_hw_ts_sup;
+       bool do_vm_check;
+       const struct tegra186_pin_range *pin_ranges;
+       unsigned int num_pin_ranges;
+       const char *pinmux;
+       const struct tegra_gte_info *gte_info;
+       int gte_npins;
 };
 
 struct tegra_gpio_saved_register {
-	bool restore_needed;
-	u32 val;
-	u32 conf;
-	u32 out;
+       bool restore_needed;
+       u32 val;
+       u32 conf;
+       u32 out;
 };
 
 struct tegra_gpio {
-	struct gpio_chip gpio;
-	struct irq_chip intc;
-	unsigned int num_irq;
-	unsigned int *irq;
-
-	const struct tegra_gpio_soc *soc;
-	unsigned int num_irqs_per_bank;
-	unsigned int num_banks;
-	unsigned int gte_enable;
-	bool use_timestamp;
-
-	void __iomem *secure;
-	void __iomem *base;
-	void __iomem *gte_regs;
-	struct tegra_gpio_saved_register *gpio_rval;
+  struct gpio_chip gpio;
+  struct irq_chip intc;
+  unsigned int num_irq;
+  unsigned int *irq;
+
+  const struct tegra_gpio_soc *soc;
+  unsigned int num_irqs_per_bank;
+  unsigned int num_banks;
+  unsigned int gte_enable;
+  bool use_timestamp;
+
+  void __iomem *secure;
+  void __iomem *base;
+  void __iomem *gte_regs;
+  struct tegra_gpio_saved_register *gpio_rval;
 };
 
 /*************************** GTE related code ********************/
 
 struct tegra_gte_info {
-	uint32_t pin_num;
-	uint32_t slice;
-	uint32_t slice_bit;
+  uint32_t pin_num;
+  uint32_t slice;
+  uint32_t slice_bit;
 };
 
 /* Structure to maintain all information about the AON GPIOs
  * that can be supported
  */
 static struct tegra_gte_info tegra194_gte_info[] = {
-	/* pin_num, slice, slice_bit*/
-	[0]  = {11, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_0},
-	[1]  = {10, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_1},
-	[2]  = {9,  2, NV_AON_GTE_SLICE2_IRQ_GPIO_2},
-	[3]  = {8,  2, NV_AON_GTE_SLICE2_IRQ_GPIO_3},
-	[4]  = {7,  2, NV_AON_GTE_SLICE2_IRQ_GPIO_4},
-	[5]  = {6,  2, NV_AON_GTE_SLICE2_IRQ_GPIO_5},
-	[6]  = {5,  2, NV_AON_GTE_SLICE2_IRQ_GPIO_6},
-	[7]  = {4,  2, NV_AON_GTE_SLICE2_IRQ_GPIO_7},
-	[8]  = {3,  2, NV_AON_GTE_SLICE2_IRQ_GPIO_8},
-	[9]  = {2,  2, NV_AON_GTE_SLICE2_IRQ_GPIO_9},
-	[10] = {1,  2, NV_AON_GTE_SLICE2_IRQ_GPIO_10},
-	[11] = {0,  2, NV_AON_GTE_SLICE2_IRQ_GPIO_11},
-	[12] = {26, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_12},
-	[13] = {25, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_13},
-	[14] = {24, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_14},
-	[15] = {23, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_15},
-	[16] = {22, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_16},
-	[17] = {21, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_17},
-	[18] = {20, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_18},
-	[19] = {19, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_19},
-	[20] = {18, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_20},
-	[21] = {17, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_21},
-	[22] = {16, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_22},
-	[23] = {38, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_23},
-	[24] = {37, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_24},
-	[25] = {36, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_25},
-	[26] = {35, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_26},
-	[27] = {34, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_27},
-	[28] = {33, 1, NV_AON_GTE_SLICE1_IRQ_GPIO_28},
-	[29] = {32, 1, NV_AON_GTE_SLICE1_IRQ_GPIO_29},
+  /* pin_num, slice, slice_bit*/
+  [0]  = {11, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_0},
+  [1]  = {10, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_1},
+  [2]  = {9,  2, NV_AON_GTE_SLICE2_IRQ_GPIO_2},
+  [3]  = {8,  2, NV_AON_GTE_SLICE2_IRQ_GPIO_3},
+  [4]  = {7,  2, NV_AON_GTE_SLICE2_IRQ_GPIO_4},
+  [5]  = {6,  2, NV_AON_GTE_SLICE2_IRQ_GPIO_5},
+  [6]  = {5,  2, NV_AON_GTE_SLICE2_IRQ_GPIO_6},
+  [7]  = {4,  2, NV_AON_GTE_SLICE2_IRQ_GPIO_7},
+  [8]  = {3,  2, NV_AON_GTE_SLICE2_IRQ_GPIO_8},
+  [9]  = {2,  2, NV_AON_GTE_SLICE2_IRQ_GPIO_9},
+  [10] = {1,  2, NV_AON_GTE_SLICE2_IRQ_GPIO_10},
+  [11] = {0,  2, NV_AON_GTE_SLICE2_IRQ_GPIO_11},
+  [12] = {26, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_12},
+  [13] = {25, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_13},
+  [14] = {24, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_14},
+  [15] = {23, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_15},
+  [16] = {22, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_16},
+  [17] = {21, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_17},
+  [18] = {20, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_18},
+  [19] = {19, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_19},
+  [20] = {18, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_20},
+  [21] = {17, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_21},
+  [22] = {16, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_22},
+  [23] = {38, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_23},
+  [24] = {37, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_24},
+  [25] = {36, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_25},
+  [26] = {35, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_26},
+  [27] = {34, 2, NV_AON_GTE_SLICE2_IRQ_GPIO_27},
+  [28] = {33, 1, NV_AON_GTE_SLICE1_IRQ_GPIO_28},
+  [29] = {32, 1, NV_AON_GTE_SLICE1_IRQ_GPIO_29},
 };
 
 static inline u32 tegra_gte_readl(struct tegra_gpio *tgi, u32 reg)
 {
-	return __raw_readl(tgi->gte_regs + reg);
+#if defined(GPIO_DEBUG_EXCEPTIONS)
+  if (!is_debug_exception(GPIO_NOPT_TEST1))
+    return __raw_readl_x(tgi->gte_regs + reg);
+  else
+#endif
+    return __raw_readl(tgi->gte_regs + reg);
 }
 
 static inline void tegra_gte_writel(struct tegra_gpio *tgi, u32 reg,
-		u32 val)
+    u32 val)
 {
-	__raw_writel(val, tgi->gte_regs + reg);
+#if defined(GPIO_DEBUG_EXCEPTIONS)
+  if (!is_debug_exception(GPIO_NOPT_TEST1))
+    __raw_writel_x(val, tgi->gte_regs + reg);
+  else
+#endif
+		__raw_writel(val, tgi->gte_regs + reg);
 }
 
 static void tegra_gte_flush_fifo(struct tegra_gpio *tgi)
 {
-	/* Check if FIFO is empty */
-	while ((tegra_gte_readl(tgi, GTE_GPIO_TESTATUS) >>
-		GTE_GPIO_TESTATUS_OCCUPANCY_SHIFT) &
-		GTE_GPIO_TESTATUS_OCCUPANCY_MASK) {
-		/* Pop this entry, go to next */
-		tegra_gte_writel(tgi, GTE_GPIO_TECMD, GTE_GPIO_TECMD_CMD_POP);
-	}
+  /* Check if FIFO is empty */
+  while ((tegra_gte_readl(tgi, GTE_GPIO_TESTATUS) >>
+    GTE_GPIO_TESTATUS_OCCUPANCY_SHIFT) &
+    GTE_GPIO_TESTATUS_OCCUPANCY_MASK) {
+    /* Pop this entry, go to next */
+    tegra_gte_writel(tgi, GTE_GPIO_TECMD, GTE_GPIO_TECMD_CMD_POP);
+  }
 }
 
 u64 tegra_gte_read_fifo(struct tegra_gpio *tgi, u32 offset)
 {
-	u32 src_slice;
-	u32 tsh, tsl;
-	u64 ts = 0;
-	u32 precv, curcv, xorcv;
-	u32 aon_bits;
-	u32 bit_index = 0;
-
-	/* Check if FIFO is empty */
-	while ((tegra_gte_readl(tgi, GTE_GPIO_TESTATUS) >>
-		GTE_GPIO_TESTATUS_OCCUPANCY_SHIFT) &
-		GTE_GPIO_TESTATUS_OCCUPANCY_MASK) {
-		src_slice = (tegra_gte_readl(tgi, GTE_GPIO_TESRC) >>
-				GTE_GPIO_TESRC_SLICE_SHIFT) &
-			GTE_GPIO_TESRC_SLICE_DEFAULT_MASK;
-
-		if (src_slice == AON_GPIO_SLICE1_INDEX ||
-		    src_slice == AON_GPIO_SLICE2_INDEX) {
-			precv = tegra_gte_readl(tgi, GTE_GPIO_TEPCV);
-			curcv = tegra_gte_readl(tgi, GTE_GPIO_TECCV);
-
-			/* Save TSC high and low 32 bits value */
-			tsh = tegra_gte_readl(tgi, GTE_GPIO_TETSCH);
-			tsl = tegra_gte_readl(tgi, GTE_GPIO_TETSCL);
-
-			/* TSC countre as 64 bits */
-			ts  = (((uint64_t)tsh << 32) | tsl);
-
-			xorcv = precv ^ curcv;
-			if (src_slice == AON_GPIO_SLICE1_INDEX)
-				aon_bits = xorcv & AON_GPIO_SLICE1_MAP;
-			else
-				aon_bits = xorcv & AON_GPIO_SLICE2_MAP;
-
-			bit_index = ffs(aon_bits) - 1;
-		}
-		/* Pop this entry, go to next */
-		tegra_gte_writel(tgi, GTE_GPIO_TECMD, GTE_GPIO_TECMD_CMD_POP);
-		tegra_gte_readl(tgi, GTE_GPIO_TESRC);
-	}
-
-	return (tgi->soc->gte_info[bit_index].pin_num == offset) ? ts : 0;
+  u32 src_slice;
+  u32 tsh, tsl;
+  u64 ts = 0;
+  u32 precv, curcv, xorcv;
+  u32 aon_bits;
+  u32 bit_index = 0;
+
+  // deb_verbose("\n");
+
+  /* Check if FIFO is empty */
+  while ((tegra_gte_readl(tgi, GTE_GPIO_TESTATUS) >>
+    GTE_GPIO_TESTATUS_OCCUPANCY_SHIFT) &
+    GTE_GPIO_TESTATUS_OCCUPANCY_MASK) {
+    src_slice = (tegra_gte_readl(tgi, GTE_GPIO_TESRC) >>
+        GTE_GPIO_TESRC_SLICE_SHIFT) &
+      GTE_GPIO_TESRC_SLICE_DEFAULT_MASK;
+
+    if (src_slice == AON_GPIO_SLICE1_INDEX ||
+        src_slice == AON_GPIO_SLICE2_INDEX) {
+      precv = tegra_gte_readl(tgi, GTE_GPIO_TEPCV);
+      curcv = tegra_gte_readl(tgi, GTE_GPIO_TECCV);
+
+      /* Save TSC high and low 32 bits value */
+      tsh = tegra_gte_readl(tgi, GTE_GPIO_TETSCH);
+      tsl = tegra_gte_readl(tgi, GTE_GPIO_TETSCL);
+
+      /* TSC countre as 64 bits */
+      ts  = (((uint64_t)tsh << 32) | tsl);
+
+      xorcv = precv ^ curcv;
+      if (src_slice == AON_GPIO_SLICE1_INDEX)
+        aon_bits = xorcv & AON_GPIO_SLICE1_MAP;
+      else
+        aon_bits = xorcv & AON_GPIO_SLICE2_MAP;
+
+      bit_index = ffs(aon_bits) - 1;
+    }
+    /* Pop this entry, go to next */
+    tegra_gte_writel(tgi, GTE_GPIO_TECMD, GTE_GPIO_TECMD_CMD_POP);
+    tegra_gte_readl(tgi, GTE_GPIO_TESRC);
+  }
+
+  return (tgi->soc->gte_info[bit_index].pin_num == offset) ? ts : 0;
 }
 
 int tegra_gte_enable_ts(struct tegra_gpio *tgi, u32 offset)
 {
-	u32 val, mask, reg;
-	int i = 0;
-
-	if (tgi->gte_enable == 1) {
-		dev_err(tgi->gpio.parent, "timestamp is already enabled for gpio\n");
-		return -EINVAL;
-	}
-
-	/* Configure Timestamping AON GPIO to SLICEx mapping */
-	for (i = 0; i < tgi->soc->gte_npins; i++) {
-		if (tgi->soc->gte_info[i].pin_num == offset) {
-			reg = (tgi->soc->gte_info[i].slice *
-			       GTE_GPIO_SLICE_SIZE) + GTE_GPIO_SLICE0_TETEN;
-			val = (1 << tgi->soc->gte_info[i].slice_bit);
-			tegra_gte_writel(tgi, reg, val);
-			break;
-		}
-	}
-
-	val = tegra_gte_readl(tgi, GTE_GPIO_TECTRL);
-	mask = (GTE_GPIO_TECTRL_ENABLE_MASK << GTE_GPIO_TECTRL_ENABLE_SHIFT);
-	val &= ~mask;
-	val |= (GTE_GPIO_TECTRL_ENABLE_ENABLE << GTE_GPIO_TECTRL_ENABLE_SHIFT);
-	tegra_gte_writel(tgi, GTE_GPIO_TECTRL, val);
-
-	tegra_gte_flush_fifo(tgi);
-
-	tgi->gte_enable = 1;
-
-	return 0;
+  u32 val, mask, reg;
+  int i = 0;
+
+  // deb_verbose("\n");
+
+  if (tgi->gte_enable == 1) {
+    dev_err(tgi->gpio.parent, "timestamp is already enabled for gpio\n");
+    return -EINVAL;
+  }
+
+  /* Configure Timestamping AON GPIO to SLICEx mapping */
+  for (i = 0; i < tgi->soc->gte_npins; i++) {
+    if (tgi->soc->gte_info[i].pin_num == offset) {
+      reg = (tgi->soc->gte_info[i].slice *
+             GTE_GPIO_SLICE_SIZE) + GTE_GPIO_SLICE0_TETEN;
+      val = (1 << tgi->soc->gte_info[i].slice_bit);
+      tegra_gte_writel(tgi, reg, val);
+      break;
+    }
+  }
+
+  val = tegra_gte_readl(tgi, GTE_GPIO_TECTRL);
+  mask = (GTE_GPIO_TECTRL_ENABLE_MASK << GTE_GPIO_TECTRL_ENABLE_SHIFT);
+  val &= ~mask;
+  val |= (GTE_GPIO_TECTRL_ENABLE_ENABLE << GTE_GPIO_TECTRL_ENABLE_SHIFT);
+  tegra_gte_writel(tgi, GTE_GPIO_TECTRL, val);
+
+  tegra_gte_flush_fifo(tgi);
+
+  tgi->gte_enable = 1;
+
+  return 0;
 }
 
 int tegra_gte_disable_ts(struct tegra_gpio *tgi, u32 offset)
 {
-	u32 val, mask;
+  u32 val, mask;
 
-	if (tgi->gte_enable == 0) {
-		dev_err(tgi->gpio.parent, "timestamp is already disabled\n");
-		return 0;
-	}
+  // deb_verbose("\n");
 
-	val = tegra_gte_readl(tgi, GTE_GPIO_TECTRL);
-	mask = (GTE_GPIO_TECTRL_ENABLE_MASK << GTE_GPIO_TECTRL_ENABLE_SHIFT);
-	val &= ~mask;
-	val |= (GTE_GPIO_TECTRL_ENABLE_DISABLE << GTE_GPIO_TECTRL_ENABLE_SHIFT);
-	tegra_gte_writel(tgi, GTE_GPIO_TECTRL, val);
+  if (tgi->gte_enable == 0) {
+    dev_err(tgi->gpio.parent, "timestamp is already disabled\n");
+    return 0;
+  }
 
-	/* Disable Slice mapping as well */
-	tegra_gte_writel(tgi, (AON_GPIO_SLICE1_INDEX * GTE_GPIO_SLICE_SIZE) +
-			GTE_GPIO_SLICE0_TETEN, 0);
-	tegra_gte_writel(tgi, (AON_GPIO_SLICE2_INDEX * GTE_GPIO_SLICE_SIZE) +
-			GTE_GPIO_SLICE0_TETEN, 0);
+  val = tegra_gte_readl(tgi, GTE_GPIO_TECTRL);
+  mask = (GTE_GPIO_TECTRL_ENABLE_MASK << GTE_GPIO_TECTRL_ENABLE_SHIFT);
+  val &= ~mask;
+  val |= (GTE_GPIO_TECTRL_ENABLE_DISABLE << GTE_GPIO_TECTRL_ENABLE_SHIFT);
+  tegra_gte_writel(tgi, GTE_GPIO_TECTRL, val);
 
-	tgi->gte_enable = 0;
+  /* Disable Slice mapping as well */
+  tegra_gte_writel(tgi, (AON_GPIO_SLICE1_INDEX * GTE_GPIO_SLICE_SIZE) +
+      GTE_GPIO_SLICE0_TETEN, 0);
+  tegra_gte_writel(tgi, (AON_GPIO_SLICE2_INDEX * GTE_GPIO_SLICE_SIZE) +
+      GTE_GPIO_SLICE0_TETEN, 0);
 
-	return 0;
+  tgi->gte_enable = 0;
+
+  return 0;
 }
 
 int tegra_gte_setup(struct tegra_gpio *tgi)
 {
-	tegra_gte_writel(tgi, GTE_GPIO_TECTRL, 0);
-	tgi->gte_enable = 0;
+  // deb_verbose("\n");
+
+  tegra_gte_writel(tgi, GTE_GPIO_TECTRL, 0);
+  tgi->gte_enable = 0;
 
-	return 0;
+  return 0;
 }
 
 /*****************************************************************/
@@ -416,1314 +558,1971 @@ int tegra_gte_setup(struct tegra_gpio *tgi)
 static const struct tegra_gpio_port *
 tegra186_gpio_get_port(struct tegra_gpio *gpio, unsigned int *pin)
 {
-	unsigned int start = 0, i;
+  unsigned int start = 0, i;
 
-	for (i = 0; i < gpio->soc->num_ports; i++) {
-		const struct tegra_gpio_port *port = &gpio->soc->ports[i];
+  // deb_verbose("GPIO, chip \n", gpio->gpio.label);
 
-		if (*pin >= start && *pin < start + port->pins) {
-			*pin -= start;
-			return port;
-		}
+  for (i = 0; i < gpio->soc->num_ports; i++) {
+    const struct tegra_gpio_port *port = &gpio->soc->ports[i];
 
-		start += port->pins;
-	}
+    if (*pin >= start && *pin < start + port->pins) {
+      *pin -= start;
+      return port;
+    }
+
+    start += port->pins;
+  }
 
-	return NULL;
+  return NULL;
 }
 
 static void __iomem *tegra186_gpio_get_base(struct tegra_gpio *gpio,
-					    unsigned int pin)
+              unsigned int pin)
 {
-	const struct tegra_gpio_port *port;
-	unsigned int offset;
+  const struct tegra_gpio_port *port;
+  unsigned int offset;
 
-	port = tegra186_gpio_get_port(gpio, &pin);
-	if (!port)
-		return NULL;
+  // deb_verbose("GPIO, chip \n", gpio->gpio.label);
 
-	offset = port->bank * 0x1000 + port->port * 0x200;
+  port = tegra186_gpio_get_port(gpio, &pin);
+  if (!port)
+    return NULL;
 
-	return gpio->base + offset + pin * 0x20;
+  offset = port->bank * 0x1000 + port->port * 0x200;
+
+  return gpio->base + offset + pin * 0x20;
 }
 
-static void __iomem *tegra186_gpio_get_secure(struct tegra_gpio *gpio,
-					    unsigned int pin)
-{
-	const struct tegra_gpio_port *port;
-	unsigned int offset;
+inline struct tegra_gpio * find_tegra_chip_by_id(int id);
 
-	port = tegra186_gpio_get_port(gpio, &pin);
-	if (!port)
-		return NULL;
-	offset = port->bank * 0x1000 + port->port * GPIO_SCR_BASE_DIFF;
+#if defined(CONFIG_TEGRA_GPIO_GUEST_PROXY) || defined(CONFIG_TEGRA_GPIO_HOST_PROXY)
+// executes tegra186_gpio_get_base in host as a proxy for guest
+void __iomem *tegra186_gpio_get_base_execute(int id, unsigned int pin)
+  {
+    struct tegra_gpio *gpio = find_tegra_chip_by_id(id);
+    return tegra186_gpio_get_base(gpio, pin);
+  }
+EXPORT_SYMBOL_GPL(tegra186_gpio_get_base_execute);
+#endif
 
-	return gpio->secure + offset + pin * GPIO_SCR_DIFF;
+#if defined(CONFIG_TEGRA_GPIO_GUEST_PROXY) || defined(CONFIG_TEGRA_GPIO_HOST_PROXY)
+// redirect function
+static inline void __iomem *tegra186_gpio_get_base_r(struct tegra_gpio *tgpio, unsigned int pin) {
+    return tegra186_gpio_get_base_redirect(tgpio->gpio.gpiodev->id, pin);
 }
+#endif
 
-static inline bool gpio_is_accessible(struct tegra_gpio *gpio, u32 pin)
+static void __iomem *tegra186_gpio_get_secure(struct tegra_gpio *gpio,
+              unsigned int pin)
 {
-	void __iomem *secure;
-	u32 val;
-
-	secure = tegra186_gpio_get_secure(gpio, pin);
-	if (gpio->soc->do_vm_check) {
-		val = __raw_readl(secure + GPIO_VM_REG);
-		if ((val & GPIO_VM_RW) != GPIO_VM_RW)
-			return false;
-	}
-
-	val = __raw_readl(secure + GPIO_SCR_REG);
+  const struct tegra_gpio_port *port;
+  unsigned int offset;
 
-	if ((val & (GPIO_SCR_SEC_ENABLE)) == 0)
-		return true;
+  // deb_verbose("GPIO, chip \n", gpio->gpio.label);
 
-	if ((val & (GPIO_FULL_ACCESS)) == GPIO_FULL_ACCESS)
-		return true;
+  port = tegra186_gpio_get_port(gpio, &pin);
+  if (!port)
+    return NULL;
+  offset = port->bank * 0x1000 + port->port * GPIO_SCR_BASE_DIFF;
 
-	return false;
+  return gpio->secure + offset + pin * GPIO_SCR_DIFF;
 }
 
-static int tegra186_gpio_get_direction(struct gpio_chip *chip,
-				       unsigned int offset)
+static inline bool gpio_is_accessible(struct tegra_gpio *gpio, u32 pin)
 {
-	struct tegra_gpio *gpio = gpiochip_get_data(chip);
-	void __iomem *base;
-	u32 value;
+  void __iomem *secure;
+  u32 val;
+
+  // deb_verbose("\n");
+  // No passthroughs in this function
+  
+  secure = tegra186_gpio_get_secure(gpio, pin);
+  if (gpio->soc->do_vm_check) {
+		
+		
+		#if defined(GPIO_DEBUG_EXCEPTIONS)
+		if (!is_debug_exception(GPIO_NOPT_TEST6))
+			val = __raw_readl_x(secure + GPIO_VM_REG);
+		else {
+			// deb_verbose("Debug exception %d", GPIO_NOPT_TEST6);
+		#endif
+			val = __raw_readl(secure + GPIO_VM_REG);
+		#if defined(GPIO_DEBUG_EXCEPTIONS)
+		}
+		#endif
+    deb_verbose("Access check reading 0x%p (secure=0x%p): %d", secure + GPIO_VM_REG, secure, val);
+    if ((val & GPIO_VM_RW) != GPIO_VM_RW)
+      return false;
+  }
+
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+	if (!is_debug_exception(GPIO_NOPT_TEST6))
+		val = __raw_readl_x(secure + GPIO_SCR_REG);
+	else {
+		// deb_verbose("Debug exception %d", GPIO_NOPT_TEST6);
+	#endif
+		val = __raw_readl(secure + GPIO_SCR_REG);
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+		}
+	#endif
 
-	if (!gpio_is_accessible(gpio, offset))
-		return -EPERM;
+  if ((val & (GPIO_SCR_SEC_ENABLE)) == 0)
+    return true;
 
-	base = tegra186_gpio_get_base(gpio, offset);
-	if (WARN_ON(base == NULL))
-		return -ENODEV;
+  if ((val & (GPIO_FULL_ACCESS)) == GPIO_FULL_ACCESS)
+    return true;
 
-	value = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);
-	if (value & TEGRA186_GPIO_ENABLE_CONFIG_OUT)
-		return GPIO_LINE_DIRECTION_OUT;
+  return false;
+}
 
-	return GPIO_LINE_DIRECTION_IN;
+// function has passthrough version
+int tegra186_gpio_get_direction(struct gpio_chip *chip,
+               unsigned int offset)
+{
+  struct tegra_gpio *gpio = gpiochip_get_data(chip);
+  void __iomem *base;
+  u32 value;
+
+  deb_verbose("GPIO, chip %s, offset %u\n", chip->label, offset);
+
+  if (!gpio_is_accessible(gpio, offset)) {
+    deb_verbose("GPIO error: gpio is not accessible %d", __LINE__);
+    return -EPERM;
+  }
+
+  deb_verbose("trace:%d", __LINE__);
+  base = tegra186_gpio_get_base(gpio, offset);
+  if (WARN_ON(base == NULL))
+    return -ENODEV;
+
+  deb_verbose("trace:%d", __LINE__);
+  value = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);
+  deb_verbose("trace:%d", __LINE__);
+  if (value & TEGRA186_GPIO_ENABLE_CONFIG_OUT) {
+    deb_verbose("Direction: LINE_OUT\n");
+    return GPIO_LINE_DIRECTION_OUT;
+  }
+
+  deb_verbose("Direction: LINE_IN\n");
+  return GPIO_LINE_DIRECTION_IN;
 }
 
-static int tegra186_gpio_direction_input(struct gpio_chip *chip,
-					 unsigned int offset)
+// function has passthrough version
+int tegra186_gpio_direction_input(struct gpio_chip *chip,
+           unsigned int offset)
 {
-	struct tegra_gpio *gpio = gpiochip_get_data(chip);
-	void __iomem *base;
-	u32 value;
-	int ret = 0;
-
-	if (!gpio_is_accessible(gpio, offset))
-		return -EPERM;
-
-	base = tegra186_gpio_get_base(gpio, offset);
-	if (WARN_ON(base == NULL))
-		return -ENODEV;
-
-	value = readl(base + TEGRA186_GPIO_OUTPUT_CONTROL);
-	value |= TEGRA186_GPIO_OUTPUT_CONTROL_FLOATED;
-	writel(value, base + TEGRA186_GPIO_OUTPUT_CONTROL);
-
-	value = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);
-	value |= TEGRA186_GPIO_ENABLE_CONFIG_ENABLE;
-	value &= ~TEGRA186_GPIO_ENABLE_CONFIG_OUT;
-	writel(value, base + TEGRA186_GPIO_ENABLE_CONFIG);
-
-	ret = pinctrl_gpio_direction_input(chip->base + offset);
-	if (ret < 0)
-		dev_err(chip->parent,
-			"Failed to set input direction: %d\n", ret);
-	return ret;
+  struct tegra_gpio *gpio = gpiochip_get_data(chip);
+  void __iomem *base;
+  u32 value;
+  int ret = 0;
+
+  deb_verbose("GPIO, chip %s, offset %u\n", chip->label, offset);
+
+  if (!gpio_is_accessible(gpio, offset)) {
+    deb_verbose("GPIO error: gpio is not accessible %d", __LINE__);
+    return -EPERM;
+  }
+
+  base = tegra186_gpio_get_base(gpio, offset);
+  if (WARN_ON(base == NULL))
+    return -ENODEV;
+
+  value = readl(base + TEGRA186_GPIO_OUTPUT_CONTROL);
+  value |= TEGRA186_GPIO_OUTPUT_CONTROL_FLOATED;
+  writel(value, base + TEGRA186_GPIO_OUTPUT_CONTROL);
+
+  value = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);
+  value |= TEGRA186_GPIO_ENABLE_CONFIG_ENABLE;
+  value &= ~TEGRA186_GPIO_ENABLE_CONFIG_OUT;
+  writel(value, base + TEGRA186_GPIO_ENABLE_CONFIG);
+
+  ret = pinctrl_gpio_direction_input(chip->base + offset);
+  if (ret < 0)
+    dev_err(chip->parent,
+      "Failed to set input direction: %d\n", ret);
+  return ret;
 }
 
-static int tegra186_gpio_direction_output(struct gpio_chip *chip,
-					  unsigned int offset, int level)
+// function has passthrough version
+int tegra186_gpio_direction_output(struct gpio_chip *chip,
+            unsigned int offset, int level)
 {
-	struct tegra_gpio *gpio = gpiochip_get_data(chip);
-	void __iomem *base;
-	u32 value;
-	int ret = 0;
-
-	if (!gpio_is_accessible(gpio, offset))
-		return -EPERM;
-
-	/* configure output level first */
-	chip->set(chip, offset, level);
-
-	base = tegra186_gpio_get_base(gpio, offset);
-	if (WARN_ON(base == NULL))
-		return -EINVAL;
-
-	/* set the direction */
-	value = readl(base + TEGRA186_GPIO_OUTPUT_CONTROL);
-	value &= ~TEGRA186_GPIO_OUTPUT_CONTROL_FLOATED;
-	writel(value, base + TEGRA186_GPIO_OUTPUT_CONTROL);
-
-	value = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);
-	value |= TEGRA186_GPIO_ENABLE_CONFIG_ENABLE;
-	value |= TEGRA186_GPIO_ENABLE_CONFIG_OUT;
-	writel(value, base + TEGRA186_GPIO_ENABLE_CONFIG);
-	ret = pinctrl_gpio_direction_output(chip->base + offset);
-
-	if (ret < 0)
-		dev_err(chip->parent,
-			"Failed to set output direction: %d\n", ret);
-	return ret;
+  struct tegra_gpio *gpio = gpiochip_get_data(chip);
+  void __iomem *base;
+  u32 value;
+  int ret = 0;
+
+  deb_verbose("GPIO, chip %s, offset %u, level %d\n", chip->label, offset, level);
+
+  if (!gpio_is_accessible(gpio, offset)) {
+    deb_verbose("GPIO error: gpio is not accessible %d", __LINE__);
+    return -EPERM;
+  }
+
+  /* configure output level first */
+  chip->set(chip, offset, level);
+
+  base = tegra186_gpio_get_base(gpio, offset);
+  if (WARN_ON(base == NULL))
+    return -EINVAL;
+
+  /* set the direction */
+  value = readl(base + TEGRA186_GPIO_OUTPUT_CONTROL);
+  value &= ~TEGRA186_GPIO_OUTPUT_CONTROL_FLOATED;
+  writel(value, base + TEGRA186_GPIO_OUTPUT_CONTROL);
+
+  value = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);
+  value |= TEGRA186_GPIO_ENABLE_CONFIG_ENABLE;
+  value |= TEGRA186_GPIO_ENABLE_CONFIG_OUT;
+  writel(value, base + TEGRA186_GPIO_ENABLE_CONFIG);
+  ret = pinctrl_gpio_direction_output(chip->base + offset);
+
+  if (ret < 0)
+    dev_err(chip->parent,
+      "Failed to set output direction: %d\n", ret);
+  return ret;
 }
 
+// function has passthrough version
 static int tegra_gpio_suspend_configure(struct gpio_chip *chip, unsigned offset,
-					enum gpiod_flags dflags)
+          enum gpiod_flags dflags)
 {
-	struct tegra_gpio *gpio = gpiochip_get_data(chip);
-	struct tegra_gpio_saved_register *regs;
-	void __iomem *base;
-
-	if (!gpio_is_accessible(gpio, offset))
-		return -EPERM;
-
-	base = tegra186_gpio_get_base(gpio, offset);
-	if (WARN_ON(base == NULL))
-		return -EINVAL;
-
-	regs = &gpio->gpio_rval[offset];
-	regs->conf = readl(base + TEGRA186_GPIO_ENABLE_CONFIG),
-	regs->out = readl(base + TEGRA186_GPIO_OUTPUT_CONTROL),
-	regs->val = readl(base + TEGRA186_GPIO_OUTPUT_VALUE),
-	regs->restore_needed = true;
-
-	if (dflags & GPIOD_FLAGS_BIT_DIR_OUT)
-		return tegra186_gpio_direction_output(chip, offset,
-					dflags & GPIOD_FLAGS_BIT_DIR_VAL);
-
-	return tegra186_gpio_direction_input(chip, offset);
+  struct tegra_gpio *gpio = gpiochip_get_data(chip);
+  struct tegra_gpio_saved_register *regs;
+  void __iomem *base;
+
+  deb_verbose("GPIO chip %s, offset %u\n", chip->label, offset);
+
+  if (!gpio_is_accessible(gpio, offset)) {
+    deb_verbose("GPIO error: gpio is not accessible %d", __LINE__);
+    return -EPERM;
+  }
+
+  #if defined(GPIO_DEBUG_EXCEPTIONS)
+  if(kernel_is_on_guest && !is_debug_exception(GPIO_NOPT_TEST2) ) {
+    base = tegra186_gpio_get_base_r(gpio, offset);
+  }
+  else
+  #endif
+    base = tegra186_gpio_get_base(gpio, offset);
+  if (WARN_ON(base == NULL))
+    return -EINVAL;
+
+  regs = &gpio->gpio_rval[offset];
+  regs->conf = readl_x(base + TEGRA186_GPIO_ENABLE_CONFIG),
+  regs->out = readl_x(base + TEGRA186_GPIO_OUTPUT_CONTROL),
+  regs->val = readl_x(base + TEGRA186_GPIO_OUTPUT_VALUE),
+  regs->restore_needed = true;
+
+  if (dflags & GPIOD_FLAGS_BIT_DIR_OUT)
+    return tegra186_gpio_direction_output(chip, offset,
+          dflags & GPIOD_FLAGS_BIT_DIR_VAL);
+
+  return tegra186_gpio_direction_input(chip, offset);
 }
 
+// function has passthrough version
 static int tegra_gpio_timestamp_control(struct gpio_chip *chip, unsigned offset,
-					int enable)
+          int enable)
 {
-	struct tegra_gpio *gpio = gpiochip_get_data(chip);
-	void __iomem *base;
-	int value;
-	int ret;
-
-	base = tegra186_gpio_get_base(gpio, offset);
-	if (WARN_ON(base == NULL))
-		return -EINVAL;
-
-	if (gpio->use_timestamp) {
-		value = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);
-		value |= TEGRA186_GPIO_ENABLE_CONFIG_TIMESTAMP_FUNC;
-		writel(value, base + TEGRA186_GPIO_ENABLE_CONFIG);
-		if (enable)
-			ret = tegra_gte_enable_ts(gpio, offset);
-		else
-			ret = tegra_gte_disable_ts(gpio, offset);
-	} else
-		ret = -EOPNOTSUPP;
-
-	return ret;
+  struct tegra_gpio *gpio = gpiochip_get_data(chip);
+  void __iomem *base;
+  int value;
+  int ret;
+
+  deb_verbose("GPIO, chip %s, offset %u\n", chip->label, offset);
+
+  base = tegra186_gpio_get_base(gpio, offset);
+  if (WARN_ON(base == NULL))
+    return -EINVAL;
+
+  if (gpio->use_timestamp) {
+    value = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);
+    value |= TEGRA186_GPIO_ENABLE_CONFIG_TIMESTAMP_FUNC;
+    writel(value, base + TEGRA186_GPIO_ENABLE_CONFIG);
+    if (enable)
+      ret = tegra_gte_enable_ts(gpio, offset);
+    else
+      ret = tegra_gte_disable_ts(gpio, offset);
+  } else
+    ret = -EOPNOTSUPP;
+
+  return ret;
 }
 
 static int tegra_gpio_timestamp_read(struct gpio_chip *chip, unsigned offset,
-				     u64 *ts)
+             u64 *ts)
 {
-	struct tegra_gpio *tgi = gpiochip_get_data(chip);
-	int ret;
+  struct tegra_gpio *tgi = gpiochip_get_data(chip);
+  int ret;
+
+  deb_verbose("GPIO chip %s, offset %u\n", chip->label, offset);
 
-	if (tgi->use_timestamp) {
-		*ts = tegra_gte_read_fifo(tgi, offset);
-		ret = 0;
-	} else
-		ret = -EOPNOTSUPP;
+  if (tgi->use_timestamp) {
+    *ts = tegra_gte_read_fifo(tgi, offset);
+    ret = 0;
+  } else
+    ret = -EOPNOTSUPP;
 
-	return ret;
+  return ret;
 }
 
+// function has passthrough version
 static int tegra186_gpio_get(struct gpio_chip *chip, unsigned int offset)
 {
-	struct tegra_gpio *gpio = gpiochip_get_data(chip);
-	void __iomem *base;
-	u32 value;
+  struct tegra_gpio *gpio = gpiochip_get_data(chip);
+  void __iomem *base;
+  u32 value;
 
-	base = tegra186_gpio_get_base(gpio, offset);
-	if (WARN_ON(base == NULL))
-		return -ENODEV;
+  deb_verbose("GPIO chip %s, offset %u\n", chip->label, offset);
 
-	value = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);
-	if (value & TEGRA186_GPIO_ENABLE_CONFIG_OUT)
-		value = readl(base + TEGRA186_GPIO_OUTPUT_VALUE);
-	else
-		value = readl(base + TEGRA186_GPIO_INPUT);
+  base = tegra186_gpio_get_base(gpio, offset);
+  if (WARN_ON(base == NULL))
+    return -ENODEV;
 
-	return value & BIT(0);
+  value = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);
+  if (value & TEGRA186_GPIO_ENABLE_CONFIG_OUT)
+    value = readl(base + TEGRA186_GPIO_OUTPUT_VALUE);
+  else
+    value = readl(base + TEGRA186_GPIO_INPUT);
+
+  return value & BIT(0);
 }
 
-static void tegra186_gpio_set(struct gpio_chip *chip, unsigned int offset,
-			      int level)
+// function has passthrough version
+void tegra186_gpio_set(struct gpio_chip *chip, unsigned int offset,
+            int level)
 {
-	struct tegra_gpio *gpio = gpiochip_get_data(chip);
-	void __iomem *base;
-	u32 value;
-
-	if (!gpio_is_accessible(gpio, offset))
-		return;
-
-	base = tegra186_gpio_get_base(gpio, offset);
-	if (WARN_ON(base == NULL))
-		return;
-
-	value = readl(base + TEGRA186_GPIO_OUTPUT_VALUE);
-	if (level == 0)
-		value &= ~TEGRA186_GPIO_OUTPUT_VALUE_HIGH;
-	else
-		value |= TEGRA186_GPIO_OUTPUT_VALUE_HIGH;
+  struct tegra_gpio *gpio = gpiochip_get_data(chip);
+  void __iomem *base;
+  u32 value;
+
+  if (!gpio_is_accessible(gpio, offset)) {
+    deb_verbose("GPIO error: gpio is not accessible %d", __LINE__);
+    pr_err("GPIO error: gpio is not accessible, Chip %s, Offset %d", gpio->gpio.label, offset);
+    return;
+  }
+  base = tegra186_gpio_get_base(gpio, offset);
+
+  if (WARN_ON(base == NULL))
+    return;
+
+  value = readl(base + TEGRA186_GPIO_OUTPUT_VALUE);
+  if (level == 0)
+    value &= ~TEGRA186_GPIO_OUTPUT_VALUE_HIGH;
+  else
+    value |= TEGRA186_GPIO_OUTPUT_VALUE_HIGH;
+
+  writel(value, base + TEGRA186_GPIO_OUTPUT_VALUE);
+}
 
-	writel(value, base + TEGRA186_GPIO_OUTPUT_VALUE);
+#if defined(CONFIG_TEGRA_GPIO_GUEST_PROXY) || defined(CONFIG_TEGRA_GPIO_HOST_PROXY)
+void tegra186_gpio_set_by_name(const char *name, unsigned int offset,
+            int level)
+{
+  struct gpio_chip *chip = find_chip_by_name(name);
+  if (chip) { tegra186_gpio_set(chip, offset, level); }
+  else {
+    pr_err("GPIO cannot find chip by name, %s\n", name);
+  }
 }
+#endif
 
+// function has passthrough version
 static int tegra186_gpio_set_config(struct gpio_chip *chip,
-				    unsigned int offset,
-				    unsigned long config)
+            unsigned int offset,
+            unsigned long config)
 {
-	struct tegra_gpio *gpio = gpiochip_get_data(chip);
-	u32 debounce, value;
-	void __iomem *base;
+  struct tegra_gpio *gpio = gpiochip_get_data(chip);
+  u32 debounce, value;
+  void __iomem *base;
 
-	base = tegra186_gpio_get_base(gpio, offset);
-	if (base == NULL)
-		return -ENXIO;
+  deb_verbose("GPIO, chip %s, offset %u\n", chip->label, offset);
 
-	if (pinconf_to_config_param(config) != PIN_CONFIG_INPUT_DEBOUNCE)
-		return -ENOTSUPP;
+  base = tegra186_gpio_get_base(gpio, offset);
+  if (base == NULL)
+    return -ENXIO;
 
-	debounce = pinconf_to_config_argument(config);
+  if (pinconf_to_config_param(config) != PIN_CONFIG_INPUT_DEBOUNCE)
+    return -ENOTSUPP;
 
-	/*
-	 * The Tegra186 GPIO controller supports a maximum of 255 ms debounce
-	 * time.
-	 */
-	if (debounce > 255000)
-		return -EINVAL;
+  debounce = pinconf_to_config_argument(config);
 
-	debounce = DIV_ROUND_UP(debounce, USEC_PER_MSEC);
+  /*
+   * The Tegra186 GPIO controller supports a maximum of 255 ms debounce
+   * time.
+   */
+  if (debounce > 255000)
+    return -EINVAL;
 
-	value = TEGRA186_GPIO_DEBOUNCE_CONTROL_THRESHOLD(debounce);
-	writel(value, base + TEGRA186_GPIO_DEBOUNCE_CONTROL);
+  debounce = DIV_ROUND_UP(debounce, USEC_PER_MSEC);
 
-	value = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);
-	value |= TEGRA186_GPIO_ENABLE_CONFIG_DEBOUNCE;
-	writel(value, base + TEGRA186_GPIO_ENABLE_CONFIG);
+  value = TEGRA186_GPIO_DEBOUNCE_CONTROL_THRESHOLD(debounce);
+  writel(value, base + TEGRA186_GPIO_DEBOUNCE_CONTROL);
 
-	return 0;
+  value = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);
+  value |= TEGRA186_GPIO_ENABLE_CONFIG_DEBOUNCE;
+  writel(value, base + TEGRA186_GPIO_ENABLE_CONFIG);
+
+  return 0;
 }
 
+// passthrough but passthrough function is not used
 static int tegra186_gpio_add_pin_ranges(struct gpio_chip *chip)
 {
-	struct tegra_gpio *gpio = gpiochip_get_data(chip);
-	struct pinctrl_dev *pctldev;
-	struct device_node *np;
-	unsigned int i, j;
-	int err;
-
-	if (!gpio->soc->pinmux || gpio->soc->num_pin_ranges == 0)
-		return 0;
-
-	np = of_find_compatible_node(NULL, NULL, gpio->soc->pinmux);
-	if (!np)
-		return -ENODEV;
-
-	pctldev = of_pinctrl_get(np);
-	of_node_put(np);
-	if (!pctldev)
-		return -EPROBE_DEFER;
-
-	for (i = 0; i < gpio->soc->num_pin_ranges; i++) {
-		unsigned int pin = gpio->soc->pin_ranges[i].offset, port;
-		const char *group = gpio->soc->pin_ranges[i].group;
-
-		port = pin / 8;
-		pin = pin % 8;
-
-		if (port >= gpio->soc->num_ports) {
-			dev_warn(chip->parent, "invalid port %u for %s\n",
-				 port, group);
-			continue;
-		}
+  struct tegra_gpio *gpio = gpiochip_get_data(chip);
+  struct pinctrl_dev *pctldev;
+  struct device_node *np;
+  unsigned int i, j;
+  int err;
 
-		for (j = 0; j < port; j++)
-			pin += gpio->soc->ports[j].pins;
+  deb_verbose("GPIO chip %s\n", chip->label);
 
-		err = gpiochip_add_pingroup_range(chip, pctldev, pin, group);
-		if (err < 0)
-			return err;
-	}
+  if (!gpio->soc->pinmux || gpio->soc->num_pin_ranges == 0)
+    return 0;
+
+  np = of_find_compatible_node(NULL, NULL, gpio->soc->pinmux);
+  if (!np)
+    return -ENODEV;
+
+  pctldev = of_pinctrl_get(np);
+  of_node_put(np);
+  if (!pctldev)
+    return -EPROBE_DEFER;
+
+  for (i = 0; i < gpio->soc->num_pin_ranges; i++) {
+    unsigned int pin = gpio->soc->pin_ranges[i].offset, port;
+    const char *group = gpio->soc->pin_ranges[i].group;
+
+    port = pin / 8;
+    pin = pin % 8;
+
+    if (port >= gpio->soc->num_ports) {
+      dev_warn(chip->parent, "invalid port %u for %s\n",
+         port, group);
+      continue;
+    }
+
+    for (j = 0; j < port; j++)
+      pin += gpio->soc->ports[j].pins;
 
-	return 0;
+    err = gpiochip_add_pingroup_range(chip, pctldev, pin, group);
+    if (err < 0)
+      return err;
+  }
+
+  return 0;
 }
 
+// candidate for passthrough (but we still need irq in Guest)
 static int tegra186_gpio_of_xlate(struct gpio_chip *chip,
-				  const struct of_phandle_args *spec,
-				  u32 *flags)
+          const struct of_phandle_args *spec,
+          u32 *flags)
 {
-	struct tegra_gpio *gpio = gpiochip_get_data(chip);
-	unsigned int port, pin, i, offset = 0;
+  struct tegra_gpio *gpio = gpiochip_get_data(chip);
+  unsigned int port, pin, i, offset = 0;
 
-	if (WARN_ON(chip->of_gpio_n_cells < 2))
-		return -EINVAL;
+  deb_verbose("GPIO chip %s\n", chip->label);
 
-	if (WARN_ON(spec->args_count < chip->of_gpio_n_cells))
-		return -EINVAL;
+  if (WARN_ON(chip->of_gpio_n_cells < 2))
+    return -EINVAL;
 
-	port = spec->args[0] / 8;
-	pin = spec->args[0] % 8;
+  if (WARN_ON(spec->args_count < chip->of_gpio_n_cells))
+    return -EINVAL;
 
-	if (port >= gpio->soc->num_ports) {
-		dev_err(chip->parent, "invalid port number: %u\n", port);
-		return -EINVAL;
-	}
+  port = spec->args[0] / 8;
+  pin = spec->args[0] % 8;
+
+  if (port >= gpio->soc->num_ports) {
+    dev_err(chip->parent, "invalid port number: %u\n", port);
+    return -EINVAL;
+  }
 
-	for (i = 0; i < port; i++)
-		offset += gpio->soc->ports[i].pins;
+  for (i = 0; i < port; i++)
+    offset += gpio->soc->ports[i].pins;
 
-	if (flags)
-		*flags = spec->args[1];
+  if (flags)
+    *flags = spec->args[1];
 
-	return offset + pin;
+  return offset + pin;
 }
 
 #define to_tegra_gpio(x) container_of((x), struct tegra_gpio, gpio)
 
+// candidate for passthrough (but we still need irq in Guest)
 static void tegra186_irq_ack(struct irq_data *data)
 {
-	struct gpio_chip *gc = irq_data_get_irq_chip_data(data);
-	struct tegra_gpio *gpio = to_tegra_gpio(gc);
-	void __iomem *base;
+  struct gpio_chip *gc = irq_data_get_irq_chip_data(data);
+  struct tegra_gpio *gpio = to_tegra_gpio(gc);
+  void __iomem *base;
 
-	base = tegra186_gpio_get_base(gpio, data->hwirq);
-	if (WARN_ON(base == NULL))
-		return;
+  base = tegra186_gpio_get_base(gpio, data->hwirq);
+  if (WARN_ON(base == NULL))
+    return;
 
-	writel(1, base + TEGRA186_GPIO_INTERRUPT_CLEAR);
+  writel(1, base + TEGRA186_GPIO_INTERRUPT_CLEAR);
 }
 
+// candidate for passthrough (but we still need irq in Guest)
 static void tegra186_irq_mask(struct irq_data *data)
 {
-	struct gpio_chip *gc = irq_data_get_irq_chip_data(data);
-	struct tegra_gpio *gpio = to_tegra_gpio(gc);
-	void __iomem *base;
-	u32 value;
-
-	base = tegra186_gpio_get_base(gpio, data->hwirq);
-	if (WARN_ON(base == NULL))
-		return;
-
-	value = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);
-	value &= ~TEGRA186_GPIO_ENABLE_CONFIG_INTERRUPT;
-	writel(value, base + TEGRA186_GPIO_ENABLE_CONFIG);
+  struct gpio_chip *gc = irq_data_get_irq_chip_data(data);
+  struct tegra_gpio *gpio = to_tegra_gpio(gc);
+  void __iomem *base;
+  u32 value;
+
+  base = tegra186_gpio_get_base(gpio, data->hwirq);
+  if (WARN_ON(base == NULL))
+    return;
+
+  value = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);
+  value &= ~TEGRA186_GPIO_ENABLE_CONFIG_INTERRUPT;
+  writel(value, base + TEGRA186_GPIO_ENABLE_CONFIG);
 }
 
+// candidate for passthrough (but we still need irq in Guest)
 static void tegra186_irq_unmask(struct irq_data *data)
 {
-	struct gpio_chip *gc = irq_data_get_irq_chip_data(data);
-	struct tegra_gpio *gpio = to_tegra_gpio(gc);
-	void __iomem *base;
-	u32 value;
-
-	base = tegra186_gpio_get_base(gpio, data->hwirq);
-	if (WARN_ON(base == NULL))
-		return;
-
-	value = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);
-	value |= TEGRA186_GPIO_ENABLE_CONFIG_INTERRUPT;
-	writel(value, base + TEGRA186_GPIO_ENABLE_CONFIG);
+  struct gpio_chip *gc = irq_data_get_irq_chip_data(data);
+  struct tegra_gpio *gpio = to_tegra_gpio(gc);
+  void __iomem *base;
+  u32 value;
+
+  base = tegra186_gpio_get_base(gpio, data->hwirq);
+  if (WARN_ON(base == NULL))
+    return;
+
+  value = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);
+  value |= TEGRA186_GPIO_ENABLE_CONFIG_INTERRUPT;
+  writel(value, base + TEGRA186_GPIO_ENABLE_CONFIG);
 }
 
+// candidate for passthrough (but we still need irq in Guest)
 static int tegra186_irq_set_type(struct irq_data *data, unsigned int type)
 {
-	struct gpio_chip *gc = irq_data_get_irq_chip_data(data);
-	struct tegra_gpio *gpio = to_tegra_gpio(gc);
-	void __iomem *base;
-	u32 value;
-
-	base = tegra186_gpio_get_base(gpio, data->hwirq);
-	if (WARN_ON(base == NULL))
-		return -ENODEV;
-
-	value = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);
-	value &= ~TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_MASK;
-	value &= ~TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_LEVEL;
-
-	switch (type & IRQ_TYPE_SENSE_MASK) {
-	case IRQ_TYPE_NONE:
-		break;
-
-	case IRQ_TYPE_EDGE_RISING:
-		value |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_SINGLE_EDGE;
-		value |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_LEVEL;
-		break;
-
-	case IRQ_TYPE_EDGE_FALLING:
-		value |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_SINGLE_EDGE;
-		break;
-
-	case IRQ_TYPE_EDGE_BOTH:
-		value |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_DOUBLE_EDGE;
-		break;
-
-	case IRQ_TYPE_LEVEL_HIGH:
-		value |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_LEVEL;
-		value |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_LEVEL;
-		break;
-
-	case IRQ_TYPE_LEVEL_LOW:
-		value |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_LEVEL;
-		break;
-
-	default:
-		return -EINVAL;
-	}
+  struct gpio_chip *gc = irq_data_get_irq_chip_data(data);
+  struct tegra_gpio *gpio = to_tegra_gpio(gc);
+  void __iomem *base;
+  u32 value;
+
+  base = tegra186_gpio_get_base(gpio, data->hwirq);
+  if (WARN_ON(base == NULL))
+    return -ENODEV;
+
+  value = readl(base + TEGRA186_GPIO_ENABLE_CONFIG);
+  value &= ~TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_MASK;
+  value &= ~TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_LEVEL;
+
+  switch (type & IRQ_TYPE_SENSE_MASK) {
+  case IRQ_TYPE_NONE:
+    break;
+
+  case IRQ_TYPE_EDGE_RISING:
+    value |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_SINGLE_EDGE;
+    value |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_LEVEL;
+    break;
+
+  case IRQ_TYPE_EDGE_FALLING:
+    value |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_SINGLE_EDGE;
+    break;
+
+  case IRQ_TYPE_EDGE_BOTH:
+    value |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_DOUBLE_EDGE;
+    break;
 
-	writel(value, base + TEGRA186_GPIO_ENABLE_CONFIG);
+  case IRQ_TYPE_LEVEL_HIGH:
+    value |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_LEVEL;
+    value |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_LEVEL;
+    break;
 
-	if ((type & IRQ_TYPE_EDGE_BOTH) == 0)
-		irq_set_handler_locked(data, handle_level_irq);
-	else
-		irq_set_handler_locked(data, handle_edge_irq);
+  case IRQ_TYPE_LEVEL_LOW:
+    value |= TEGRA186_GPIO_ENABLE_CONFIG_TRIGGER_TYPE_LEVEL;
+    break;
 
-	if (data->parent_data)
-		return irq_chip_set_type_parent(data, type);
+  default:
+    return -EINVAL;
+  }
 
-	return 0;
+  writel(value, base + TEGRA186_GPIO_ENABLE_CONFIG);
+
+  if ((type & IRQ_TYPE_EDGE_BOTH) == 0)
+    irq_set_handler_locked(data, handle_level_irq);
+  else
+    irq_set_handler_locked(data, handle_edge_irq);
+
+  if (data->parent_data)
+    return irq_chip_set_type_parent(data, type);
+
+  return 0;
 }
 
 static int tegra186_irq_set_wake(struct irq_data *data, unsigned int on)
 {
-	if (data->parent_data)
-		return irq_chip_set_wake_parent(data, on);
+  if (data->parent_data)
+    return irq_chip_set_wake_parent(data, on);
 
-	return 0;
+  return 0;
 }
 
+// candidate for passthrough (but we still need irq in Guest)
 static void tegra186_gpio_irq(struct irq_desc *desc)
 {
-	struct tegra_gpio *gpio = irq_desc_get_handler_data(desc);
-	struct irq_domain *domain = gpio->gpio.irq.domain;
-	struct irq_chip *chip = irq_desc_get_chip(desc);
-	unsigned int parent = irq_desc_get_irq(desc);
-	unsigned int i, j, offset = 0;
+  struct tegra_gpio *gpio = irq_desc_get_handler_data(desc);
+  struct irq_domain *domain = gpio->gpio.irq.domain;
+  struct irq_chip *chip = irq_desc_get_chip(desc);
+  unsigned int parent = irq_desc_get_irq(desc);
+  unsigned int i, j, offset = 0;
 
-	chained_irq_enter(chip, desc);
+  deb_debug("irq_domain=%p\n", domain);
+  chained_irq_enter(chip, desc);
 
-	for (i = 0; i < gpio->soc->num_ports; i++) {
-		const struct tegra_gpio_port *port = &gpio->soc->ports[i];
-		unsigned int pin, irq;
-		unsigned long value;
-		void __iomem *base;
+  for (i = 0; i < gpio->soc->num_ports; i++) {
+    const struct tegra_gpio_port *port = &gpio->soc->ports[i];
+    unsigned int pin, irq;
+    unsigned long value;
+    void __iomem *base;
 
-		base = gpio->base + port->bank * 0x1000 + port->port * 0x200;
+    base = gpio->base + port->bank * 0x1000 + port->port * 0x200;
 
-		for (j = 0; j < gpio->num_irqs_per_bank; j++) {
-			if (parent == gpio->irq[port->bank * gpio->num_irqs_per_bank + j])
-				break;
-		}
+    for (j = 0; j < gpio->num_irqs_per_bank; j++) {
+      if (parent == gpio->irq[port->bank * gpio->num_irqs_per_bank + j])
+        break;
+    }
 
-		if (j == gpio->num_irqs_per_bank)
-			goto skip;
+    if (j == gpio->num_irqs_per_bank)
+      goto skip;
 
-		value = readl(base + TEGRA186_GPIO_INTERRUPT_STATUS(1));
+    value = readl(base + TEGRA186_GPIO_INTERRUPT_STATUS(1));
 
-		for_each_set_bit(pin, &value, port->pins) {
-			irq = irq_find_mapping(domain, offset + pin);
-			if (WARN_ON(irq == 0))
-				continue;
+    for_each_set_bit(pin, &value, port->pins) {
+      irq = irq_find_mapping(domain, offset + pin);
+      if (WARN_ON(irq == 0))
+        continue;
 
-			generic_handle_irq(irq);
-		}
+      generic_handle_irq(irq);
+    }
 
 skip:
-		offset += port->pins;
-	}
+    offset += port->pins;
+  }
 
-	chained_irq_exit(chip, desc);
+  chained_irq_exit(chip, desc);
 }
 
 static int tegra186_gpio_irq_domain_translate(struct irq_domain *domain,
-					      struct irq_fwspec *fwspec,
-					      unsigned long *hwirq,
-					      unsigned int *type)
+                struct irq_fwspec *fwspec,
+                unsigned long *hwirq,
+                unsigned int *type)
 {
-	struct tegra_gpio *gpio = gpiochip_get_data(domain->host_data);
-	unsigned int port, pin, i, offset = 0;
+  struct tegra_gpio *gpio = gpiochip_get_data(domain->host_data);
+  unsigned int port, pin, i, offset = 0;
 
-	if (WARN_ON(gpio->gpio.of_gpio_n_cells < 2))
-		return -EINVAL;
+  if (WARN_ON(gpio->gpio.of_gpio_n_cells < 2))
+    return -EINVAL;
 
-	if (WARN_ON(fwspec->param_count < gpio->gpio.of_gpio_n_cells))
-		return -EINVAL;
+  if (WARN_ON(fwspec->param_count < gpio->gpio.of_gpio_n_cells))
+    return -EINVAL;
 
-	port = fwspec->param[0] / 8;
-	pin = fwspec->param[0] % 8;
+  port = fwspec->param[0] / 8;
+  pin = fwspec->param[0] % 8;
 
-	if (port >= gpio->soc->num_ports)
-		return -EINVAL;
+  if (port >= gpio->soc->num_ports)
+    return -EINVAL;
 
-	for (i = 0; i < port; i++)
-		offset += gpio->soc->ports[i].pins;
+  for (i = 0; i < port; i++)
+    offset += gpio->soc->ports[i].pins;
 
-	*type = fwspec->param[1] & IRQ_TYPE_SENSE_MASK;
-	*hwirq = offset + pin;
+  *type = fwspec->param[1] & IRQ_TYPE_SENSE_MASK;
+  *hwirq = offset + pin;
 
-	return 0;
+  return 0;
 }
 
 static void *tegra186_gpio_populate_parent_fwspec(struct gpio_chip *chip,
-						 unsigned int parent_hwirq,
-						 unsigned int parent_type)
+             unsigned int parent_hwirq,
+             unsigned int parent_type)
 {
-	struct tegra_gpio *gpio = gpiochip_get_data(chip);
-	struct irq_fwspec *fwspec;
+  struct tegra_gpio *gpio = gpiochip_get_data(chip);
+  struct irq_fwspec *fwspec;
 
-	fwspec = kmalloc(sizeof(*fwspec), GFP_KERNEL);
-	if (!fwspec)
-		return NULL;
+  fwspec = kmalloc(sizeof(*fwspec), GFP_KERNEL);
+  if (!fwspec)
+    return NULL;
 
-	fwspec->fwnode = chip->irq.parent_domain->fwnode;
-	fwspec->param_count = 3;
-	fwspec->param[0] = gpio->soc->instance;
-	fwspec->param[1] = parent_hwirq;
-	fwspec->param[2] = parent_type;
+  fwspec->fwnode = chip->irq.parent_domain->fwnode;
+  fwspec->param_count = 3;
+  fwspec->param[0] = gpio->soc->instance;
+  fwspec->param[1] = parent_hwirq;
+  fwspec->param[2] = parent_type;
 
-	return fwspec;
+  return fwspec;
 }
 
 static int tegra186_gpio_child_to_parent_hwirq(struct gpio_chip *chip,
-					       unsigned int hwirq,
-					       unsigned int type,
-					       unsigned int *parent_hwirq,
-					       unsigned int *parent_type)
+                 unsigned int hwirq,
+                 unsigned int type,
+                 unsigned int *parent_hwirq,
+                 unsigned int *parent_type)
 {
-	*parent_hwirq = chip->irq.child_offset_to_irq(chip, hwirq);
-	*parent_type = type;
+  *parent_hwirq = chip->irq.child_offset_to_irq(chip, hwirq);
+  *parent_type = type;
 
-	return 0;
+  return 0;
 }
 
 static unsigned int tegra186_gpio_child_offset_to_irq(struct gpio_chip *chip,
-						      unsigned int offset)
+                  unsigned int offset)
 {
-	struct tegra_gpio *gpio = gpiochip_get_data(chip);
-	unsigned int i;
+  struct tegra_gpio *gpio = gpiochip_get_data(chip);
+  unsigned int i;
 
-	for (i = 0; i < gpio->soc->num_ports; i++) {
-		if (offset < gpio->soc->ports[i].pins)
-			break;
+  for (i = 0; i < gpio->soc->num_ports; i++) {
+    if (offset < gpio->soc->ports[i].pins)
+      break;
 
-		offset -= gpio->soc->ports[i].pins;
-	}
+    offset -= gpio->soc->ports[i].pins;
+  }
 
-	return offset + i * 8;
+  return offset + i * 8;
 }
 
 static const struct of_device_id tegra186_pmc_of_match[] = {
-	{ .compatible = "nvidia,tegra186-pmc" },
-	{ .compatible = "nvidia,tegra194-pmc" },
-	{ .compatible = "nvidia,tegra234-pmc" },
-	{ /* sentinel */ }
+  { .compatible = "nvidia,tegra186-pmc" },
+  { .compatible = "nvidia,tegra194-pmc" },
+  { .compatible = "nvidia,tegra234-pmc" },
+  { /* sentinel */ }
 };
 
+// readl and writel are called
 static void tegra186_gpio_init_route_mapping(struct tegra_gpio *gpio)
 {
-	struct device *dev = gpio->gpio.parent;
-	unsigned int i, j;
-	u32 value;
-
-	for (i = 0; i < gpio->soc->num_ports; i++) {
-		const struct tegra_gpio_port *port = &gpio->soc->ports[i];
-		unsigned int offset, p = port->port;
-		void __iomem *base;
-
-		base = gpio->secure + port->bank * 0x1000 + 0x800;
-
-		value = readl(base + TEGRA186_GPIO_CTL_SCR);
-
-		/*
-		 * For controllers that haven't been locked down yet, make
-		 * sure to program the default interrupt route mapping.
-		 */
-		if ((value & TEGRA186_GPIO_CTL_SCR_SEC_REN) == 0 &&
-		    (value & TEGRA186_GPIO_CTL_SCR_SEC_WEN) == 0) {
-			/*
-			 * On Tegra194 and later, each pin can be routed to one or more
-			 * interrupts.
-			 */
-			for (j = 0; j < gpio->num_irqs_per_bank; j++) {
-				dev_dbg(dev, "programming default interrupt routing for port %s\n",
-					port->name);
-
-				offset = TEGRA186_GPIO_INT_ROUTE_MAPPING(p, j);
-
-				/*
-				 * By default we only want to route GPIO pins to IRQ 0. This works
-				 * only under the assumption that we're running as the host kernel
-				 * and hence all GPIO pins are owned by Linux.
-				 *
-				 * For cases where Linux is the guest OS, the hypervisor will have
-				 * to configure the interrupt routing and pass only the valid
-				 * interrupts via device tree.
-				 */
-
+  struct device *dev = gpio->gpio.parent;
+  unsigned int i, j;
+  u32 value;
+  
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+	bool stash = kernel_is_on_guest; 
+	if(kernel_is_on_guest && is_debug_exception(GPIO_NOPT_TEST3))
+	#endif
+		kernel_is_on_guest = false; // tmp value for this function
+
+  // deb_verbose("GPIO, chip \n", gpio->gpio.label);
+
+  for (i = 0; i < gpio->soc->num_ports; i++) {
+    const struct tegra_gpio_port *port = &gpio->soc->ports[i];
+    unsigned int offset, p = port->port;
+    void __iomem *base;
+
+    base = gpio->secure + port->bank * 0x1000 + 0x800;
+
+    /* this cannot work as passthroug because 'base' and 'gpio->secure' has local value based on guest
+     * we should pass this from host: gpio->secure = devm_platform_ioremap_resource_byname(pdev, "security");
+    value = readl_x(base + TEGRA186_GPIO_CTL_SCR);
+    * and yet: routing should be done locally?
+    */
+    #if defined(CONFIG_TEGRA_GPIO_GUEST_PROXY) || defined(CONFIG_TEGRA_GPIO_HOST_PROXY)
+    value = readl_x(base + TEGRA186_GPIO_CTL_SCR);
+    value = readl_x(base + TEGRA186_GPIO_CTL_SCR);
+    #else
+    value = readl(base + TEGRA186_GPIO_CTL_SCR);
+    value = readl(base + TEGRA186_GPIO_CTL_SCR);
+    #endif
+
+    /*
+     * For controllers that haven't been locked down yet, make
+     * sure to program the default interrupt route mapping.
+     */
+    if ((value & TEGRA186_GPIO_CTL_SCR_SEC_REN) == 0 &&
+        (value & TEGRA186_GPIO_CTL_SCR_SEC_WEN) == 0) {
+      /*
+       * On Tegra194 and later, each pin can be routed to one or more
+       * interrupts.
+       */
+      for (j = 0; j < gpio->num_irqs_per_bank; j++) {
+        dev_dbg(dev, "programming default interrupt routing for port %s\n",
+          port->name);
+
+        offset = TEGRA186_GPIO_INT_ROUTE_MAPPING(p, j);
+
+        /*
+         * By default we only want to route GPIO pins to IRQ 0. This works
+         * only under the assumption that we're running as the host kernel
+         * and hence all GPIO pins are owned by Linux.
+         *
+         * For cases where Linux is the guest OS, the hypervisor will have
+         * to configure the interrupt routing and pass only the valid
+         * interrupts via device tree.
+         */
+
+        #if defined(CONFIG_TEGRA_GPIO_GUEST_PROXY) || defined(CONFIG_TEGRA_GPIO_HOST_PROXY)
+				// deb_verbose("Debug exception %d", GPIO_NOPT_TEST3);
+        if (j == 0) {
+          value = readl_x(base + offset);
+          value = BIT(port->pins) - 1;
+          writel_x(value, base + offset);
+        }
+        #else
 				if (j == 0) {
 					value = readl(base + offset);
 					value = BIT(port->pins) - 1;
 					writel(value, base + offset);
 				}
-			}
-		}
-	}
+        #endif
+      }
+    }
+  }
+  #if defined(GPIO_DEBUG_EXCEPTIONS)
+  kernel_is_on_guest = stash;
+  #endif
 }
 
 static unsigned int tegra186_gpio_irqs_per_bank(struct tegra_gpio *gpio)
 {
-	struct device *dev = gpio->gpio.parent;
+  struct device *dev = gpio->gpio.parent;
 
-	if (gpio->num_irq > gpio->num_banks) {
-		if (gpio->num_irq % gpio->num_banks != 0)
-			goto error;
-	}
+  if (gpio->num_irq > gpio->num_banks) {
+    if (gpio->num_irq % gpio->num_banks != 0)
+      goto error;
+  }
 
-	if (gpio->num_irq < gpio->num_banks)
-		goto error;
+  if (gpio->num_irq < gpio->num_banks)
+    goto error;
 
-	gpio->num_irqs_per_bank = gpio->num_irq / gpio->num_banks;
+  gpio->num_irqs_per_bank = gpio->num_irq / gpio->num_banks;
 
-	if (gpio->num_irqs_per_bank > gpio->soc->num_irqs_per_bank)
-		goto error;
+  if (gpio->num_irqs_per_bank > gpio->soc->num_irqs_per_bank)
+    goto error;
 
-	return 0;
+  return 0;
 
 error:
-	dev_err(dev, "invalid number of interrupts (%u) for %u banks\n",
-		gpio->num_irq, gpio->num_banks);
-	return -EINVAL;
+  dev_err(dev, "invalid number of interrupts (%u) for %u banks\n",
+    gpio->num_irq, gpio->num_banks);
+  return -EINVAL;
 }
 
-static int tegra186_gpio_probe(struct platform_device *pdev)
-{
-	unsigned int i, j, offset;
-	struct gpio_irq_chip *irq;
-	struct tegra_gpio *gpio;
-	struct device_node *np;
-	struct resource *res;
-	char **names;
-	int err;
-	int ret;
-	int value;
-	void __iomem *base;
-
-	gpio = devm_kzalloc(&pdev->dev, sizeof(*gpio), GFP_KERNEL);
-	if (!gpio)
-		return -ENOMEM;
-
-	gpio->soc = of_device_get_match_data(&pdev->dev);
-	gpio->gpio.label = gpio->soc->name;
-	gpio->gpio.parent = &pdev->dev;
-
-	gpio->secure = devm_platform_ioremap_resource_byname(pdev, "security");
-	if (IS_ERR(gpio->secure))
-		return PTR_ERR(gpio->secure);
-
-	/* count the number of banks in the controller */
-	for (i = 0; i < gpio->soc->num_ports; i++)
-		if (gpio->soc->ports[i].bank > gpio->num_banks)
-			gpio->num_banks = gpio->soc->ports[i].bank;
-
-	gpio->num_banks++;
-
-	gpio->base = devm_platform_ioremap_resource_byname(pdev, "gpio");
-	if (IS_ERR(gpio->base))
-		return PTR_ERR(gpio->base);
-
-	gpio->gpio_rval = devm_kzalloc(&pdev->dev, gpio->soc->num_ports * 8 *
-				      sizeof(*gpio->gpio_rval), GFP_KERNEL);
-	if (!gpio->gpio_rval)
-		return -ENOMEM;
-
-	np = pdev->dev.of_node;
-	if (!np) {
-		dev_err(&pdev->dev, "No valid device node, probe failed\n");
-		return -EINVAL;
-	}
-
-	gpio->use_timestamp = of_property_read_bool(np, "use-timestamp");
-
-	if (gpio->use_timestamp) {
-		res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "gte");
-		if (!res) {
-			dev_err(&pdev->dev, "Missing gte MEM resource\n");
-			return -ENODEV;
-		}
-		gpio->gte_regs = devm_ioremap_resource(&pdev->dev, res);
-		if (IS_ERR(gpio->gte_regs)) {
-			ret = PTR_ERR(gpio->gte_regs);
-			dev_err(&pdev->dev,
-				"Failed to iomap for gte: %d\n", ret);
-			return ret;
-		}
-	}
-
-	err = platform_irq_count(pdev);
-	if (err < 0)
-		return err;
-
-	gpio->num_irq = err;
-
-	err = tegra186_gpio_irqs_per_bank(gpio);
-	if (err < 0)
-		return err;
-
-	gpio->irq = devm_kcalloc(&pdev->dev, gpio->num_irq, sizeof(*gpio->irq),
-				 GFP_KERNEL);
-	if (!gpio->irq)
-		return -ENOMEM;
-
-	for (i = 0; i < gpio->num_irq; i++) {
-		err = platform_get_irq(pdev, i);
-		if (err < 0)
-			return err;
-
-		gpio->irq[i] = err;
-	}
-
+// PT function that gets the host value for gpio->secure and gpio->host
+void *gpio_get_host_values(unsigned char id, unsigned int h_val);
+
+#if defined(CONFIG_TEGRA_GPIO_GUEST_PROXY) || defined(CONFIG_TEGRA_GPIO_HOST_PROXY)
+
+  // functions that are passed through. Function body is in gpio-guest-proxy.c
+  int gpiochip_generic_request_redirect(struct gpio_chip *gc, unsigned offset);
+  void gpiochip_generic_free_redirect(struct gpio_chip *gc, unsigned offset);
+  int tegra186_gpio_get_direction_redirect(struct gpio_chip *chip,
+                unsigned int offset);
+  int tegra186_gpio_direction_input_redirect(struct gpio_chip *chip,
+            unsigned int offset);
+  int tegra186_gpio_direction_output_redirect(struct gpio_chip *chip,
+              unsigned int offset, int level);
+  int tegra186_gpio_get_redirect(struct gpio_chip *chip, unsigned int offset);
+  void tegra186_gpio_set_redirect(struct gpio_chip *chip, unsigned int offset,
+              int level);
+  void tegra186_gpio_set_by_name_redirect(const char *name, unsigned int offset,   // TODO, seems to work without
+              int level);
+  int tegra186_gpio_set_config_redirect(struct gpio_chip *chip,
+              unsigned int offset,
+              unsigned long config);
+  /*
+  const struct tegra_gpio_port *
+  tegra186_gpio_get_port_redirect(struct tegra_gpio *gpio, unsigned int *pin);
+
+  void __iomem *tegra186_gpio_get_base_redirect(unsigned char id,
+
+              unsigned int pin);
+
+  void __iomem *tegra186_gpio_get_secure_redirect(struct tegra_gpio *gpio,
+              unsigned int pin);
+  */
+
+  int tegra_gpio_timestamp_control_redirect(struct gpio_chip *chip, unsigned offset,
+            int enable);
+  int tegra_gpio_timestamp_read_redirect(struct gpio_chip *chip, unsigned offset,
+              u64 *ts);
+  int tegra_gpio_suspend_configure_redirect(struct gpio_chip *chip, unsigned offset,
+            enum gpiod_flags dflags);
+  int tegra186_gpio_add_pin_ranges_redirect(struct gpio_chip *chip);
+  
+  /* functions that are called both locally and passed through
+   * This addition is not necessary for output pins
+   */
+
+  /*
+  static inline int gpiochip_generic_request_both(struct gpio_chip *chip, unsigned offset) {
+    int r1=0, r2=0;
+    deb_verbose("chip=%s, offset=%d\n", chip->label, offset);
+    r1 = gpiochip_generic_request(chip, offset);
+    r2 = gpiochip_generic_request_redirect(chip, offset);
+    if( r1 != r2 ) deb_debug("return values differ %d/%d", r1, r2);
+    return r2;
+  }
+
+  static inline void gpiochip_generic_free_both(struct gpio_chip *chip, unsigned offset) {
+    deb_verbose("chip=%s, offset=%d\n", chip->label, offset);
+    gpiochip_generic_free_redirect(chip, offset);
+    gpiochip_generic_free(chip, offset);
+  }
+  */
+
+  static inline int tegra186_gpio_get_direction_both(struct gpio_chip *chip, unsigned int offset) {
+    int r1=0, r2=0;
+    deb_verbose("chip=%s, offset=%d\n", chip->label, offset);
+    r1 = tegra186_gpio_get_direction(chip, offset);
+    r2 = tegra186_gpio_get_direction_redirect(chip, offset);
+    if( r1 != r2 ) deb_debug("return values differ %d/%d", r1, r2);
+    return r2;
+  }
+
+  static inline int tegra186_gpio_direction_input_both(struct gpio_chip *chip, unsigned int offset) {
+    int r1=0, r2=0;
+    deb_verbose("chip=%s, offset=%d\n", chip->label, offset);
+    r1 = tegra186_gpio_direction_input(chip, offset);
+    r2 = tegra186_gpio_direction_input_redirect(chip, offset);
+    if( r1 != r2 ) deb_debug("return values differ %d/%d", r1, r2);
+    return r2;
+  }
+
+  static inline int tegra186_gpio_direction_output_both(struct gpio_chip *chip, unsigned int offset, int level) {
+    int r1=0, r2=0;
+    deb_verbose("chip=%s, offset=%d\n level=%d", chip->label, offset, level);
+    r1 = tegra186_gpio_direction_output(chip, offset, level);
+    r2 = tegra186_gpio_direction_output_redirect(chip, offset, level);
+    if( r1 != r2 ) deb_debug("return values differ %d/%d", r1, r2);
+    return r2;
+  }
+
+  /*
+  static int tegra186_gpio_get_both(struct gpio_chip *chip, unsigned int offset) {
+    int r1=0, r2=0;
+    r1 = tegra186_gpio_get_redirect(chip, offset);
+    r2 = tegra186_gpio_get(chip, offset);
+    if( r1 != r2 ) deb_debug("return values differ %d/%d", r1, r2);
+    return r2;
+  }
+
+  static inline void tegra186_gpio_set_both(struct gpio_chip *chip, unsigned int offset, int level) {
+    tegra186_gpio_set(chip, offset, level);
+    tegra186_gpio_set_redirect(chip, offset, level);
+  }
+
+  static inline int tegra186_gpio_set_config_both(struct gpio_chip *chip,
+                unsigned int offset,
+                unsigned long config) {
+    int r1=0, r2=0;
+    deb_verbose("chip=%s, offset=%d\n", chip->label, offset);
+    r1 = tegra186_gpio_set_config_redirect(chip, offset, config);
+    r2 = tegra186_gpio_set_config(chip, offset, config);
+    if( r1 != r2 ) deb_debug("return values differ %d/%d", r1, r2);
+    return r2;
+  }
+
+  static int tegra186_gpio_add_pin_ranges_both(struct gpio_chip *chip) {
+    int r1=0, r2=0;
+    deb_verbose("chip=%s\n", chip->label);
+    r1 = tegra186_gpio_add_pin_ranges(chip);
+    r2 = tegra186_gpio_add_pin_ranges_redirect(chip);
+    if( r1 != r2 ) deb_debug("return values differ %d/%d", r1, r2);
+    return r2;
+  }
+  */
+
+  /*
+  static inline int tegra186_gpio_direction_input_nopt(struct gpio_chip *chip, unsigned int offset) {
+    int r;
+    kernel_is_on_guest = false; // inhibit passthrough
+    r = tegra186_gpio_direction_input(chip, offset);
+    kernel_is_on_guest = true;
+    return r;
+  }
+
+  static inline int tegra186_gpio_direction_output_nopt(struct gpio_chip *chip, unsigned int offset, int level) {
+    int r;
+    kernel_is_on_guest = false; // inhibit passthrough
+    r = tegra186_gpio_direction_output(chip, offset, level);
+    kernel_is_on_guest = true;
+    return r;
+  }
+
+  static inline void tegra186_gpio_set_nopt(struct gpio_chip *chip, unsigned int offset, int level) {
+    kernel_is_on_guest = false; // inhibit passthrough
+    tegra186_gpio_set(chip, offset, level);
+    kernel_is_on_guest = true;
+  }
+  */
+#endif
 
+// this function sets the standard bindings used by the host driver
+static inline void gpio_nohook(struct tegra_gpio *gpio) {
+	deb_debug("Setting default functions for %s", gpio->gpio.label);
 	gpio->gpio.request = gpiochip_generic_request;
 	gpio->gpio.free = gpiochip_generic_free;
 	gpio->gpio.get_direction = tegra186_gpio_get_direction;
 	gpio->gpio.direction_input = tegra186_gpio_direction_input;
 	gpio->gpio.direction_output = tegra186_gpio_direction_output;
-	gpio->gpio.get = tegra186_gpio_get,
+	gpio->gpio.get = tegra186_gpio_get;
 	gpio->gpio.set = tegra186_gpio_set;
 	gpio->gpio.set_config = tegra186_gpio_set_config;
 	gpio->gpio.timestamp_control = tegra_gpio_timestamp_control;
 	gpio->gpio.timestamp_read = tegra_gpio_timestamp_read;
-	gpio->gpio.suspend_configure = tegra_gpio_suspend_configure;
+	gpio->gpio.suspend_configure = tegra_gpio_suspend_configure;	// dont do passthrough
+	// gpio->gpio.to_irq = N/A;
+	// gpio->gpio.dbg_show = N/A;
+	// gpio->gpio.init_valid_mask = N/A;
 	gpio->gpio.add_pin_ranges = tegra186_gpio_add_pin_ranges;
-
 	gpio->gpio.base = -1;
+}
 
-	for (i = 0; i < gpio->soc->num_ports; i++)
-		gpio->gpio.ngpio += gpio->soc->ports[i].pins;
-
-	names = devm_kcalloc(gpio->gpio.parent, gpio->gpio.ngpio,
-			     sizeof(*names), GFP_KERNEL);
-	if (!names)
-		return -ENOMEM;
-
-	for (i = 0, offset = 0; i < gpio->soc->num_ports; i++) {
-		const struct tegra_gpio_port *port = &gpio->soc->ports[i];
-		char *name;
-
-		for (j = 0; j < port->pins; j++) {
-			name = devm_kasprintf(gpio->gpio.parent, GFP_KERNEL,
-					      "P%s.%02x", port->name, j);
-			if (!name)
-				return -ENOMEM;
-
-			names[offset + j] = name;
-		}
-
-		offset += port->pins;
-	}
-
-	gpio->gpio.names = (const char * const *)names;
-
-	gpio->gpio.of_node = pdev->dev.of_node;
-	gpio->gpio.of_gpio_n_cells = 2;
-	gpio->gpio.of_xlate = tegra186_gpio_of_xlate;
-
-	gpio->intc.name = pdev->dev.of_node->name;
-	gpio->intc.irq_ack = tegra186_irq_ack;
-	gpio->intc.irq_mask = tegra186_irq_mask;
-	gpio->intc.irq_unmask = tegra186_irq_unmask;
-	gpio->intc.irq_set_type = tegra186_irq_set_type;
-	gpio->intc.irq_set_wake = tegra186_irq_set_wake;
-
-	irq = &gpio->gpio.irq;
-	irq->chip = &gpio->intc;
-	irq->fwnode = of_node_to_fwnode(pdev->dev.of_node);
-	irq->child_to_parent_hwirq = tegra186_gpio_child_to_parent_hwirq;
-	irq->populate_parent_alloc_arg = tegra186_gpio_populate_parent_fwspec;
-	irq->child_offset_to_irq = tegra186_gpio_child_offset_to_irq;
-	irq->child_irq_domain_ops.translate = tegra186_gpio_irq_domain_translate;
-	irq->handler = handle_simple_irq;
-	irq->default_type = IRQ_TYPE_NONE;
-	irq->parent_handler = tegra186_gpio_irq;
-	irq->parent_handler_data = gpio;
-	irq->num_parents = gpio->num_irq;
-
-
-	/*
-	* To simplify things, use a single interrupt per bank for now. Some
-	* chips support up to 8 interrupts per bank, which can be useful to
-	* distribute the load and decrease the processing latency for GPIOs
-	* but it also requires a more complicated interrupt routing than we
-	* currently program.
-	*/
-	if (gpio->num_irqs_per_bank > 1) {
-		irq->parents = devm_kcalloc(&pdev->dev, gpio->num_banks,
-						sizeof(*irq->parents), GFP_KERNEL);
-		if (!irq->parents)
-			return -ENOMEM;
-
-		for (i = 0; i < gpio->num_banks; i++)
-			irq->parents[i] = gpio->irq[i * gpio->num_irqs_per_bank];
-
-		irq->num_parents = gpio->num_banks;
-	} else {
-		irq->num_parents = gpio->num_irq;
-		irq->parents = gpio->irq;
-	}
-
-	if (gpio->soc->num_irqs_per_bank > 1)
-		tegra186_gpio_init_route_mapping(gpio);
-
-	np = of_find_matching_node(NULL, tegra186_pmc_of_match);
-	if (!of_device_is_available(np))
-		np = of_irq_find_parent(pdev->dev.of_node);
-
-	if (of_device_is_available(np)) {
-		irq->parent_domain = irq_find_host(np);
-		of_node_put(np);
-
-		if (!irq->parent_domain)
-			return -EPROBE_DEFER;
+#if defined(CONFIG_TEGRA_GPIO_GUEST_PROXY) || defined(CONFIG_TEGRA_GPIO_HOST_PROXY)
+
+	static inline void gpio_sethook(struct tegra_gpio *gpio) {
+		// default values for redirection
+		gpio->gpio.request = gpiochip_generic_request_redirect;	                // passthrough
+		gpio->gpio.free = gpiochip_generic_free_redirect;	                      // passthrough
+		gpio->gpio.get_direction = tegra186_gpio_get_direction_redirect;	      // passthrough
+		gpio->gpio.direction_input = tegra186_gpio_direction_input_redirect;	  // passthrough
+		gpio->gpio.direction_output = tegra186_gpio_direction_output_redirect;	// passthrough
+		gpio->gpio.get = tegra186_gpio_get;
+		gpio->gpio.set = tegra186_gpio_set;
+		gpio->gpio.set_config = tegra186_gpio_set_config;
+		// gpio->gpio.get_multiple = N/A;
+		// gpio->gpio.set_multiple = N/A
+		// ??? = tegra186_gpio_get_port_redirect;   // not in struct
+		// ??? = tegra186_gpio_get_base_redirect;   // not in struct
+		// ??? = tegra186_gpio_get_secure_redirect; // not in struct
+		gpio->gpio.timestamp_control = tegra_gpio_timestamp_control;
+		gpio->gpio.timestamp_read = tegra_gpio_timestamp_read;
+		gpio->gpio.suspend_configure = tegra_gpio_suspend_configure;
+		gpio->gpio.add_pin_ranges = tegra186_gpio_add_pin_ranges;
+		gpio->gpio.base = -1;
 	}
+	
+  /* "normal" redirect version */
+  static inline void gpio_hook(struct tegra_gpio *gpio) {
+    deb_debug("Setting hooks for functions for %s", gpio->gpio.label);
+		#if defined(GPIO_DEBUG_EXCEPTIONS)
+		gpio_nohook(gpio);
+    if(!is_debug_exception(GPIO_NOFUNC_TEST0A))
+      gpio->gpio.request = gpiochip_generic_request_redirect;
+    if(!is_debug_exception(GPIO_NOFUNC_TEST0B))
+      gpio->gpio.free = gpiochip_generic_free_redirect;
+    if(!is_debug_exception(GPIO_NOFUNC_TEST1))
+      gpio->gpio.get_direction = tegra186_gpio_get_direction_redirect;
+    if(!is_debug_exception(GPIO_NOFUNC_TEST2A))
+      gpio->gpio.direction_input = tegra186_gpio_direction_input_redirect;
+    if(!is_debug_exception(GPIO_NOFUNC_TEST2B))
+      gpio->gpio.direction_output = tegra186_gpio_direction_output_redirect;
+    if(!is_debug_exception(GPIO_NOFUNC_TEST3A))
+      gpio->gpio.get = tegra186_gpio_get_redirect;
+    if(!is_debug_exception(GPIO_NOFUNC_TEST3B))
+      gpio->gpio.set = tegra186_gpio_set_redirect;
+    if(!is_debug_exception(GPIO_NOFUNC_TEST4))
+      gpio->gpio.set_config = tegra186_gpio_set_config_redirect;
+      // gpio->gpio.get_multiple = N/A;
+      // gpio->gpio.set_multiple = N/A
+      // ??? = tegra186_gpio_get_port_redirect;   // not in struct
+      // ??? = tegra186_gpio_get_base_redirect;   // not in struct
+      // ??? = tegra186_gpio_get_secure_redirect; // not in struct
+    if(!is_debug_exception(GPIO_NOFUNC_TEST5A))
+      gpio->gpio.timestamp_control = tegra_gpio_timestamp_control_redirect;
+    if(!is_debug_exception(GPIO_NOFUNC_TEST5B))
+      gpio->gpio.timestamp_read = tegra_gpio_timestamp_read_redirect;
+    if(!is_debug_exception(GPIO_NOFUNC_TEST6))
+      gpio->gpio.suspend_configure = tegra_gpio_suspend_configure_redirect;
+    if(!is_debug_exception(GPIO_NOFUNC_TEST7))
+      gpio->gpio.add_pin_ranges = tegra186_gpio_add_pin_ranges_redirect;
+
+    if(!is_debug_exception(GPIO_BOTH_TEST)) {
+			if(is_debug_exception(GPIO_BOTHFUNC_TEST2))
+				gpio->gpio.get_direction = tegra186_gpio_get_direction_both;
+			if(is_debug_exception(GPIO_BOTHFUNC_TEST3))
+				gpio->gpio.direction_input = tegra186_gpio_direction_input_both;
+			if(is_debug_exception(GPIO_BOTHFUNC_TEST4))
+				gpio->gpio.direction_output = tegra186_gpio_direction_output_both;
+		}
+		#else
+		gpio_sethook(gpio);
+	  #endif
+    gpio->gpio.base = -1;
+  }
+
+  extern int tegra_gpio_guest_init(void);
+  extern int tegra_gpio_host_init(void);
+  extern int tegra_gpio_guest_cleanup(void);
+  extern int tegra_gpio_host_cleanup(void);
+
+  #define MAX_CHIP 2    // check this value against value in gpio_host-proxy.h
+
+  struct tegra_gpio *tegra_gpio_hosts[MAX_CHIP] = {NULL, NULL};
+  atomic_t tegra_gpio_hosts_ready = ATOMIC_INIT(0);
+
+  /* note for reference:
+  struct tegra_gpio {
+    struct gpio_chip gpio;
+    struct irq_chip intc;
+    unsigned int num_irq;
+    unsigned int *irq;
+    [...]
+  }
+
+  struct gpio_chip {
+    const char    *label;
+    struct gpio_device  *gpiodev;
+    struct device   *parent;
+    struct module   *owner;
+    [...]
+  }
+
+  struct gpio_device  *gpiodev {
+    int     id;
+    struct device   dev;
+  }
+
+  */
+
+  /* preserve_tegrachip() and unpreserve_all_tegrachips() functions
+   *
+   * store the tegra_gpio and gpio_chip pointers for direct use by proxy drivers
+   * the preserve functions also assist in allocation and deallocaton, setting up and unseting
+   * of proxy related data */
+  static void preserve_tegrachip(struct tegra_gpio *tegrachip) {
+    static int gpio_chip_count = 0;
+    deb_debug("entering with gpio_chip_count = %d\n", gpio_chip_count);
+
+    if (gpio_chip_count >= MAX_CHIP) {
+      pr_err("GPIO, *ERROR* maximum chip count is exceeded (%d)", gpio_chip_count);
+    }
+    else {
+      tegra_gpio_hosts[gpio_chip_count] = tegrachip;
+      deb_debug("put chip %s in list for passthrough in slot %d [0..1]\n", tegrachip->gpio.label, gpio_chip_count);
+    };
+    atomic_set(&tegra_gpio_hosts_ready, ++gpio_chip_count);
+  }
+
+
+  /* deactivates tegra_gpio_hosts array, function is called by guest proxy.
+   * allocations and hooks are not needed if guest proxy driver unloads
+   * (paranoia because drivers are built in) */
+  void unpreserve_all_tegrachips(void) {
+    struct tegra_gpio ** tegrachip;
+    int i, timeout = 0;
+
+    // wait until tegra driver has set the tegra_gpio_hosts array -- this seems a bit paranoid
+    while (atomic_read(&tegra_gpio_hosts_ready) != MAX_CHIP) {
+      msleep(100); // Sleep briefly instead of looping infinitely.
+      if( timeout++ > 120 ) {
+        pr_err("GPIO could not access tegra_gpio chip array\n");
+        return;
+      }
+    }
+    for( i = 0 ; i < MAX_CHIP ; i++){
+      tegrachip = &tegra_gpio_hosts[i];
+      if(*tegrachip)
+        gpio_nohook(*tegrachip);
+      *tegrachip = NULL;
+    }
+  }
+  EXPORT_SYMBOL_GPL(unpreserve_all_tegrachips);
+
+  /* find_chip_by_id
+   * replacement for find_chip_by_name, because it is slightly faster
+   * one doubtful assumption is that chip pointers are numbered by the driver
+   * in the same order preserve_tegrachip records them */
+  inline struct gpio_chip * find_chip_by_id(int id) {
+    int i = 0, r;
+    while ( (r = atomic_read(&tegra_gpio_hosts_ready)) != MAX_CHIP) {
+      msleep(100); // Sleep briefly instead of looping infinitely.
+      if( i++ > 10 ) {
+        pr_err("GPIO tegra_gpio_host chip table setup error: id=%d, count=%d\n", id, r);
+        if(r == 1) return &tegra_gpio_hosts[0]->gpio;
+        else return NULL;
+      }
+    }
+    if(id & ~0x00000001) {
+      pr_err("GPIO, *ERROR* Illegal chip number (%d)", id);
+      return NULL;
+    }
+    else
+      return &tegra_gpio_hosts[id]->gpio;
+  }
+  EXPORT_SYMBOL_GPL(find_chip_by_id);
+
+  inline struct tegra_gpio * find_tegra_chip_by_id(int id) {
+    /*
+    int i = 0;
+    while (atomic_read(&tegra_gpio_hosts_ready) != MAX_CHIP) {
+      msleep(100); // Sleep briefly instead of looping infinitely.
+      if( i++ > 120 ) {
+        pr_err("GPIO tegra_gpio_hosts setup error: id=%d, count=%d\n", id, atomic_read(&tegra_gpio_hosts_ready));
+        return NULL;
+      }
+    }
+    */
+    if(id & ~0x00000001) {
+      pr_err("GPIO, *ERROR* Illegal chip number (%d)", id);
+      return NULL;
+    }
+    else
+      return tegra_gpio_hosts[id];
+  }
+  EXPORT_SYMBOL_GPL(find_tegra_chip_by_id);
+  
+#endif
 
+struct tegra_gpio_local_values gpio_local_values[2] = {
+	{ .initialised = false },
+	{ .initialised = false }
+};
 
-	irq->map = devm_kcalloc(&pdev->dev, gpio->gpio.ngpio,
-				sizeof(*irq->map), GFP_KERNEL);
-	if (!irq->map)
-		return -ENOMEM;
-
-	for (i = 0, offset = 0; i < gpio->soc->num_ports; i++) {
-		const struct tegra_gpio_port *port = &gpio->soc->ports[i];
-
-		for (j = 0; j < port->pins; j++)
-			irq->map[offset + j] = irq->parents[port->bank];
-
-		offset += port->pins;
-	}
-
-	platform_set_drvdata(pdev, gpio);
-
-	err = devm_gpiochip_add_data(&pdev->dev, &gpio->gpio, gpio);
-	if (err < 0)
-		return err;
-
-	if (gpio->soc->is_hw_ts_sup) {
-		for (i = 0, offset = 0; i < gpio->soc->num_ports; i++) {
-			const struct tegra_gpio_port *port =
-							&gpio->soc->ports[i];
-
-			for (j = 0; j < port->pins; j++) {
-				base = tegra186_gpio_get_base(gpio, offset + j);
-				if (WARN_ON(base == NULL))
-					return -EINVAL;
-
-				value = readl(base +
-					      TEGRA186_GPIO_ENABLE_CONFIG);
-				value |=
-				TEGRA186_GPIO_ENABLE_CONFIG_TIMESTAMP_FUNC;
-				writel(value,
-				       base + TEGRA186_GPIO_ENABLE_CONFIG);
-			}
-			offset += port->pins;
-		}
-	}
+static int tegra186_gpio_probe(struct platform_device *pdev)
+{
+  unsigned int i, j, offset;
+  struct gpio_irq_chip *irq;
+  struct tegra_gpio *gpio;
+  struct device_node *np;
+  struct resource *res;
+  char **names;
+  int err;
+  int ret;
+  int value;
+  void __iomem *base;
+
+  #if defined(CONFIG_TEGRA_GPIO_GUEST_PROXY) || defined(CONFIG_TEGRA_GPIO_HOST_PROXY)
+  static bool guest_proxy_is_set_up = false;
+  static bool host_proxy_is_set_up = false;
+  #endif
+
+  deb_debug("Probing gpio");
+
+  gpio = devm_kzalloc(&pdev->dev, sizeof(*gpio), GFP_KERNEL);
+  if (!gpio) {
+    pr_err("GPIO devm_kzalloc error");
+    return -ENOMEM;
+  }
+
+	#if defined(CONFIG_TEGRA_GPIO_GUEST_PROXY) || defined(CONFIG_TEGRA_GPIO_HOST_PROXY)
+
+    deb_debug("GPIO Proxy code\n");
+
+    // If virtual-pa node is defined, it means that we are using a GPIO proxy
+    err = of_property_read_u64(pdev->dev.of_node, "virtual-pa", &gpio_vpa);
+    if(!err) {
+      // error in reading virtual-pa is non fatal, it only means we are on host.
+      deb_info("GPIO kernel is on guest, virtual-pa: 0x%llx\n", gpio_vpa);
+      kernel_is_on_guest = true;
+    }
+	#endif
+
+  gpio->soc = of_device_get_match_data(&pdev->dev);
+  gpio->gpio.label = gpio->soc->name;
+  gpio->gpio.parent = &pdev->dev;
+
+  gpio_local_values[gpio->soc->instance].secure = devm_platform_ioremap_resource_byname(pdev, "security");
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+  deb_verbose("secure address for %d is 0x%p\n", gpio->soc->instance, gpio_local_values[gpio->soc->instance].secure);
+  if(kernel_is_on_guest && !is_debug_exception(GPIO_NOPT_TEST7))
+    gpio->secure = gpio_get_host_values(gpio->soc->instance, GPIO_HOST_VALUE_SECURE); // a passthrogh function
+  else
+	#endif
+    gpio->secure = gpio_local_values[gpio->soc->instance].secure;
+
+  if (IS_ERR(gpio->secure)) {
+    pr_err("GPIO *ERROR* devm_platform_ioremap_resource_byname pdev->name=\"%s\"", pdev->name);
+    return PTR_ERR(gpio->secure);
+  }
+
+  deb_verbose("num of ports = %d", gpio->soc->num_ports);
+
+  /* count the number of banks in the controller */
+  for (i = 0; i < gpio->soc->num_ports; i++)
+    if (gpio->soc->ports[i].bank > gpio->num_banks)
+      gpio->num_banks = gpio->soc->ports[i].bank;
+
+  gpio->num_banks++;
+
+  deb_verbose("num of banks = %d", gpio->num_banks);
+
+  gpio_local_values[gpio->soc->instance].base = devm_platform_ioremap_resource_byname(pdev, "gpio");
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+  if(kernel_is_on_guest && !is_debug_exception(GPIO_NOPT_TEST2))
+    gpio->base = gpio_get_host_values(gpio->soc->instance, GPIO_HOST_VALUE_BASE);
+  else
+  #endif
+    gpio->base = gpio_local_values[gpio->soc->instance].base;
+  if (IS_ERR(gpio->base))
+    return PTR_ERR(gpio->base);
+
+  deb_verbose("gpio base = 0x%llx", (long long unsigned int)gpio->base);
+
+  gpio->gpio_rval = devm_kzalloc(&pdev->dev, gpio->soc->num_ports * 8 *
+              sizeof(*gpio->gpio_rval), GFP_KERNEL);
+  // gpio->gpio_rval = gpio_get_host_values(id, GPIO_HOST_VALUE_GPIO_RVAL);	// should probably be guest address space
+  if (!gpio->gpio_rval)
+    return -ENOMEM;
+
+  np = pdev->dev.of_node;
+  if (!np) {
+    dev_err(&pdev->dev, "No valid device node, probe failed\n");
+    return -EINVAL;
+  }
+
+  deb_verbose("node pointer = 0x%llx", (long long unsigned int)np);
+
+  gpio->use_timestamp = of_property_read_bool(np, "use-timestamp");
+
+  if (gpio->use_timestamp) {
+    deb_verbose("use_timestamp");
+    res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "gte");
+    if (!res) {
+      dev_err(&pdev->dev, "Missing gte MEM resource\n");
+      return -ENODEV;
+    }
+    gpio->gte_regs = devm_ioremap_resource(&pdev->dev, res);
+    // gpio->gte_regs = gpio_get_host_values(id, GPIO_HOST_VALUE_GTE_REGS);	// should probably be guest address space
+    if (IS_ERR(gpio->gte_regs)) {
+      ret = PTR_ERR(gpio->gte_regs);
+      dev_err(&pdev->dev,
+        "Failed to iomap for gte: %d\n", ret);
+      return ret;
+    }
+  }
+
+  err = platform_irq_count(pdev);
+  if (err < 0) {
+    pr_err("GPIO platform_irq_count\n");
+    return err;
+  }
+
+  gpio->num_irq = err;
+
+  deb_verbose("num_irq = %d", gpio->num_irq);
+
+  err = tegra186_gpio_irqs_per_bank(gpio);
+  if (err < 0) {
+    pr_err("GPIO tegra186_gpio_irqs_per_bank\n");
+    return err;
+  }
+
+  gpio->irq = devm_kcalloc(&pdev->dev, gpio->num_irq, sizeof(*gpio->irq),
+         GFP_KERNEL);
+  if (!gpio->irq)
+    return -ENOMEM;
+
+  for (i = 0; i < gpio->num_irq; i++) {
+    err = platform_get_irq(pdev, i);
+    if (err < 0) {
+      pr_err("GPIO platform_get_irq");
+      return err;
+    }
+
+    gpio->irq[i] = err;
+  }
 
 	if (gpio->use_timestamp)
 		tegra_gte_setup(gpio);
 
-	return 0;
+	  #if defined(CONFIG_TEGRA_GPIO_HOST_PROXY) || defined(CONFIG_TEGRA_GPIO_GUEST_PROXY)
+
+    if(kernel_is_on_guest) {
+      deb_debug("GPIO Proxy guest init section\n");
+      if( ! guest_proxy_is_set_up ) {
+        ret = tegra_gpio_guest_init();
+        guest_proxy_is_set_up = true;
+      }
+      // guest should use gpio_hook() for its "host" driver
+      gpio_hook(gpio);
+    }
+    else {
+      deb_debug("GPIO Proxy host init section\n");
+      if( ! host_proxy_is_set_up ) {
+        ret = tegra_gpio_host_init();
+        host_proxy_is_set_up = true;
+      }
+      // gpio_nohook is the same as standard settings
+      // unhooked pointers are for the host driver on host only
+      BUG_ON(gpio_vpa != 0);  // assert we do not set up the vpa driver
+      gpio_nohook(gpio);      // set standard function pointers
+    };
+
+    gpio->gpio.base = -1;
+    deb_debug("gpio function pointers are set for gpio label=%s\n", gpio->gpio.label);
+    #else
+    // this code segment is for standard operation in a compile without PROXY configuraton
+    deb_debug("Setting standard gpio functions for a non-proxy compile of driver\n");
+    // BUG_ON(gpio_vpa != 0);  // assert we do not set up the vpa driver, because non-proxy
+    gpio_nohook(gpio);
+    #endif
+
+  for (i = 0; i < gpio->soc->num_ports; i++)
+    gpio->gpio.ngpio += gpio->soc->ports[i].pins;
+
+  names = devm_kcalloc(gpio->gpio.parent, gpio->gpio.ngpio,
+           sizeof(*names), GFP_KERNEL);
+  if (!names)
+    return -ENOMEM;
+
+  for (i = 0, offset = 0; i < gpio->soc->num_ports; i++) {
+    const struct tegra_gpio_port *port = &gpio->soc->ports[i];
+    char *name;
+
+    for (j = 0; j < port->pins; j++) {
+      name = devm_kasprintf(gpio->gpio.parent, GFP_KERNEL,
+                "P%s.%02x", port->name, j);
+      if (!name)
+        return -ENOMEM;
+
+      names[offset + j] = name;
+      // deb_verbose("GPIO, name=\n", name);
+    }
+
+    offset += port->pins;
+  }
+
+  gpio->gpio.names = (const char * const *)names;
+
+  gpio->gpio.of_node = pdev->dev.of_node;
+  gpio->gpio.of_gpio_n_cells = 2;
+  gpio->gpio.of_xlate = tegra186_gpio_of_xlate;
+
+  gpio->intc.name = pdev->dev.of_node->name;
+  gpio->intc.irq_ack = tegra186_irq_ack;
+  gpio->intc.irq_mask = tegra186_irq_mask;
+  gpio->intc.irq_unmask = tegra186_irq_unmask;
+  gpio->intc.irq_set_type = tegra186_irq_set_type;
+  gpio->intc.irq_set_wake = tegra186_irq_set_wake;
+
+  irq = &gpio->gpio.irq;
+  irq->chip = &gpio->intc;
+  irq->fwnode = of_node_to_fwnode(pdev->dev.of_node);
+  irq->child_to_parent_hwirq = tegra186_gpio_child_to_parent_hwirq;
+  irq->populate_parent_alloc_arg = tegra186_gpio_populate_parent_fwspec;
+  irq->child_offset_to_irq = tegra186_gpio_child_offset_to_irq;
+  irq->child_irq_domain_ops.translate = tegra186_gpio_irq_domain_translate;
+  irq->handler = handle_simple_irq;
+  irq->default_type = IRQ_TYPE_NONE;
+  irq->parent_handler = tegra186_gpio_irq;
+  irq->parent_handler_data = gpio;
+  irq->num_parents = gpio->num_irq;
+
+  deb_verbose("gpio->gpio.of_node = 0x%llx, pdev->dev.of_node = 0x%llx", (long long unsigned int)gpio->gpio.of_node, (long long unsigned int)pdev->dev.of_node);
+
+  /*
+  * To simplify things, use a single interrupt per bank for now. Some
+  * chips support up to 8 interrupts per bank, which can be useful to
+  * distribute the load and decrease the processing latency for GPIOs
+  * but it also requires a more complicated interrupt routing than we
+  * currently program.
+  */
+  if (gpio->num_irqs_per_bank > 1) {
+    irq->parents = devm_kcalloc(&pdev->dev, gpio->num_banks,
+            sizeof(*irq->parents), GFP_KERNEL);
+    if (!irq->parents)
+      return -ENOMEM;
+
+    for (i = 0; i < gpio->num_banks; i++)
+      irq->parents[i] = gpio->irq[i * gpio->num_irqs_per_bank];
+
+    irq->num_parents = gpio->num_banks;
+  } else {
+    irq->num_parents = gpio->num_irq;
+    irq->parents = gpio->irq;
+  }
+
+  if (gpio->soc->num_irqs_per_bank > 1)
+    tegra186_gpio_init_route_mapping(gpio);
+
+  np = of_find_matching_node(NULL, tegra186_pmc_of_match);
+  if (!of_device_is_available(np))
+    np = of_irq_find_parent(pdev->dev.of_node);
+
+  if (of_device_is_available(np)) {
+    irq->parent_domain = irq_find_host(np);
+    of_node_put(np);
+
+    if (!irq->parent_domain)
+      return -EPROBE_DEFER;
+  }
+
+
+  irq->map = devm_kcalloc(&pdev->dev, gpio->gpio.ngpio,
+        sizeof(*irq->map), GFP_KERNEL);
+  if (!irq->map)
+    return -ENOMEM;
+
+  for (i = 0, offset = 0; i < gpio->soc->num_ports; i++) {
+    const struct tegra_gpio_port *port = &gpio->soc->ports[i];
+
+    for (j = 0; j < port->pins; j++)
+      irq->map[offset + j] = irq->parents[port->bank];
+
+    offset += port->pins;
+  }
+
+  platform_set_drvdata(pdev, gpio);
+  
+  err = devm_gpiochip_add_data(&pdev->dev, &gpio->gpio, gpio);
+  if (err < 0) {
+    pr_err("GPIO *ERROR* devm_gpiochip_add_data\n");
+    return err;
+  }
+
+  if (gpio->soc->is_hw_ts_sup) {
+    for (i = 0, offset = 0; i < gpio->soc->num_ports; i++) {
+      const struct tegra_gpio_port *port =
+              &gpio->soc->ports[i];
+
+      for (j = 0; j < port->pins; j++) {
+			#if defined(GPIO_DEBUG_EXCEPTIONS)   
+        if(kernel_is_on_guest && !is_debug_exception(GPIO_NOPT_TEST4)) {
+          base = tegra186_gpio_get_base(gpio, offset + j);
+          if (WARN_ON(base == NULL))
+            return -EINVAL;
+
+          value = readl_x(base +
+                  TEGRA186_GPIO_ENABLE_CONFIG);
+          value |=
+          TEGRA186_GPIO_ENABLE_CONFIG_TIMESTAMP_FUNC;
+          writel_x(value,
+                base + TEGRA186_GPIO_ENABLE_CONFIG);
+        }
+        else {
+          // deb_verbose("Debug exception %d", GPIO_NOPT_TEST4);
+			#endif
+          base = tegra186_gpio_get_base(gpio, offset + j);
+          if (WARN_ON(base == NULL))
+            return -EINVAL;
+
+          value = readl(base +
+                  TEGRA186_GPIO_ENABLE_CONFIG);
+          value |=
+          TEGRA186_GPIO_ENABLE_CONFIG_TIMESTAMP_FUNC;
+          writel(value,
+                base + TEGRA186_GPIO_ENABLE_CONFIG);
+                
+			#if defined(GPIO_DEBUG_EXCEPTIONS)
+        }
+			#endif
+      }
+      offset += port->pins;
+    }
+  }
+
+  #if defined(CONFIG_TEGRA_GPIO_HOST_PROXY) || defined(CONFIG_TEGRA_GPIO_GUEST_PROXY)
+	gpio_local_values[gpio->soc->instance].initialised = true;
+  preserve_tegrachip(gpio);
+  #endif
+  return 0;
 }
 
 #ifdef CONFIG_PM_SLEEP
 static int tegra_gpio_resume_early(struct device *dev)
 {
-	struct tegra_gpio *gpio = dev_get_drvdata(dev);
-	struct tegra_gpio_saved_register *regs;
-	unsigned offset = 0U;
-	void __iomem *base;
-	int i;
-
-	base = tegra186_gpio_get_base(gpio, offset);
-	if (WARN_ON(base == NULL))
-		return -EINVAL;
-
-	for (i = 0; i < gpio->gpio.ngpio; i++) {
-		regs = &gpio->gpio_rval[i];
-		if (!regs->restore_needed)
-			continue;
-
-		regs->restore_needed = false;
-
-		writel(regs->val,  base + TEGRA186_GPIO_OUTPUT_VALUE);
-		writel(regs->out,  base + TEGRA186_GPIO_OUTPUT_CONTROL);
-		writel(regs->conf, base + TEGRA186_GPIO_ENABLE_CONFIG);
-	}
-
-	return 0;
+  struct tegra_gpio *gpio = dev_get_drvdata(dev);
+  struct tegra_gpio_saved_register *regs;
+  unsigned offset = 0U;
+  int i;
+  void __iomem *base;
+  #if defined(GPIO_DEBUG_EXCEPTIONS)
+  void __iomem *base_r;  // base_r is the redirected value from host
+
+  if(kernel_is_on_guest && !is_debug_exception(GPIO_NOPT_TEST5)) {
+    base_r = tegra186_gpio_get_base_r(gpio, offset);
+    if (WARN_ON(base_r == NULL))
+      return -EINVAL;
+  }
+  #endif
+
+  base = tegra186_gpio_get_base(gpio, offset);
+  if (WARN_ON(base == NULL))
+    return -EINVAL;
+
+  for (i = 0; i < gpio->gpio.ngpio; i++) {
+    regs = &gpio->gpio_rval[i];
+    if (!regs->restore_needed)
+      continue;
+
+    regs->restore_needed = false;
+
+		#if defined(GPIO_DEBUG_EXCEPTIONS)
+    /* this passthrough should work becasue we have 'base_r'*/
+    if(kernel_is_on_guest && !is_debug_exception(GPIO_NOPT_TEST5) ) {
+      writel_x(regs->val,  base_r + TEGRA186_GPIO_OUTPUT_VALUE);
+      writel_x(regs->out,  base_r + TEGRA186_GPIO_OUTPUT_CONTROL);
+      writel_x(regs->conf, base_r + TEGRA186_GPIO_ENABLE_CONFIG);
+    }
+    else {
+		#endif
+      writel(regs->val,  base + TEGRA186_GPIO_OUTPUT_VALUE);
+      writel(regs->out,  base + TEGRA186_GPIO_OUTPUT_CONTROL);
+      writel(regs->conf, base + TEGRA186_GPIO_ENABLE_CONFIG);
+		#if defined(GPIO_DEBUG_EXCEPTIONS)
+    }
+		#endif
+  }
+
+  return 0;
 }
 
 static int tegra_gpio_suspend_late(struct device *dev)
 {
-	struct tegra_gpio *gpio = dev_get_drvdata(dev);
+  struct tegra_gpio *gpio = dev_get_drvdata(dev);
 
-	return of_gpiochip_suspend(&gpio->gpio);
+  return of_gpiochip_suspend(&gpio->gpio);
 }
 
 static const struct dev_pm_ops tegra_gpio_pm = {
-	.suspend_late = tegra_gpio_suspend_late,
-	.resume_early = tegra_gpio_resume_early,
+  .suspend_late = tegra_gpio_suspend_late,
+  .resume_early = tegra_gpio_resume_early,
 };
-#define TEGRA_GPIO_PM		&tegra_gpio_pm
+#define TEGRA_GPIO_PM   &tegra_gpio_pm
 #else
-#define TEGRA_GPIO_PM		NULL
+#define TEGRA_GPIO_PM   NULL
 #endif
 
 static int tegra186_gpio_remove(struct platform_device *pdev)
 {
-	return 0;
+	#if defined(CONFIG_TEGRA_GPIO_GUEST_PROXY) || defined(CONFIG_TEGRA_GPIO_HOST_PROXY)
+  if(kernel_is_on_guest) {
+    tegra_gpio_guest_cleanup();
+  }
+  else {
+    tegra_gpio_host_cleanup();
+  }
+	#endif
+  return 0;
 }
 
-#define TEGRA186_MAIN_GPIO_PORT(_name, _bank, _port, _pins)	\
-	[TEGRA186_MAIN_GPIO_PORT_##_name] = {			\
-		.name = #_name,					\
-		.bank = _bank,					\
-		.port = _port,					\
-		.pins = _pins,					\
-	}
+
+#define TEGRA186_MAIN_GPIO_PORT(_name, _bank, _port, _pins) \
+  [TEGRA186_MAIN_GPIO_PORT_##_name] = {     \
+    .name = #_name,         \
+    .bank = _bank,          \
+    .port = _port,          \
+    .pins = _pins,          \
+  }
 
 static const struct tegra_gpio_port tegra186_main_ports[] = {
-	TEGRA186_MAIN_GPIO_PORT( A, 2, 0, 7),
-	TEGRA186_MAIN_GPIO_PORT( B, 3, 0, 7),
-	TEGRA186_MAIN_GPIO_PORT( C, 3, 1, 7),
-	TEGRA186_MAIN_GPIO_PORT( D, 3, 2, 6),
-	TEGRA186_MAIN_GPIO_PORT( E, 2, 1, 8),
-	TEGRA186_MAIN_GPIO_PORT( F, 2, 2, 6),
-	TEGRA186_MAIN_GPIO_PORT( G, 4, 1, 6),
-	TEGRA186_MAIN_GPIO_PORT( H, 1, 0, 7),
-	TEGRA186_MAIN_GPIO_PORT( I, 0, 4, 8),
-	TEGRA186_MAIN_GPIO_PORT( J, 5, 0, 8),
-	TEGRA186_MAIN_GPIO_PORT( K, 5, 1, 1),
-	TEGRA186_MAIN_GPIO_PORT( L, 1, 1, 8),
-	TEGRA186_MAIN_GPIO_PORT( M, 5, 3, 6),
-	TEGRA186_MAIN_GPIO_PORT( N, 0, 0, 7),
-	TEGRA186_MAIN_GPIO_PORT( O, 0, 1, 4),
-	TEGRA186_MAIN_GPIO_PORT( P, 4, 0, 7),
-	TEGRA186_MAIN_GPIO_PORT( Q, 0, 2, 6),
-	TEGRA186_MAIN_GPIO_PORT( R, 0, 5, 6),
-	TEGRA186_MAIN_GPIO_PORT( T, 0, 3, 4),
-	TEGRA186_MAIN_GPIO_PORT( X, 1, 2, 8),
-	TEGRA186_MAIN_GPIO_PORT( Y, 1, 3, 7),
-	TEGRA186_MAIN_GPIO_PORT(BB, 2, 3, 2),
-	TEGRA186_MAIN_GPIO_PORT(CC, 5, 2, 4),
+  TEGRA186_MAIN_GPIO_PORT( A, 2, 0, 7),
+  TEGRA186_MAIN_GPIO_PORT( B, 3, 0, 7),
+  TEGRA186_MAIN_GPIO_PORT( C, 3, 1, 7),
+  TEGRA186_MAIN_GPIO_PORT( D, 3, 2, 6),
+  TEGRA186_MAIN_GPIO_PORT( E, 2, 1, 8),
+  TEGRA186_MAIN_GPIO_PORT( F, 2, 2, 6),
+  TEGRA186_MAIN_GPIO_PORT( G, 4, 1, 6),
+  TEGRA186_MAIN_GPIO_PORT( H, 1, 0, 7),
+  TEGRA186_MAIN_GPIO_PORT( I, 0, 4, 8),
+  TEGRA186_MAIN_GPIO_PORT( J, 5, 0, 8),
+  TEGRA186_MAIN_GPIO_PORT( K, 5, 1, 1),
+  TEGRA186_MAIN_GPIO_PORT( L, 1, 1, 8),
+  TEGRA186_MAIN_GPIO_PORT( M, 5, 3, 6),
+  TEGRA186_MAIN_GPIO_PORT( N, 0, 0, 7),
+  TEGRA186_MAIN_GPIO_PORT( O, 0, 1, 4),
+  TEGRA186_MAIN_GPIO_PORT( P, 4, 0, 7),
+  TEGRA186_MAIN_GPIO_PORT( Q, 0, 2, 6),
+  TEGRA186_MAIN_GPIO_PORT( R, 0, 5, 6),
+  TEGRA186_MAIN_GPIO_PORT( T, 0, 3, 4),
+  TEGRA186_MAIN_GPIO_PORT( X, 1, 2, 8),
+  TEGRA186_MAIN_GPIO_PORT( Y, 1, 3, 7),
+  TEGRA186_MAIN_GPIO_PORT(BB, 2, 3, 2),
+  TEGRA186_MAIN_GPIO_PORT(CC, 5, 2, 4),
 };
 
 static const struct tegra_gpio_soc tegra186_main_soc = {
-	.num_ports = ARRAY_SIZE(tegra186_main_ports),
-	.ports = tegra186_main_ports,
-	.name = "tegra186-gpio",
-	.instance = 0,
-	.num_irqs_per_bank = 1,
+  .num_ports = ARRAY_SIZE(tegra186_main_ports),
+  .ports = tegra186_main_ports,
+  .name = "tegra186-gpio",
+  .instance = 0,
+  .num_irqs_per_bank = 1,
 };
 
-#define TEGRA186_AON_GPIO_PORT(_name, _bank, _port, _pins)	\
-	[TEGRA186_AON_GPIO_PORT_##_name] = {			\
-		.name = #_name,					\
-		.bank = _bank,					\
-		.port = _port,					\
-		.pins = _pins,					\
-	}
+#define TEGRA186_AON_GPIO_PORT(_name, _bank, _port, _pins)  \
+  [TEGRA186_AON_GPIO_PORT_##_name] = {      \
+    .name = #_name,         \
+    .bank = _bank,          \
+    .port = _port,          \
+    .pins = _pins,          \
+  }
 
 static const struct tegra_gpio_port tegra186_aon_ports[] = {
-	TEGRA186_AON_GPIO_PORT( S, 0, 1, 5),
-	TEGRA186_AON_GPIO_PORT( U, 0, 2, 6),
-	TEGRA186_AON_GPIO_PORT( V, 0, 4, 8),
-	TEGRA186_AON_GPIO_PORT( W, 0, 5, 8),
-	TEGRA186_AON_GPIO_PORT( Z, 0, 7, 4),
-	TEGRA186_AON_GPIO_PORT(AA, 0, 6, 8),
-	TEGRA186_AON_GPIO_PORT(EE, 0, 3, 3),
-	TEGRA186_AON_GPIO_PORT(FF, 0, 0, 5),
+  TEGRA186_AON_GPIO_PORT( S, 0, 1, 5),
+  TEGRA186_AON_GPIO_PORT( U, 0, 2, 6),
+  TEGRA186_AON_GPIO_PORT( V, 0, 4, 8),
+  TEGRA186_AON_GPIO_PORT( W, 0, 5, 8),
+  TEGRA186_AON_GPIO_PORT( Z, 0, 7, 4),
+  TEGRA186_AON_GPIO_PORT(AA, 0, 6, 8),
+  TEGRA186_AON_GPIO_PORT(EE, 0, 3, 3),
+  TEGRA186_AON_GPIO_PORT(FF, 0, 0, 5),
 };
 
 static const struct tegra_gpio_soc tegra186_aon_soc = {
-	.num_ports = ARRAY_SIZE(tegra186_aon_ports),
-	.ports = tegra186_aon_ports,
-	.name = "tegra186-gpio-aon",
-	.instance = 1,
-	.num_irqs_per_bank = 1,
+  .num_ports = ARRAY_SIZE(tegra186_aon_ports),
+  .ports = tegra186_aon_ports,
+  .name = "tegra186-gpio-aon",
+  .instance = 1,
+  .num_irqs_per_bank = 1,
 };
 
-#define TEGRA194_MAIN_GPIO_PORT(_name, _bank, _port, _pins)	\
-	[TEGRA194_MAIN_GPIO_PORT_##_name] = {			\
-		.name = #_name,					\
-		.bank = _bank,					\
-		.port = _port,					\
-		.pins = _pins,					\
-	}
+#define TEGRA194_MAIN_GPIO_PORT(_name, _bank, _port, _pins) \
+  [TEGRA194_MAIN_GPIO_PORT_##_name] = {     \
+    .name = #_name,         \
+    .bank = _bank,          \
+    .port = _port,          \
+    .pins = _pins,          \
+  }
 
 static const struct tegra_gpio_port tegra194_main_ports[] = {
-	TEGRA194_MAIN_GPIO_PORT( A, 1, 2, 8),
-	TEGRA194_MAIN_GPIO_PORT( B, 4, 7, 2),
-	TEGRA194_MAIN_GPIO_PORT( C, 4, 3, 8),
-	TEGRA194_MAIN_GPIO_PORT( D, 4, 4, 4),
-	TEGRA194_MAIN_GPIO_PORT( E, 4, 5, 8),
-	TEGRA194_MAIN_GPIO_PORT( F, 4, 6, 6),
-	TEGRA194_MAIN_GPIO_PORT( G, 4, 0, 8),
-	TEGRA194_MAIN_GPIO_PORT( H, 4, 1, 8),
-	TEGRA194_MAIN_GPIO_PORT( I, 4, 2, 5),
-	TEGRA194_MAIN_GPIO_PORT( J, 5, 1, 6),
-	TEGRA194_MAIN_GPIO_PORT( K, 3, 0, 8),
-	TEGRA194_MAIN_GPIO_PORT( L, 3, 1, 4),
-	TEGRA194_MAIN_GPIO_PORT( M, 2, 3, 8),
-	TEGRA194_MAIN_GPIO_PORT( N, 2, 4, 3),
-	TEGRA194_MAIN_GPIO_PORT( O, 5, 0, 6),
-	TEGRA194_MAIN_GPIO_PORT( P, 2, 5, 8),
-	TEGRA194_MAIN_GPIO_PORT( Q, 2, 6, 8),
-	TEGRA194_MAIN_GPIO_PORT( R, 2, 7, 6),
-	TEGRA194_MAIN_GPIO_PORT( S, 3, 3, 8),
-	TEGRA194_MAIN_GPIO_PORT( T, 3, 4, 8),
-	TEGRA194_MAIN_GPIO_PORT( U, 3, 5, 1),
-	TEGRA194_MAIN_GPIO_PORT( V, 1, 0, 8),
-	TEGRA194_MAIN_GPIO_PORT( W, 1, 1, 2),
-	TEGRA194_MAIN_GPIO_PORT( X, 2, 0, 8),
-	TEGRA194_MAIN_GPIO_PORT( Y, 2, 1, 8),
-	TEGRA194_MAIN_GPIO_PORT( Z, 2, 2, 8),
-	TEGRA194_MAIN_GPIO_PORT(FF, 3, 2, 2),
-	TEGRA194_MAIN_GPIO_PORT(GG, 0, 0, 2)
+  TEGRA194_MAIN_GPIO_PORT( A, 1, 2, 8),
+  TEGRA194_MAIN_GPIO_PORT( B, 4, 7, 2),
+  TEGRA194_MAIN_GPIO_PORT( C, 4, 3, 8),
+  TEGRA194_MAIN_GPIO_PORT( D, 4, 4, 4),
+  TEGRA194_MAIN_GPIO_PORT( E, 4, 5, 8),
+  TEGRA194_MAIN_GPIO_PORT( F, 4, 6, 6),
+  TEGRA194_MAIN_GPIO_PORT( G, 4, 0, 8),
+  TEGRA194_MAIN_GPIO_PORT( H, 4, 1, 8),
+  TEGRA194_MAIN_GPIO_PORT( I, 4, 2, 5),
+  TEGRA194_MAIN_GPIO_PORT( J, 5, 1, 6),
+  TEGRA194_MAIN_GPIO_PORT( K, 3, 0, 8),
+  TEGRA194_MAIN_GPIO_PORT( L, 3, 1, 4),
+  TEGRA194_MAIN_GPIO_PORT( M, 2, 3, 8),
+  TEGRA194_MAIN_GPIO_PORT( N, 2, 4, 3),
+  TEGRA194_MAIN_GPIO_PORT( O, 5, 0, 6),
+  TEGRA194_MAIN_GPIO_PORT( P, 2, 5, 8),
+  TEGRA194_MAIN_GPIO_PORT( Q, 2, 6, 8),
+  TEGRA194_MAIN_GPIO_PORT( R, 2, 7, 6),
+  TEGRA194_MAIN_GPIO_PORT( S, 3, 3, 8),
+  TEGRA194_MAIN_GPIO_PORT( T, 3, 4, 8),
+  TEGRA194_MAIN_GPIO_PORT( U, 3, 5, 1),
+  TEGRA194_MAIN_GPIO_PORT( V, 1, 0, 8),
+  TEGRA194_MAIN_GPIO_PORT( W, 1, 1, 2),
+  TEGRA194_MAIN_GPIO_PORT( X, 2, 0, 8),
+  TEGRA194_MAIN_GPIO_PORT( Y, 2, 1, 8),
+  TEGRA194_MAIN_GPIO_PORT( Z, 2, 2, 8),
+  TEGRA194_MAIN_GPIO_PORT(FF, 3, 2, 2),
+  TEGRA194_MAIN_GPIO_PORT(GG, 0, 0, 2)
 };
 
 static const struct tegra_gpio_soc tegra194_main_soc = {
-	.num_ports = ARRAY_SIZE(tegra194_main_ports),
-	.ports = tegra194_main_ports,
-	.name = "tegra194-gpio",
-	.instance = 0,
-	.num_irqs_per_bank = 8,
-	.do_vm_check = true,
+  .num_ports = ARRAY_SIZE(tegra194_main_ports),
+  .ports = tegra194_main_ports,
+  .name = "tegra194-gpio",
+  .instance = 0,
+  .num_irqs_per_bank = 8,
+  .do_vm_check = true,
 };
 
-#define TEGRA194_AON_GPIO_PORT(_name, _bank, _port, _pins)	\
-	[TEGRA194_AON_GPIO_PORT_##_name] = {			\
-		.name = #_name,					\
-		.bank = _bank,					\
-		.port = _port,					\
-		.pins = _pins,					\
-	}
+#define TEGRA194_AON_GPIO_PORT(_name, _bank, _port, _pins)  \
+  [TEGRA194_AON_GPIO_PORT_##_name] = {      \
+    .name = #_name,         \
+    .bank = _bank,          \
+    .port = _port,          \
+    .pins = _pins,          \
+  }
 
 static const struct tegra_gpio_port tegra194_aon_ports[] = {
-	TEGRA194_AON_GPIO_PORT(AA, 0, 3, 8),
-	TEGRA194_AON_GPIO_PORT(BB, 0, 4, 4),
-	TEGRA194_AON_GPIO_PORT(CC, 0, 1, 8),
-	TEGRA194_AON_GPIO_PORT(DD, 0, 2, 3),
-	TEGRA194_AON_GPIO_PORT(EE, 0, 0, 7)
+  TEGRA194_AON_GPIO_PORT(AA, 0, 3, 8),
+  TEGRA194_AON_GPIO_PORT(BB, 0, 4, 4),
+  TEGRA194_AON_GPIO_PORT(CC, 0, 1, 8),
+  TEGRA194_AON_GPIO_PORT(DD, 0, 2, 3),
+  TEGRA194_AON_GPIO_PORT(EE, 0, 0, 7)
 };
 
 static const struct tegra_gpio_soc tegra194_aon_soc = {
-	.num_ports = ARRAY_SIZE(tegra194_aon_ports),
-	.ports = tegra194_aon_ports,
-	.name = "tegra194-gpio-aon",
-	.gte_info = tegra194_gte_info,
-	.gte_npins = ARRAY_SIZE(tegra194_gte_info),
-	.instance = 1,
-	.num_irqs_per_bank = 8,
-	.is_hw_ts_sup = true,
-	.do_vm_check = false,
+  .num_ports = ARRAY_SIZE(tegra194_aon_ports),
+  .ports = tegra194_aon_ports,
+  .name = "tegra194-gpio-aon",
+  .gte_info = tegra194_gte_info,
+  .gte_npins = ARRAY_SIZE(tegra194_gte_info),
+  .instance = 1,
+  .num_irqs_per_bank = 8,
+  .is_hw_ts_sup = true,
+  .do_vm_check = false,
 };
 
-#define TEGRA234_MAIN_GPIO_PORT(_name, _bank, _port, _pins)	\
-	[TEGRA234_MAIN_GPIO_PORT_##_name] = {			\
-		.name = #_name,					\
-		.bank = _bank,					\
-		.port = _port,					\
-		.pins = _pins,					\
-	}
+#define TEGRA234_MAIN_GPIO_PORT(_name, _bank, _port, _pins) \
+  [TEGRA234_MAIN_GPIO_PORT_##_name] = {     \
+    .name = #_name,         \
+    .bank = _bank,          \
+    .port = _port,          \
+    .pins = _pins,          \
+  }
 
 static const struct tegra_gpio_port tegra234_main_ports[] = {
-	TEGRA234_MAIN_GPIO_PORT(A, 0, 0, 8),
-	TEGRA234_MAIN_GPIO_PORT(B, 0, 3, 1),
-	TEGRA234_MAIN_GPIO_PORT(C, 5, 1, 8),
-	TEGRA234_MAIN_GPIO_PORT(D, 5, 2, 4),
-	TEGRA234_MAIN_GPIO_PORT(E, 5, 3, 8),
-	TEGRA234_MAIN_GPIO_PORT(F, 5, 4, 6),
-	TEGRA234_MAIN_GPIO_PORT(G, 4, 0, 8),
-	TEGRA234_MAIN_GPIO_PORT(H, 4, 1, 8),
-	TEGRA234_MAIN_GPIO_PORT(I, 4, 2, 7),
-	TEGRA234_MAIN_GPIO_PORT(J, 5, 0, 6),
-	TEGRA234_MAIN_GPIO_PORT(K, 3, 0, 8),
-	TEGRA234_MAIN_GPIO_PORT(L, 3, 1, 4),
-	TEGRA234_MAIN_GPIO_PORT(M, 2, 0, 8),
-	TEGRA234_MAIN_GPIO_PORT(N, 2, 1, 8),
-	TEGRA234_MAIN_GPIO_PORT(P, 2, 2, 8),
-	TEGRA234_MAIN_GPIO_PORT(Q, 2, 3, 8),
-	TEGRA234_MAIN_GPIO_PORT(R, 2, 4, 6),
-	TEGRA234_MAIN_GPIO_PORT(X, 1, 0, 8),
-	TEGRA234_MAIN_GPIO_PORT(Y, 1, 1, 8),
-	TEGRA234_MAIN_GPIO_PORT(Z, 1, 2, 8),
-	TEGRA234_MAIN_GPIO_PORT(AC, 0, 1, 8),
-	TEGRA234_MAIN_GPIO_PORT(AD, 0, 2, 4),
-	TEGRA234_MAIN_GPIO_PORT(AE, 3, 3, 2),
-	TEGRA234_MAIN_GPIO_PORT(AF, 3, 4, 4),
-	TEGRA234_MAIN_GPIO_PORT(AG, 3, 2, 8)
+  TEGRA234_MAIN_GPIO_PORT(A, 0, 0, 8),
+  TEGRA234_MAIN_GPIO_PORT(B, 0, 3, 1),
+  TEGRA234_MAIN_GPIO_PORT(C, 5, 1, 8),
+  TEGRA234_MAIN_GPIO_PORT(D, 5, 2, 4),
+  TEGRA234_MAIN_GPIO_PORT(E, 5, 3, 8),
+  TEGRA234_MAIN_GPIO_PORT(F, 5, 4, 6),
+  TEGRA234_MAIN_GPIO_PORT(G, 4, 0, 8),
+  TEGRA234_MAIN_GPIO_PORT(H, 4, 1, 8),
+  TEGRA234_MAIN_GPIO_PORT(I, 4, 2, 7),
+  TEGRA234_MAIN_GPIO_PORT(J, 5, 0, 6),
+  TEGRA234_MAIN_GPIO_PORT(K, 3, 0, 8),
+  TEGRA234_MAIN_GPIO_PORT(L, 3, 1, 4),
+  TEGRA234_MAIN_GPIO_PORT(M, 2, 0, 8),
+  TEGRA234_MAIN_GPIO_PORT(N, 2, 1, 8),
+  TEGRA234_MAIN_GPIO_PORT(P, 2, 2, 8),
+  TEGRA234_MAIN_GPIO_PORT(Q, 2, 3, 8),
+  TEGRA234_MAIN_GPIO_PORT(R, 2, 4, 6),
+  TEGRA234_MAIN_GPIO_PORT(X, 1, 0, 8),
+  TEGRA234_MAIN_GPIO_PORT(Y, 1, 1, 8),
+  TEGRA234_MAIN_GPIO_PORT(Z, 1, 2, 8),
+  TEGRA234_MAIN_GPIO_PORT(AC, 0, 1, 8),
+  TEGRA234_MAIN_GPIO_PORT(AD, 0, 2, 4),
+  TEGRA234_MAIN_GPIO_PORT(AE, 3, 3, 2),
+  TEGRA234_MAIN_GPIO_PORT(AF, 3, 4, 4),
+  TEGRA234_MAIN_GPIO_PORT(AG, 3, 2, 8)
 };
 
 static const struct tegra_gpio_soc tegra234_main_soc = {
-	.num_ports = ARRAY_SIZE(tegra234_main_ports),
-	.ports = tegra234_main_ports,
-	.name = "tegra234-gpio",
-	.instance = 0,
-	.num_irqs_per_bank = 8,
-	.do_vm_check = true,
+  .num_ports = ARRAY_SIZE(tegra234_main_ports),
+  .ports = tegra234_main_ports,
+  .name = "tegra234-gpio",
+  .instance = 0,
+  .num_irqs_per_bank = 8,
+  .do_vm_check = true,
 };
 
-#define TEGRA234_AON_GPIO_PORT(_name, _bank, _port, _pins)	\
-	[TEGRA234_AON_GPIO_PORT_##_name] = {			\
-		.name = #_name,					\
-		.bank = _bank,					\
-		.port = _port,					\
-		.pins = _pins,					\
-	}
+#define TEGRA234_AON_GPIO_PORT(_name, _bank, _port, _pins)  \
+  [TEGRA234_AON_GPIO_PORT_##_name] = {      \
+    .name = #_name,         \
+    .bank = _bank,          \
+    .port = _port,          \
+    .pins = _pins,          \
+  }
 
 static const struct tegra_gpio_port tegra234_aon_ports[] = {
-	TEGRA234_AON_GPIO_PORT(AA, 0, 4, 8),
-	TEGRA234_AON_GPIO_PORT(BB, 0, 5, 4),
-	TEGRA234_AON_GPIO_PORT(CC, 0, 2, 8),
-	TEGRA234_AON_GPIO_PORT(DD, 0, 3, 3),
-	TEGRA234_AON_GPIO_PORT(EE, 0, 0, 8),
-	TEGRA234_AON_GPIO_PORT(GG, 0, 1, 1)
+  TEGRA234_AON_GPIO_PORT(AA, 0, 4, 8),
+  TEGRA234_AON_GPIO_PORT(BB, 0, 5, 4),
+  TEGRA234_AON_GPIO_PORT(CC, 0, 2, 8),
+  TEGRA234_AON_GPIO_PORT(DD, 0, 3, 3),
+  TEGRA234_AON_GPIO_PORT(EE, 0, 0, 8),
+  TEGRA234_AON_GPIO_PORT(GG, 0, 1, 1)
 };
 
 static const struct tegra_gpio_soc tegra234_aon_soc = {
-	.num_ports = ARRAY_SIZE(tegra234_aon_ports),
-	.ports = tegra234_aon_ports,
-	.name = "tegra234-gpio-aon",
-	.instance = 1,
-	.num_irqs_per_bank = 8,
-	.is_hw_ts_sup = true,
-	.do_vm_check = false,
+  .num_ports = ARRAY_SIZE(tegra234_aon_ports),
+  .ports = tegra234_aon_ports,
+  .name = "tegra234-gpio-aon",
+  .instance = 1,
+  .num_irqs_per_bank = 8,
+  .is_hw_ts_sup = true,
+  .do_vm_check = false,
 };
 
-#define TEGRA239_MAIN_GPIO_PORT(_name, _bank, _port, _pins)	\
-	[TEGRA239_MAIN_GPIO_PORT_##_name] = {			\
-		.name = #_name,					\
-		.bank = _bank,					\
-		.port = _port,					\
-		.pins = _pins,					\
-	}
+#define TEGRA239_MAIN_GPIO_PORT(_name, _bank, _port, _pins) \
+  [TEGRA239_MAIN_GPIO_PORT_##_name] = {     \
+    .name = #_name,         \
+    .bank = _bank,          \
+    .port = _port,          \
+    .pins = _pins,          \
+  }
 
 static const struct tegra_gpio_port tegra239_main_ports[] = {
-	TEGRA239_MAIN_GPIO_PORT(A, 0, 0, 8),
-	TEGRA239_MAIN_GPIO_PORT(B, 0, 1, 5),
-	TEGRA239_MAIN_GPIO_PORT(C, 0, 2, 8),
-	TEGRA239_MAIN_GPIO_PORT(D, 0, 3, 8),
-	TEGRA239_MAIN_GPIO_PORT(E, 0, 4, 4),
-	TEGRA239_MAIN_GPIO_PORT(F, 0, 5, 8),
-	TEGRA239_MAIN_GPIO_PORT(G, 0, 6, 8),
-	TEGRA239_MAIN_GPIO_PORT(H, 0, 7, 6),
-	TEGRA239_MAIN_GPIO_PORT(J, 1, 0, 8),
-	TEGRA239_MAIN_GPIO_PORT(K, 1, 1, 4),
-	TEGRA239_MAIN_GPIO_PORT(L, 1, 2, 8),
-	TEGRA239_MAIN_GPIO_PORT(M, 1, 3, 8),
-	TEGRA239_MAIN_GPIO_PORT(N, 1, 4, 3),
-	TEGRA239_MAIN_GPIO_PORT(P, 1, 5, 8),
-	TEGRA239_MAIN_GPIO_PORT(Q, 1, 6, 3),
-	TEGRA239_MAIN_GPIO_PORT(R, 2, 0, 8),
-	TEGRA239_MAIN_GPIO_PORT(S, 2, 1, 8),
-	TEGRA239_MAIN_GPIO_PORT(T, 2, 2, 8),
-	TEGRA239_MAIN_GPIO_PORT(U, 2, 3, 6),
-	TEGRA239_MAIN_GPIO_PORT(V, 2, 4, 2),
-	TEGRA239_MAIN_GPIO_PORT(W, 3, 0, 8),
-	TEGRA239_MAIN_GPIO_PORT(X, 3, 1, 2)
+  TEGRA239_MAIN_GPIO_PORT(A, 0, 0, 8),
+  TEGRA239_MAIN_GPIO_PORT(B, 0, 1, 5),
+  TEGRA239_MAIN_GPIO_PORT(C, 0, 2, 8),
+  TEGRA239_MAIN_GPIO_PORT(D, 0, 3, 8),
+  TEGRA239_MAIN_GPIO_PORT(E, 0, 4, 4),
+  TEGRA239_MAIN_GPIO_PORT(F, 0, 5, 8),
+  TEGRA239_MAIN_GPIO_PORT(G, 0, 6, 8),
+  TEGRA239_MAIN_GPIO_PORT(H, 0, 7, 6),
+  TEGRA239_MAIN_GPIO_PORT(J, 1, 0, 8),
+  TEGRA239_MAIN_GPIO_PORT(K, 1, 1, 4),
+  TEGRA239_MAIN_GPIO_PORT(L, 1, 2, 8),
+  TEGRA239_MAIN_GPIO_PORT(M, 1, 3, 8),
+  TEGRA239_MAIN_GPIO_PORT(N, 1, 4, 3),
+  TEGRA239_MAIN_GPIO_PORT(P, 1, 5, 8),
+  TEGRA239_MAIN_GPIO_PORT(Q, 1, 6, 3),
+  TEGRA239_MAIN_GPIO_PORT(R, 2, 0, 8),
+  TEGRA239_MAIN_GPIO_PORT(S, 2, 1, 8),
+  TEGRA239_MAIN_GPIO_PORT(T, 2, 2, 8),
+  TEGRA239_MAIN_GPIO_PORT(U, 2, 3, 6),
+  TEGRA239_MAIN_GPIO_PORT(V, 2, 4, 2),
+  TEGRA239_MAIN_GPIO_PORT(W, 3, 0, 8),
+  TEGRA239_MAIN_GPIO_PORT(X, 3, 1, 2)
 };
 
 static const struct tegra_gpio_soc tegra239_main_soc = {
-	.num_ports = ARRAY_SIZE(tegra239_main_ports),
-	.ports = tegra239_main_ports,
-	.name = "tegra239-gpio",
-	.instance = 0,
-	.num_irqs_per_bank = 8,
-	.do_vm_check = true,
+  .num_ports = ARRAY_SIZE(tegra239_main_ports),
+  .ports = tegra239_main_ports,
+  .name = "tegra239-gpio",
+  .instance = 0,
+  .num_irqs_per_bank = 8,
+  .do_vm_check = true,
 };
 
-#define TEGRA239_AON_GPIO_PORT(_name, _bank, _port, _pins)	\
-	[TEGRA239_AON_GPIO_PORT_##_name] = {			\
-		.name = #_name,					\
-		.bank = _bank,					\
-		.port = _port,					\
-		.pins = _pins,					\
-	}
+#define TEGRA239_AON_GPIO_PORT(_name, _bank, _port, _pins)  \
+  [TEGRA239_AON_GPIO_PORT_##_name] = {      \
+    .name = #_name,         \
+    .bank = _bank,          \
+    .port = _port,          \
+    .pins = _pins,          \
+  }
 
 static const struct tegra_gpio_port tegra239_aon_ports[] = {
-	TEGRA239_AON_GPIO_PORT(AA, 0, 0, 8),
-	TEGRA239_AON_GPIO_PORT(BB, 0, 1, 1),
-	TEGRA239_AON_GPIO_PORT(CC, 0, 2, 8),
-	TEGRA239_AON_GPIO_PORT(DD, 0, 3, 8),
-	TEGRA239_AON_GPIO_PORT(EE, 0, 4, 6),
-	TEGRA239_AON_GPIO_PORT(FF, 0, 5, 8),
-	TEGRA239_AON_GPIO_PORT(GG, 0, 6, 8),
-	TEGRA239_AON_GPIO_PORT(HH, 0, 7, 4)
+  TEGRA239_AON_GPIO_PORT(AA, 0, 0, 8),
+  TEGRA239_AON_GPIO_PORT(BB, 0, 1, 1),
+  TEGRA239_AON_GPIO_PORT(CC, 0, 2, 8),
+  TEGRA239_AON_GPIO_PORT(DD, 0, 3, 8),
+  TEGRA239_AON_GPIO_PORT(EE, 0, 4, 6),
+  TEGRA239_AON_GPIO_PORT(FF, 0, 5, 8),
+  TEGRA239_AON_GPIO_PORT(GG, 0, 6, 8),
+  TEGRA239_AON_GPIO_PORT(HH, 0, 7, 4)
 };
 
 static const struct tegra_gpio_soc tegra239_aon_soc = {
-	.num_ports = ARRAY_SIZE(tegra239_aon_ports),
-	.ports = tegra239_aon_ports,
-	.name = "tegra239-gpio-aon",
-	.instance = 1,
-	.num_irqs_per_bank = 8,
-	.is_hw_ts_sup = true,
-	.do_vm_check = false,
+  .num_ports = ARRAY_SIZE(tegra239_aon_ports),
+  .ports = tegra239_aon_ports,
+  .name = "tegra239-gpio-aon",
+  .instance = 1,
+  .num_irqs_per_bank = 8,
+  .is_hw_ts_sup = true,
+  .do_vm_check = false,
 };
 
 static const struct of_device_id tegra186_gpio_of_match[] = {
-	{
-		.compatible = "nvidia,tegra186-gpio",
-		.data = &tegra186_main_soc
-	}, {
-		.compatible = "nvidia,tegra186-gpio-aon",
-		.data = &tegra186_aon_soc
-	}, {
-		.compatible = "nvidia,tegra194-gpio",
-		.data = &tegra194_main_soc
-	}, {
-		.compatible = "nvidia,tegra194-gpio-aon",
-		.data = &tegra194_aon_soc
-	}, {
-		.compatible = "nvidia,tegra234-gpio",
-		.data = &tegra234_main_soc
-	}, {
-		.compatible = "nvidia,tegra234-gpio-aon",
-		.data = &tegra234_aon_soc
-	}, {
-		.compatible = "nvidia,tegra239-gpio",
-		.data = &tegra239_main_soc
-	}, {
-		.compatible = "nvidia,tegra239-gpio-aon",
-		.data = &tegra239_aon_soc
-	}, {
-		/* sentinel */
-	}
+  {
+    .compatible = "nvidia,tegra186-gpio",
+    .data = &tegra186_main_soc
+  }, {
+    .compatible = "nvidia,tegra186-gpio-aon",
+    .data = &tegra186_aon_soc
+  }, {
+    .compatible = "nvidia,tegra194-gpio",
+    .data = &tegra194_main_soc
+  }, {
+    .compatible = "nvidia,tegra194-gpio-aon",
+    .data = &tegra194_aon_soc
+  }, {
+    .compatible = "nvidia,tegra234-gpio",
+    .data = &tegra234_main_soc
+  }, {
+    .compatible = "nvidia,tegra234-gpio-aon",
+    .data = &tegra234_aon_soc
+  }, {
+    .compatible = "nvidia,tegra239-gpio",
+    .data = &tegra239_main_soc
+  }, {
+    .compatible = "nvidia,tegra239-gpio-aon",
+    .data = &tegra239_aon_soc
+  }, {
+    /* sentinel */
+  }
 };
 MODULE_DEVICE_TABLE(of, tegra186_gpio_of_match);
 
 static struct platform_driver tegra186_gpio_driver = {
-	.driver = {
-		.name = "tegra186-gpio",
-		.of_match_table = tegra186_gpio_of_match,
-		.pm = TEGRA_GPIO_PM,
-	},
-	.probe = tegra186_gpio_probe,
-	.remove = tegra186_gpio_remove,
+  .driver = {
+    .name = "tegra186-gpio",
+    .of_match_table = tegra186_gpio_of_match,
+    .pm = TEGRA_GPIO_PM,
+  },
+  .probe = tegra186_gpio_probe,
+  .remove = tegra186_gpio_remove,
 };
-module_platform_driver(tegra186_gpio_driver);
+
+// module_platform_driver(tegra186_gpio_driver);
+builtin_platform_driver(tegra186_gpio_driver);
 
 MODULE_DESCRIPTION("NVIDIA Tegra186 GPIO controller driver");
 MODULE_AUTHOR("Thierry Reding <treding@nvidia.com>");
diff --git a/drivers/gpio/gpiolib-cdev.c b/drivers/gpio/gpiolib-cdev.c
index 2613881a66e6..8f7a911c24ab 100644
--- a/drivers/gpio/gpiolib-cdev.c
+++ b/drivers/gpio/gpiolib-cdev.c
@@ -83,6 +83,31 @@ struct linehandle_state {
 	GPIOHANDLE_REQUEST_OPEN_DRAIN | \
 	GPIOHANDLE_REQUEST_OPEN_SOURCE)
 
+// define Debug  
+// #define GPIO_DEBUG
+// #define GPIO_DEBUG_VERBOSE
+
+#ifdef GPIO_DEBUG
+  /*
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+  #define deb_error(fmt, ...)    printk(KERN_ERR "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__ , kbasename(__FILE__), ##__VA_ARGS__)
+  */
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' -- " fmt, __func__, ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' -- " fmt, __func__, ##__VA_ARGS__)
+  #define deb_error(fmt, ...)    printk(KERN_ERR "GPIO func \'%s\' -- " fmt, __func__ , ##__VA_ARGS__)
+#else
+  #define deb_info(fmt, ...)
+  #define deb_debug(fmt, ...)
+  #define deb_error(fmt, ...)
+#endif
+
+#ifdef GPIO_DEBUG_VERBOSE
+  #define deb_verbose           deb_debug
+#else
+  #define deb_verbose(fmt, ...)
+#endif
+
 static int linehandle_validate_flags(u32 flags)
 {
 	/* Return an error if an unknown flag is set */
@@ -155,6 +180,8 @@ static long linehandle_set_config(struct linehandle_state *lh,
 	int i, ret;
 	u32 lflags;
 
+	deb_debug("\n");
+
 	if (copy_from_user(&gcnf, ip, sizeof(gcnf)))
 		return -EFAULT;
 
@@ -199,6 +226,8 @@ static long linehandle_ioctl(struct file *file, unsigned int cmd,
 	DECLARE_BITMAP(vals, GPIOHANDLES_MAX);
 	int i;
 
+	deb_debug("cmd=0x%x, user_pointer=0x%p\n", cmd, ip);
+
 	if (cmd == GPIOHANDLE_GET_LINE_VALUES_IOCTL) {
 		/* NOTE: It's ok to read values of output lines. */
 		int ret = gpiod_get_array_value_complex(false,
@@ -268,6 +297,8 @@ static void linehandle_free(struct linehandle_state *lh)
 
 static int linehandle_release(struct inode *inode, struct file *file)
 {
+	deb_debug("\n");
+
 	linehandle_free(file->private_data);
 	return 0;
 }
@@ -290,6 +321,8 @@ static int linehandle_create(struct gpio_device *gdev, void __user *ip)
 	int fd, i, ret;
 	u32 lflags;
 
+	deb_debug("\n");
+
 	if (copy_from_user(&handlereq, ip, sizeof(handlereq)))
 		return -EFAULT;
 	if ((handlereq.lines == 0) || (handlereq.lines > GPIOHANDLES_MAX))
@@ -801,6 +834,11 @@ static int edge_detector_setup(struct line *line,
 			IRQF_TRIGGER_RISING : IRQF_TRIGGER_FALLING;
 	irqflags |= IRQF_ONESHOT;
 
+  #ifdef GPIO_DEBUG_VERBOSE
+  deb_verbose("request_threaded_irq() parameters: %x, %lx, %s, %p\n",irq, irqflags, line->req->label, line);
+  // dump_stack();
+  #endif
+
 	/* Request a thread to read the events */
 	ret = request_threaded_irq(irq, edge_irq_handler, edge_irq_thread,
 				   irqflags, line->req->label, line);
@@ -1040,6 +1078,8 @@ static long linereq_set_values_unlocked(struct linereq *lr,
 	unsigned int i, didx, num_set;
 	int ret;
 
+	deb_debug("\n");
+
 	bitmap_zero(vals, GPIO_V2_LINES_MAX);
 	for (num_set = 0, i = 0; i < lr->num_lines; i++) {
 		if (lv->mask & BIT_ULL(i)) {
@@ -1079,6 +1119,8 @@ static long linereq_set_values(struct linereq *lr, void __user *ip)
 	struct gpio_v2_line_values lv;
 	int ret;
 
+	deb_debug("\n");
+
 	if (copy_from_user(&lv, ip, sizeof(lv)))
 		return -EFAULT;
 
@@ -1165,6 +1207,8 @@ static long linereq_ioctl(struct file *file, unsigned int cmd,
 	struct linereq *lr = file->private_data;
 	void __user *ip = (void __user *)arg;
 
+	deb_debug("\n");
+
 	if (cmd == GPIO_V2_LINE_GET_VALUES_IOCTL)
 		return linereq_get_values(lr, ip);
 	else if (cmd == GPIO_V2_LINE_SET_VALUES_IOCTL)
@@ -1297,6 +1341,8 @@ static int linereq_create(struct gpio_device *gdev, void __user *ip)
 	unsigned int i;
 	int fd, ret;
 
+	deb_debug("\n");
+
 	if (copy_from_user(&ulr, ip, sizeof(ulr)))
 		return -EFAULT;
 
@@ -1702,6 +1748,8 @@ static int lineevent_create(struct gpio_device *gdev, void __user *ip)
 	int ret;
 	int irq, irqflags = 0;
 
+	deb_debug("\n");
+
 	if (copy_from_user(&eventreq, ip, sizeof(eventreq)))
 		return -EFAULT;
 
@@ -1738,6 +1786,8 @@ static int lineevent_create(struct gpio_device *gdev, void __user *ip)
 	le->gdev = gdev;
 	get_device(&gdev->dev);
 
+	deb_verbose("id=%d, chip=%s, chip=%s", gdev->id, gdev->label, gdev->chip->label);
+
 	if (eventreq.consumer_label[0] != '\0') {
 		/* label is only initialized if consumer_label is set */
 		le->label = kstrndup(eventreq.consumer_label,
@@ -1750,16 +1800,20 @@ static int lineevent_create(struct gpio_device *gdev, void __user *ip)
 	}
 
 	ret = gpiod_request(desc, le->label);
-	if (ret)
+	if (ret) {
+		deb_verbose("fail at line %d", __LINE__);
 		goto out_free_le;
+	}
 	le->desc = desc;
 	le->eflags = eflags;
 
 	linehandle_flags_to_desc_flags(lflags, &desc->flags);
 
 	ret = gpiod_direction_input(desc);
-	if (ret)
+	if (ret) {
+		deb_verbose("fail at line %d", __LINE__);
 		goto out_free_le;
+	}
 
 	blocking_notifier_call_chain(&desc->gdev->notifier,
 				     GPIO_V2_LINE_CHANGED_REQUESTED, desc);
@@ -1767,6 +1821,7 @@ static int lineevent_create(struct gpio_device *gdev, void __user *ip)
 	irq = gpiod_to_irq(desc);
 	if (irq <= 0) {
 		ret = -ENODEV;
+		deb_verbose("fail at line %d", __LINE__);
 		goto out_free_le;
 	}
 	le->irq = irq;
@@ -1782,6 +1837,11 @@ static int lineevent_create(struct gpio_device *gdev, void __user *ip)
 	INIT_KFIFO(le->events);
 	init_waitqueue_head(&le->wait);
 
+  #ifdef GPIO_DEBUG_VERBOSE
+  deb_verbose("request_threaded_irq() parameters: %x, %x, %s, %p\n",le->irq, irqflags, le->label, le);
+  // dump_stack();
+  #endif
+
 	/* Request a thread to read the events */
 	ret = request_threaded_irq(le->irq,
 				   lineevent_irq_handler,
@@ -1789,12 +1849,15 @@ static int lineevent_create(struct gpio_device *gdev, void __user *ip)
 				   irqflags,
 				   le->label,
 				   le);
-	if (ret)
+	if (ret) {
+		deb_verbose("fail at line %d", __LINE__);
 		goto out_free_le;
+	}
 
 	fd = get_unused_fd_flags(O_RDONLY | O_CLOEXEC);
 	if (fd < 0) {
 		ret = fd;
+		deb_verbose("fail at line %d", __LINE__);
 		goto out_free_le;
 	}
 
@@ -1870,7 +1933,6 @@ static void gpio_v2_line_info_changed_to_v1(
 	lic_v1->timestamp = lic_v2->timestamp_ns;
 	lic_v1->event_type = lic_v2->event_type;
 }
-
 #endif /* CONFIG_GPIO_CDEV_V1 */
 
 static void gpio_desc_to_lineinfo(struct gpio_desc *desc,
@@ -1967,6 +2029,8 @@ static int chipinfo_get(struct gpio_chardev_data *cdev, void __user *ip)
 {
 	struct gpio_device *gdev = cdev->gdev;
 	struct gpiochip_info chipinfo;
+	
+	deb_debug("\n");
 
 	memset(&chipinfo, 0, sizeof(chipinfo));
 
@@ -2000,6 +2064,8 @@ static int lineinfo_get_v1(struct gpio_chardev_data *cdev, void __user *ip,
 	struct gpioline_info lineinfo;
 	struct gpio_v2_line_info lineinfo_v2;
 
+	deb_debug("\n");
+
 	if (copy_from_user(&lineinfo, ip, sizeof(lineinfo)))
 		return -EFAULT;
 
@@ -2035,6 +2101,8 @@ static int lineinfo_get(struct gpio_chardev_data *cdev, void __user *ip,
 	struct gpio_desc *desc;
 	struct gpio_v2_line_info lineinfo;
 
+	deb_debug("\n");
+
 	if (copy_from_user(&lineinfo, ip, sizeof(lineinfo)))
 		return -EFAULT;
 
@@ -2067,7 +2135,8 @@ static int lineinfo_get(struct gpio_chardev_data *cdev, void __user *ip,
 static int lineinfo_unwatch(struct gpio_chardev_data *cdev, void __user *ip)
 {
 	__u32 offset;
-
+	deb_debug("\n");
+	
 	if (copy_from_user(&offset, ip, sizeof(offset)))
 		return -EFAULT;
 
@@ -2089,6 +2158,8 @@ static long gpio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	struct gpio_device *gdev = cdev->gdev;
 	void __user *ip = (void __user *)arg;
 
+	deb_debug("cmd=0x%x, user_pointer=0x%p\n", cmd, ip);
+
 	/* We fail any subsequent ioctl():s when the chip is gone */
 	if (!gdev->chip)
 		return -ENODEV;
@@ -2122,6 +2193,8 @@ static long gpio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 static long gpio_ioctl_compat(struct file *file, unsigned int cmd,
 			      unsigned long arg)
 {
+	deb_debug("cmd=%d\n", cmd);
+
 	return gpio_ioctl(file, cmd, (unsigned long)compat_ptr(arg));
 }
 #endif
@@ -2216,8 +2289,8 @@ static ssize_t lineinfo_watch_read(struct file *file, char __user *buf,
 		if (count < event_size) {
 			spin_unlock(&cdev->wait.lock);
 			return -EINVAL;
-		}
 #endif
+		}
 		ret = kfifo_out(&cdev->events, &event, 1);
 		spin_unlock(&cdev->wait.lock);
 		if (ret != 1) {
@@ -2261,6 +2334,8 @@ static int gpio_chrdev_open(struct inode *inode, struct file *file)
 	struct gpio_chardev_data *cdev;
 	int ret = -ENOMEM;
 
+	deb_debug("\n");
+
 	/* Fail on open if the backing gpiochip is gone */
 	if (!gdev->chip)
 		return -ENODEV;
@@ -2285,7 +2360,6 @@ static int gpio_chrdev_open(struct inode *inode, struct file *file)
 
 	get_device(&gdev->dev);
 	file->private_data = cdev;
-
 	ret = nonseekable_open(inode, file);
 	if (ret)
 		goto out_unregister_notifier;
@@ -2313,6 +2387,8 @@ static int gpio_chrdev_release(struct inode *inode, struct file *file)
 	struct gpio_chardev_data *cdev = file->private_data;
 	struct gpio_device *gdev = cdev->gdev;
 
+	deb_debug("\n");
+
 	bitmap_free(cdev->watched_lines);
 	blocking_notifier_chain_unregister(&gdev->notifier,
 					   &cdev->lineinfo_changed_nb);
@@ -2339,6 +2415,8 @@ int gpiolib_cdev_register(struct gpio_device *gdev, dev_t devt)
 {
 	int ret;
 
+	deb_debug("\n");
+
 	cdev_init(&gdev->chrdev, &gpio_fileops);
 	gdev->chrdev.owner = THIS_MODULE;
 	gdev->dev.devt = MKDEV(MAJOR(devt), gdev->id);
@@ -2355,5 +2433,7 @@ int gpiolib_cdev_register(struct gpio_device *gdev, dev_t devt)
 
 void gpiolib_cdev_unregister(struct gpio_device *gdev)
 {
+	deb_debug("\n");
+
 	cdev_device_del(&gdev->chrdev, &gdev->dev);
 }
diff --git a/drivers/gpio/gpiolib-devres.c b/drivers/gpio/gpiolib-devres.c
index 7dbce4c4ebdf..c0c635f2e6fa 100644
--- a/drivers/gpio/gpiolib-devres.c
+++ b/drivers/gpio/gpiolib-devres.c
@@ -377,9 +377,6 @@ void devm_gpiod_put_array(struct device *dev, struct gpio_descs *descs)
 }
 EXPORT_SYMBOL_GPL(devm_gpiod_put_array);
 
-
-
-
 static void devm_gpio_release(struct device *dev, void *res)
 {
 	unsigned *gpio = res;
@@ -503,6 +500,7 @@ static void devm_gpio_chip_release(struct device *dev, void *res)
  * gc->base is invalid or already associated with a different chip.
  * Otherwise it returns zero as a success code.
  */
+
 int devm_gpiochip_add_data_with_key(struct device *dev, struct gpio_chip *gc, void *data,
 				    struct lock_class_key *lock_key,
 				    struct lock_class_key *request_key)
diff --git a/drivers/gpio/gpiolib-legacy.c b/drivers/gpio/gpiolib-legacy.c
index 30e2476a6dc4..883fd15c78d7 100644
--- a/drivers/gpio/gpiolib-legacy.c
+++ b/drivers/gpio/gpiolib-legacy.c
@@ -6,8 +6,34 @@
 
 #include "gpiolib.h"
 
+// #define GPIO_DEBUG
+// #define GPIO_DEBUG_VERBOSE
+
+#ifdef GPIO_DEBUG
+  /*
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+  #define deb_error(fmt, ...)    printk(KERN_ERR "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__ , kbasename(__FILE__), ##__VA_ARGS__)
+  */
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' -- " fmt, __func__, ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' -- " fmt, __func__, ##__VA_ARGS__)
+  #define deb_error(fmt, ...)    printk(KERN_ERR "GPIO func \'%s\' -- " fmt, __func__ , ##__VA_ARGS__)
+#else
+  #define deb_info(fmt, ...)
+  #define deb_debug(fmt, ...)
+  #define deb_error(fmt, ...)
+#endif
+
+#ifdef GPIO_DEBUG_VERBOSE
+  #define deb_verbose           deb_debug
+#else
+  #define deb_verbose(fmt, ...)
+#endif
+
 void gpio_free(unsigned gpio)
 {
+	deb_debug("\n");
+	
 	gpiod_free(gpio_to_desc(gpio));
 }
 EXPORT_SYMBOL_GPL(gpio_free);
@@ -23,6 +49,8 @@ int gpio_request_one(unsigned gpio, unsigned long flags, const char *label)
 	struct gpio_desc *desc;
 	int err;
 
+	deb_debug("label=%s\n", label);
+
 	desc = gpio_to_desc(gpio);
 
 	/* Compatibility: assume unavailable "valid" GPIOs will appear later */
@@ -69,6 +97,8 @@ int gpio_request(unsigned gpio, const char *label)
 {
 	struct gpio_desc *desc = gpio_to_desc(gpio);
 
+	deb_debug("label=%s\n", label);
+
 	/* Compatibility: assume unavailable "valid" GPIOs will appear later */
 	if (!desc && gpio_is_valid(gpio))
 		return -EPROBE_DEFER;
@@ -86,6 +116,8 @@ int gpio_request_array(const struct gpio *array, size_t num)
 {
 	int i, err;
 
+	deb_debug("\n");
+
 	for (i = 0; i < num; i++, array++) {
 		err = gpio_request_one(array->gpio, array->flags, array->label);
 		if (err)
diff --git a/drivers/gpio/gpiolib-of.c b/drivers/gpio/gpiolib-of.c
index f54b5905e2cc..d589fadb5b55 100644
--- a/drivers/gpio/gpiolib-of.c
+++ b/drivers/gpio/gpiolib-of.c
@@ -24,6 +24,26 @@
 #include "gpiolib.h"
 #include "gpiolib-of.h"
 
+// #define GPIO_DEBUG
+// #define GPIO_DEBUG_VERBOSE
+
+#ifdef GPIO_DEBUG
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+#else
+  #define deb_info(fmt, ...)
+  #define deb_debug(fmt, ...)
+#endif
+
+#ifdef GPIO_DEBUG_VERBOSE
+  #define deb_verbose           deb_debug
+#else
+  #define deb_verbose(fmt, ...)
+#endif
+
+#if defined(CONFIG_TEGRA_GPIO_GUEST_PROXY) || defined(CONFIG_TEGRA_GPIO_HOST_PROXY)
+#endif // CONFIG_TEGRA_GPIO_GUEST_PROXY and CONFIG_TEGRA_GPIO_HOST_PROXY
+
 /**
  * of_gpio_spi_cs_get_count() - special GPIO counting for SPI
  * @dev:    Consuming device
@@ -853,6 +873,8 @@ int of_gpiochip_suspend(struct gpio_chip *chip)
 	int ret;
 	int i, ncells, ngpios;
 
+  deb_verbose("\n");
+
 	for_each_available_child_of_node(chip->of_node, np) {
 		if (!of_property_read_bool(np, "gpio-suspend"))
 			continue;
@@ -897,8 +919,11 @@ int of_gpiochip_suspend(struct gpio_chip *chip)
 						gpio_chip_hwgpio(desc),
 						dflags & GPIOD_FLAGS_BIT_DIR_VAL);
 				else
+          {
+          deb_verbose("chip->direction_input()\n");
 					ret = chip->direction_input(chip,
 							gpio_chip_hwgpio(desc));
+          }
 			}
 
 			if (ret < 0)
@@ -1065,12 +1090,10 @@ static int of_gpiochip_add_pin_range(struct gpio_chip *chip)
 				index, &pinspec);
 		if (ret)
 			break;
-
 		pctldev = of_pinctrl_get(pinspec.np);
 		of_node_put(pinspec.np);
 		if (!pctldev)
 			return -EPROBE_DEFER;
-
 		if (pinspec.args[2]) {
 			if (group_names) {
 				of_property_read_string_index(np,
@@ -1141,7 +1164,6 @@ int of_gpiochip_add(struct gpio_chip *chip)
 		chip->of_gpio_n_cells = 2;
 		chip->of_xlate = of_gpio_simple_xlate;
 	}
-
 	if (chip->of_gpio_n_cells > MAX_PHANDLE_ARGS)
 		return -EINVAL;
 
diff --git a/drivers/gpio/gpiolib-sysfs.c b/drivers/gpio/gpiolib-sysfs.c
index 3ef71ca242ba..cabbea8d2b31 100644
--- a/drivers/gpio/gpiolib-sysfs.c
+++ b/drivers/gpio/gpiolib-sysfs.c
@@ -17,6 +17,28 @@
 #define GPIO_IRQF_TRIGGER_RISING	BIT(1)
 #define GPIO_IRQF_TRIGGER_BOTH		(GPIO_IRQF_TRIGGER_FALLING | \
 					 GPIO_IRQF_TRIGGER_RISING)
+// #define GPIO_DEBUG
+
+#ifdef GPIO_DEBUG
+  /*
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+  #define deb_error(fmt, ...)    printk(KERN_ERR "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__ , kbasename(__FILE__), ##__VA_ARGS__)
+  */
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' -- " fmt, __func__, ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' -- " fmt, __func__, ##__VA_ARGS__)
+  #define deb_error(fmt, ...)    printk(KERN_ERR "GPIO func \'%s\' -- " fmt, __func__ , ##__VA_ARGS__)
+#else
+  #define deb_info(fmt, ...)
+  #define deb_debug(fmt, ...)
+  #define deb_error(fmt, ...)
+#endif
+
+#ifdef GPIO_DEBUG_VERBOSE
+  #define deb_verbose           deb_debug
+#else
+  #define deb_verbose(fmt, ...)
+#endif
 
 struct gpiod_data {
 	struct gpio_desc *desc;
@@ -489,6 +511,8 @@ static ssize_t export_store(struct class *class,
 	struct gpio_chip	*gc;
 	int			offset;
 
+	deb_debug("\n");
+
 	status = kstrtol(buf, 0, &gpio);
 
 	/* If buf is not a number then try to find by name */
diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c
index 94b70e0636fe..fa5952eadcf3 100644
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@ -31,6 +31,33 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/gpio.h>
 
+// #define GPIO_DEBUG
+// #define GPIO_DEBUG_VERBOSE
+
+#ifdef GPIO_DEBUG
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+  #define deb_error(fmt, ...)    printk(KERN_ERR "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__ , kbasename(__FILE__), ##__VA_ARGS__)
+  /*
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' -- " fmt, __func__, ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' -- " fmt, __func__, ##__VA_ARGS__)
+  #define deb_error(fmt, ...)    printk(KERN_ERR "GPIO func \'%s\' -- " fmt, __func__ , ##__VA_ARGS__)
+  */
+#else
+  #define deb_info(fmt, ...)
+  #define deb_debug(fmt, ...)
+  #define deb_error(fmt, ...)
+#endif
+
+#ifdef GPIO_DEBUG_VERBOSE
+  #define deb_verbose           deb_debug
+#else
+  #define deb_verbose(fmt, ...)
+#endif
+
+#if defined(CONFIG_TEGRA_GPIO_GUEST_PROXY) || defined(CONFIG_TEGRA_GPIO_HOST_PROXY)
+#endif // CONFIG_TEGRA_GPIO_GUEST_PROXY and CONFIG_TEGRA_GPIO_HOST_PROXY
+
 /* Implementation infrastructure for GPIO interfaces.
  *
  * The GPIO programming interface allows for inlining speed-critical
@@ -106,6 +133,8 @@ struct gpio_desc *gpio_to_desc(unsigned gpio)
 	struct gpio_device *gdev;
 	unsigned long flags;
 
+	deb_verbose("\n");
+
 	spin_lock_irqsave(&gpio_lock, flags);
 
 	list_for_each_entry(gdev, &gpio_devices, list) {
@@ -140,6 +169,8 @@ struct gpio_desc *gpiochip_get_desc(struct gpio_chip *gc,
 {
 	struct gpio_device *gdev = gc->gpiodev;
 
+	deb_verbose("HW Number %u\n", hwnum);
+
 	if (hwnum >= gdev->ngpio)
 		return ERR_PTR(-EINVAL);
 
@@ -170,6 +201,8 @@ EXPORT_SYMBOL_GPL(desc_to_gpio);
  */
 struct gpio_chip *gpiod_to_chip(const struct gpio_desc *desc)
 {
+	deb_verbose("\n");
+
 	if (!desc || !desc->gdev)
 		return NULL;
 	return desc->gdev->chip;
@@ -183,6 +216,7 @@ static int gpiochip_find_base(int ngpio)
 	int base = ARCH_NR_GPIOS - ngpio;
 
 	list_for_each_entry_reverse(gdev, &gpio_devices, list) {
+    deb_verbose("entry 0x%llx", (long long unsigned int)gdev);
 		/* found a free space? */
 		if (gdev->base + gdev->ngpio <= base)
 			break;
@@ -214,6 +248,8 @@ int gpiod_get_direction(struct gpio_desc *desc)
 	unsigned offset;
 	int ret;
 
+	deb_verbose("name=%s, label=%s\n", desc->name, desc->label);
+
 	gc = gpiod_to_chip(desc);
 	offset = gpio_chip_hwgpio(desc);
 
@@ -228,7 +264,7 @@ int gpiod_get_direction(struct gpio_desc *desc)
 	if (!gc->get_direction)
 		return -ENOTSUPP;
 
-	ret = gc->get_direction(gc, offset);
+	ret = gc->get_direction(gc, offset);	// this function is potentially redirected to host (depending on settings)
 	if (ret < 0)
 		return ret;
 
@@ -253,6 +289,8 @@ static int gpiodev_add_to_list(struct gpio_device *gdev)
 {
 	struct gpio_device *prev, *next;
 
+	deb_verbose("\n");
+
 	if (list_empty(&gpio_devices)) {
 		/* initial entry in list */
 		list_add_tail(&gdev->list, &gpio_devices);
@@ -270,6 +308,7 @@ static int gpiodev_add_to_list(struct gpio_device *gdev)
 	if (prev->base + prev->ngpio <= gdev->base) {
 		/* add behind last entry */
 		list_add_tail(&gdev->list, &gpio_devices);
+		deb_verbose("debug 3");
 		return 0;
 	}
 
@@ -301,6 +340,8 @@ struct gpio_desc *gpio_name_to_desc(const char * const name)
 	struct gpio_device *gdev;
 	unsigned long flags;
 
+	// deb_verbose("\n");
+
 	if (!name)
 		return NULL;
 
@@ -340,6 +381,8 @@ static int gpiochip_set_desc_names(struct gpio_chip *gc)
 	struct gpio_device *gdev = gc->gpiodev;
 	int i;
 
+	deb_verbose("\n");
+
 	/* First check all names if they are unique */
 	for (i = 0; i != gc->ngpio; ++i) {
 		struct gpio_desc *gpio;
@@ -375,6 +418,8 @@ static int devprop_gpiochip_set_names(struct gpio_chip *chip)
 	int ret, i;
 	int count;
 
+	deb_verbose("\n");
+
 	count = fwnode_property_string_array_count(fwnode, "gpio-line-names");
 	if (count < 0)
 		return 0;
@@ -409,6 +454,8 @@ static unsigned long *gpiochip_allocate_mask(struct gpio_chip *gc)
 {
 	unsigned long *p;
 
+	deb_verbose("\n");
+
 	p = bitmap_alloc(gc->ngpio, GFP_KERNEL);
 	if (!p)
 		return NULL;
@@ -421,6 +468,8 @@ static unsigned long *gpiochip_allocate_mask(struct gpio_chip *gc)
 
 static int gpiochip_alloc_valid_mask(struct gpio_chip *gc)
 {
+	deb_verbose("\n");
+
 	if (!(of_gpio_need_valid_mask(gc) || gc->init_valid_mask))
 		return 0;
 
@@ -433,6 +482,8 @@ static int gpiochip_alloc_valid_mask(struct gpio_chip *gc)
 
 static int gpiochip_init_valid_mask(struct gpio_chip *gc)
 {
+	deb_verbose("\n");
+
 	if (gc->init_valid_mask)
 		return gc->init_valid_mask(gc,
 					   gc->valid_mask,
@@ -443,12 +494,16 @@ static int gpiochip_init_valid_mask(struct gpio_chip *gc)
 
 static void gpiochip_free_valid_mask(struct gpio_chip *gc)
 {
+	deb_verbose("\n");
+
 	bitmap_free(gc->valid_mask);
 	gc->valid_mask = NULL;
 }
 
 static int gpiochip_add_pin_ranges(struct gpio_chip *gc)
 {
+	deb_verbose("\n");
+
 	if (gc->add_pin_ranges)
 		return gc->add_pin_ranges(gc);
 
@@ -458,6 +513,8 @@ static int gpiochip_add_pin_ranges(struct gpio_chip *gc)
 bool gpiochip_line_is_valid(const struct gpio_chip *gc,
 				unsigned int offset)
 {
+	deb_verbose("chip %s, offset=%u\n", gc->label, offset);
+
 	/* No mask means all valid */
 	if (likely(!gc->valid_mask))
 		return true;
@@ -470,6 +527,8 @@ static void gpiodevice_release(struct device *dev)
 	struct gpio_device *gdev = dev_get_drvdata(dev);
 	unsigned long flags;
 
+	deb_verbose("\n");
+
 	spin_lock_irqsave(&gpio_lock, flags);
 	list_del(&gdev->list);
 	spin_unlock_irqrestore(&gpio_lock, flags);
@@ -492,11 +551,25 @@ static void gpiodevice_release(struct device *dev)
 #define gcdev_unregister(gdev)		device_del(&(gdev)->dev)
 #endif
 
+static int gpio_dev_count = 0;
+struct gpio_device *proxy_host_gpio_dev[2] = {NULL, NULL};
+EXPORT_SYMBOL_GPL(proxy_host_gpio_dev);
+
 static int gpiochip_setup_dev(struct gpio_device *gdev)
 {
 	int ret;
 
+	deb_verbose("\n");
+
+	// store GPIO char device for use by proxy host driver (In guest this is redundant)
+	if (gpio_dev_count == 2) {
+		pr_err("GPIO %s, error, found more than two devices -- file %s", __func__, __FILE__);
+		}
+	proxy_host_gpio_dev[gpio_dev_count++] = gdev;
+	// we continue to populate gdev
+
 	ret = gcdev_register(gdev, gpio_devt);
+
 	if (ret)
 		return ret;
 
@@ -522,6 +595,8 @@ static void gpiochip_machine_hog(struct gpio_chip *gc, struct gpiod_hog *hog)
 	struct gpio_desc *desc;
 	int rv;
 
+	deb_verbose("\n");
+
 	desc = gpiochip_get_desc(gc, hog->chip_hwnum);
 	if (IS_ERR(desc)) {
 		chip_err(gc, "%s: unable to get GPIO desc: %ld\n", __func__,
@@ -542,6 +617,8 @@ static void machine_gpiochip_add(struct gpio_chip *gc)
 {
 	struct gpiod_hog *hog;
 
+	deb_verbose("\n");
+
 	mutex_lock(&gpio_machine_hogs_mutex);
 
 	list_for_each_entry(hog, &gpio_machine_hogs, list) {
@@ -557,6 +634,8 @@ static void gpiochip_setup_devs(void)
 	struct gpio_device *gdev;
 	int ret;
 
+	deb_verbose("\n");
+
 	list_for_each_entry(gdev, &gpio_devices, list) {
 		ret = gpiochip_setup_dev(gdev);
 		if (ret)
@@ -576,6 +655,8 @@ int gpiochip_add_data_with_key(struct gpio_chip *gc, void *data,
 	int		base = gc->base;
 	struct gpio_device *gdev;
 
+	deb_verbose("\n");
+
 	/*
 	 * First: allocate and populate the internal stat container, and
 	 * set up the struct device.
@@ -802,6 +883,8 @@ EXPORT_SYMBOL_GPL(gpiochip_add_data_with_key);
  */
 void *gpiochip_get_data(struct gpio_chip *gc)
 {
+	deb_verbose("\n");
+
 	return gc->gpiodev->data;
 }
 EXPORT_SYMBOL_GPL(gpiochip_get_data);
@@ -818,6 +901,8 @@ void gpiochip_remove(struct gpio_chip *gc)
 	unsigned long	flags;
 	unsigned int	i;
 
+	deb_verbose("\n");
+
 	/* FIXME: should the legacy sysfs handling be moved to gpio_device? */
 	gpiochip_sysfs_unregister(gdev);
 	gpiochip_free_hogs(gc);
@@ -875,10 +960,13 @@ struct gpio_chip *gpiochip_find(void *data,
 	struct gpio_chip *gc = NULL;
 	unsigned long flags;
 
+	deb_verbose("\n");
+
 	spin_lock_irqsave(&gpio_lock, flags);
 	list_for_each_entry(gdev, &gpio_devices, list)
 		if (gdev->chip && match(gdev->chip, data)) {
 			gc = gdev->chip;
+      deb_verbose("found: %p, chip: %s", gc, gc->label);
 			break;
 		}
 
@@ -895,10 +983,13 @@ static int gpiochip_match_name(struct gpio_chip *gc, void *data)
 	return !strcmp(gc->label, name);
 }
 
-static struct gpio_chip *find_chip_by_name(const char *name)
+struct gpio_chip *find_chip_by_name(const char *name)
 {
+	deb_verbose("\n");
+
 	return gpiochip_find((void *)name, gpiochip_match_name);
 }
+EXPORT_SYMBOL_GPL(find_chip_by_name);
 
 #ifdef CONFIG_GPIOLIB_IRQCHIP
 
@@ -910,6 +1001,8 @@ static int gpiochip_irqchip_init_hw(struct gpio_chip *gc)
 {
 	struct gpio_irq_chip *girq = &gc->irq;
 
+	deb_verbose("\n");
+
 	if (!girq->init_hw)
 		return 0;
 
@@ -920,6 +1013,8 @@ static int gpiochip_irqchip_init_valid_mask(struct gpio_chip *gc)
 {
 	struct gpio_irq_chip *girq = &gc->irq;
 
+	deb_verbose("\n");
+
 	if (!girq->init_valid_mask)
 		return 0;
 
@@ -934,6 +1029,8 @@ static int gpiochip_irqchip_init_valid_mask(struct gpio_chip *gc)
 
 static void gpiochip_irqchip_free_valid_mask(struct gpio_chip *gc)
 {
+	deb_verbose("\n");
+
 	bitmap_free(gc->irq.valid_mask);
 	gc->irq.valid_mask = NULL;
 }
@@ -941,12 +1038,28 @@ static void gpiochip_irqchip_free_valid_mask(struct gpio_chip *gc)
 bool gpiochip_irqchip_irq_valid(const struct gpio_chip *gc,
 				unsigned int offset)
 {
+#ifdef GPIO_DEBUG_VERBOSE
+bool ret;
+	if (!gpiochip_line_is_valid(gc, offset)) {
+		deb_verbose("(gpiochip_line_is_valid) return: false\n");
+		return false;
+	}
+	/* No mask means all valid */
+	if (likely(!gc->irq.valid_mask)) {
+		deb_verbose("(likely) return: true\n");
+		return true;
+	}
+	ret = test_bit(offset, gc->irq.valid_mask);
+	deb_verbose("(test_bit) return: %s\n", ret? "true" : "false");
+	return ret;
+#else
 	if (!gpiochip_line_is_valid(gc, offset))
 		return false;
 	/* No mask means all valid */
 	if (likely(!gc->irq.valid_mask))
 		return true;
 	return test_bit(offset, gc->irq.valid_mask);
+#endif
 }
 EXPORT_SYMBOL_GPL(gpiochip_irqchip_irq_valid);
 
@@ -966,6 +1079,8 @@ static void gpiochip_set_cascaded_irqchip(struct gpio_chip *gc,
 	struct gpio_irq_chip *girq = &gc->irq;
 	struct device *dev = &gc->gpiodev->dev;
 
+	deb_verbose("\n");
+
 	if (!girq->domain) {
 		chip_err(gc, "called %s before setting up irqchip\n",
 			 __func__);
@@ -1126,6 +1241,8 @@ static int gpiochip_hierarchy_irq_domain_alloc(struct irq_domain *d,
 	unsigned int parent_type;
 	struct gpio_irq_chip *girq = &gc->irq;
 	int ret;
+	
+	deb_verbose("irq=%d, nr_irqs=%d\n", irq, nr_irqs);
 
 	/*
 	 * The nr_irqs parameter is always one except for PCI multi-MSI
@@ -1159,6 +1276,14 @@ static int gpiochip_hierarchy_irq_domain_alloc(struct irq_domain *d,
 			    girq->handler,
 			    NULL, NULL);
 	irq_set_probe(irq);
+	
+	deb_verbose("domain=%p, irq=%d, hwirq=%ld, chip=%p, data=%p, handler=%p",
+	        d,
+			    irq,
+			    hwirq,
+			    gc->irq.chip,
+			    gc,
+			    girq->handler);
 
 	/* This parent only handles asserted level IRQs */
 	parent_arg = girq->populate_parent_alloc_arg(gc, parent_hwirq, parent_type);
@@ -1168,18 +1293,22 @@ static int gpiochip_hierarchy_irq_domain_alloc(struct irq_domain *d,
 	chip_dbg(gc, "alloc_irqs_parent for %d parent hwirq %d\n",
 		  irq, parent_hwirq);
 	irq_set_lockdep_class(irq, gc->irq.lock_key, gc->irq.request_key);
-	ret = irq_domain_alloc_irqs_parent(d, irq, 1, parent_arg);
+  deb_verbose("trace:%d, parent_arg=%p", __LINE__, parent_arg);
+	ret = irq_domain_alloc_irqs_parent(d, irq, 1, parent_arg);			// BUG: Guest seems to fail here ?
 	/*
 	 * If the parent irqdomain is msi, the interrupts have already
 	 * been allocated, so the EEXIST is good.
 	 */
+  deb_verbose("trace:%d ret=%d", __LINE__, ret);
 	if (irq_domain_is_msi(d->parent) && (ret == -EEXIST))
 		ret = 0;
+  deb_verbose("trace:%d ret=%d", __LINE__, ret);
 	if (ret)
 		chip_err(gc,
 			 "failed to allocate parent hwirq %d for hwirq %lu\n",
 			 parent_hwirq, hwirq);
 
+  deb_verbose("trace:%d ret=%d", __LINE__, ret);
 	kfree(parent_arg);
 	return ret;
 }
@@ -1230,7 +1359,7 @@ static int gpiochip_hierarchy_add_domain(struct gpio_chip *gc)
 		gc->irq.fwnode,
 		&gc->irq.child_irq_domain_ops,
 		gc);
-
+	deb_debug("irq_domain=%p\n", gc->irq.domain);
 	if (!gc->irq.domain)
 		return -ENOMEM;
 
@@ -1250,6 +1379,8 @@ void *gpiochip_populate_parent_fwspec_twocell(struct gpio_chip *gc,
 {
 	struct irq_fwspec *fwspec;
 
+	deb_verbose("\n");
+
 	fwspec = kmalloc(sizeof(*fwspec), GFP_KERNEL);
 	if (!fwspec)
 		return NULL;
@@ -1269,6 +1400,8 @@ void *gpiochip_populate_parent_fwspec_fourcell(struct gpio_chip *gc,
 {
 	struct irq_fwspec *fwspec;
 
+	deb_verbose("\n");
+
 	fwspec = kmalloc(sizeof(*fwspec), GFP_KERNEL);
 	if (!fwspec)
 		return NULL;
@@ -1314,6 +1447,8 @@ int gpiochip_irq_map(struct irq_domain *d, unsigned int irq,
 	struct gpio_chip *gc = d->host_data;
 	int ret = 0;
 
+	deb_verbose("\n");
+
 	if (!gpiochip_irqchip_irq_valid(gc, hwirq))
 		return -ENXIO;
 
@@ -1403,6 +1538,8 @@ void gpiochip_irq_domain_deactivate(struct irq_domain *domain,
 				    struct irq_data *data)
 {
 	struct gpio_chip *gc = domain->host_data;
+	
+	deb_verbose("\n");
 
 	return gpiochip_unlock_as_irq(gc, data->hwirq);
 }
@@ -1411,6 +1548,10 @@ EXPORT_SYMBOL_GPL(gpiochip_irq_domain_deactivate);
 static int gpiochip_to_irq(struct gpio_chip *gc, unsigned offset)
 {
 	struct irq_domain *domain = gc->irq.domain;
+#ifdef GPIO_DEBUG_VERBOSE
+	int ret;
+	deb_verbose("irq_domain=%p, base=%d, offset=%d\n", domain, gc->base, offset);
+#endif
 
 #ifdef CONFIG_GPIOLIB_IRQCHIP
 	/*
@@ -1418,26 +1559,38 @@ static int gpiochip_to_irq(struct gpio_chip *gc, unsigned offset)
 	 * an IRQ before the irqchip has been properly registered,
 	 * i.e. while gpiochip is still being brought up.
 	 */
+	deb_verbose("trace A, line %d\n", __LINE__);
 	if (!gc->irq.initialized)
 		return -EPROBE_DEFER;
 #endif
-
+	deb_verbose("trace B, line %d\n", __LINE__);
 	if (!gpiochip_irqchip_irq_valid(gc, offset))
 		return -ENXIO;
-
+	deb_verbose("trace C, line %d\n", __LINE__);
 #ifdef CONFIG_IRQ_DOMAIN_HIERARCHY
+	
+	deb_verbose("trace D, line %d\n", __LINE__);
 	if (irq_domain_is_hierarchy(domain)) {
 		struct irq_fwspec spec;
+		deb_verbose("trace E, line %d\n", __LINE__);
 
 		spec.fwnode = domain->fwnode;
 		spec.param_count = 2;
 		spec.param[0] = gc->irq.child_offset_to_irq(gc, offset);
 		spec.param[1] = IRQ_TYPE_NONE;
-
+		
+		deb_verbose("trace F, line %d; %p, count=%d, offset=%d, type=%d\n", __LINE__, spec.fwnode, spec.param_count, spec.param[0], spec.param[1]);
+#ifdef GPIO_DEBUG_VERBOSE
+		ret = irq_create_fwspec_mapping(&spec);		// BUG Guest seems to fail here, NO fail *here* if we add exception for request/free
+		deb_verbose("trace G, line %d: %d\n", __LINE__, ret);
+    return ret;
+#else
 		return irq_create_fwspec_mapping(&spec);
+#endif
 	}
 #endif
 
+	deb_verbose("trace H, line %d\n", __LINE__);
 	return irq_create_mapping(domain, offset);
 }
 
@@ -1492,6 +1645,8 @@ static void gpiochip_irq_disable(struct irq_data *d)
 static void gpiochip_set_irq_hooks(struct gpio_chip *gc)
 {
 	struct irq_chip *irqchip = gc->irq.chip;
+	
+	deb_verbose("\n");
 
 	if (!irqchip->irq_request_resources &&
 	    !irqchip->irq_release_resources) {
@@ -1544,6 +1699,8 @@ static int gpiochip_add_irqchip(struct gpio_chip *gc,
 	struct device_node *np;
 	unsigned int type;
 	unsigned int i;
+	
+	deb_verbose("\n");
 
 	if (!irqchip)
 		return 0;
@@ -1592,6 +1749,7 @@ static int gpiochip_add_irqchip(struct gpio_chip *gc,
 			gc->ngpio,
 			gc->irq.first,
 			ops, gc);
+deb_debug("irq_domain=%p\n", gc->irq.domain);
 		if (!gc->irq.domain)
 			return -EINVAL;
 	}
@@ -1718,6 +1876,8 @@ int gpiochip_irqchip_add_key(struct gpio_chip *gc,
 			     struct lock_class_key *request_key)
 {
 	struct device_node *of_node;
+  
+  deb_verbose("\n");
 
 	if (!gc || !irqchip)
 		return -EINVAL;
@@ -1760,6 +1920,7 @@ int gpiochip_irqchip_add_key(struct gpio_chip *gc,
 	gc->irq.domain = irq_domain_add_simple(of_node,
 					gc->ngpio, first_irq,
 					&gpiochip_domain_ops, gc);
+deb_debug("irq_domain=%p\n", gc->irq.domain);
 	if (!gc->irq.domain) {
 		gc->irq.chip = NULL;
 		return -EINVAL;
@@ -1783,12 +1944,13 @@ EXPORT_SYMBOL_GPL(gpiochip_irqchip_add_key);
 int gpiochip_irqchip_add_domain(struct gpio_chip *gc,
 				struct irq_domain *domain)
 {
+deb_debug("\n");
 	if (!domain)
 		return -EINVAL;
 
 	gc->to_irq = gpiochip_to_irq;
 	gc->irq.domain = domain;
-
+	deb_debug("irq_domain=%p\n", gc->irq.domain);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(gpiochip_irqchip_add_domain);
@@ -1824,6 +1986,8 @@ static inline void gpiochip_irqchip_free_valid_mask(struct gpio_chip *gc)
  */
 int gpiochip_generic_request(struct gpio_chip *gc, unsigned offset)
 {
+	deb_verbose("chip %s, offset=%u\n", gc->label, offset);
+
 #ifdef CONFIG_PINCTRL
 	if (list_empty(&gc->gpiodev->pin_ranges))
 		return 0;
@@ -1840,6 +2004,8 @@ EXPORT_SYMBOL_GPL(gpiochip_generic_request);
  */
 void gpiochip_generic_free(struct gpio_chip *gc, unsigned offset)
 {
+ 	deb_verbose("chip %s, offset=%u\n", gc->label, offset);
+ 
 #ifdef CONFIG_PINCTRL
 	if (list_empty(&gc->gpiodev->pin_ranges))
 		return;
@@ -1858,6 +2024,8 @@ EXPORT_SYMBOL_GPL(gpiochip_generic_free);
 int gpiochip_generic_config(struct gpio_chip *gc, unsigned offset,
 			    unsigned long config)
 {
+	deb_verbose("\n");
+
 	return pinctrl_gpio_set_config(gc->gpiodev->base + offset, config);
 }
 EXPORT_SYMBOL_GPL(gpiochip_generic_config);
@@ -1884,6 +2052,8 @@ int gpiochip_add_pingroup_range(struct gpio_chip *gc,
 	struct gpio_device *gdev = gc->gpiodev;
 	int ret;
 
+	deb_verbose("\n");
+
 	pin_range = kzalloc(sizeof(*pin_range), GFP_KERNEL);
 	if (!pin_range) {
 		chip_err(gc, "failed to allocate pin ranges\n");
@@ -1942,6 +2112,8 @@ int gpiochip_add_pin_range(struct gpio_chip *gc, const char *pinctl_name,
 	struct gpio_device *gdev = gc->gpiodev;
 	int ret;
 
+	deb_verbose("\n");
+
 	pin_range = kzalloc(sizeof(*pin_range), GFP_KERNEL);
 	if (!pin_range) {
 		chip_err(gc, "failed to allocate pin ranges\n");
@@ -1983,6 +2155,8 @@ void gpiochip_remove_pin_ranges(struct gpio_chip *gc)
 	struct gpio_pin_range *pin_range, *tmp;
 	struct gpio_device *gdev = gc->gpiodev;
 
+	deb_verbose("\n");
+   
 	list_for_each_entry_safe(pin_range, tmp, &gdev->pin_ranges, node) {
 		list_del(&pin_range->node);
 		pinctrl_remove_gpio_range(pin_range->pctldev,
@@ -2006,6 +2180,8 @@ static int gpiod_request_commit(struct gpio_desc *desc, const char *label)
 	bool			hogged = false;
 	unsigned		offset;
 
+	deb_verbose("label=%s\n", label);
+
 	if (label) {
 		/* Free desc->label if already allocated. */
 		if (desc->label) {
@@ -2111,6 +2287,8 @@ int gpiod_request(struct gpio_desc *desc, const char *label)
 	int ret = -EPROBE_DEFER;
 	struct gpio_device *gdev;
 
+	deb_verbose("label=%s\n", label);
+
 	VALIDATE_DESC(desc);
 	gdev = desc->gdev;
 
@@ -2127,6 +2305,7 @@ int gpiod_request(struct gpio_desc *desc, const char *label)
 
 	return ret;
 }
+EXPORT_SYMBOL_GPL(gpiod_request);
 
 static bool gpiod_free_commit(struct gpio_desc *desc)
 {
@@ -2134,6 +2313,8 @@ static bool gpiod_free_commit(struct gpio_desc *desc)
 	unsigned long		flags;
 	struct gpio_chip	*gc;
 
+	deb_verbose("\n");
+   
 	might_sleep();
 
 	gpiod_unexport(desc);
@@ -2178,6 +2359,8 @@ static bool gpiod_free_commit(struct gpio_desc *desc)
 
 void gpiod_free(struct gpio_desc *desc)
 {
+	deb_verbose("\n");
+
 	if (desc && desc->gdev && gpiod_free_commit(desc)) {
 		module_put(desc->gdev->owner);
 		put_device(&desc->gdev->dev);
@@ -2185,6 +2368,7 @@ void gpiod_free(struct gpio_desc *desc)
 		WARN_ON(extra_checks);
 	}
 }
+EXPORT_SYMBOL_GPL(gpiod_free);
 
 /**
  * gpiochip_is_requested - return string iff signal was requested
@@ -2203,6 +2387,8 @@ const char *gpiochip_is_requested(struct gpio_chip *gc, unsigned offset)
 {
 	struct gpio_desc *desc;
 
+	deb_verbose("label=%s\n", gc->label);
+
 	if (offset >= gc->ngpio)
 		return NULL;
 
@@ -2246,6 +2432,8 @@ struct gpio_desc *gpiochip_request_own_desc(struct gpio_chip *gc,
 	struct gpio_desc *desc = gpiochip_get_desc(gc, hwnum);
 	int ret;
 
+	deb_verbose("\n");
+
 	if (IS_ERR(desc)) {
 		chip_err(gc, "failed to get GPIO descriptor\n");
 		return desc;
@@ -2293,6 +2481,8 @@ EXPORT_SYMBOL_GPL(gpiochip_free_own_desc);
 static int gpio_do_set_config(struct gpio_chip *gc, unsigned int offset,
 			      unsigned long config)
 {
+	deb_verbose("\n");
+
 	if (!gc->set_config)
 		return -ENOTSUPP;
 
@@ -2305,6 +2495,8 @@ static int gpio_set_config(struct gpio_desc *desc, enum pin_config_param mode)
 	unsigned long config;
 	unsigned arg;
 
+	deb_verbose("\n");
+
 	switch (mode) {
 	case PIN_CONFIG_BIAS_PULL_DOWN:
 	case PIN_CONFIG_BIAS_PULL_UP:
@@ -2324,6 +2516,8 @@ static int gpio_set_bias(struct gpio_desc *desc)
 	int bias = 0;
 	int ret = 0;
 
+	deb_verbose("\n");
+
 	if (test_bit(FLAG_BIAS_DISABLE, &desc->flags))
 		bias = PIN_CONFIG_BIAS_DISABLE;
 	else if (test_bit(FLAG_PULL_UP, &desc->flags))
@@ -2353,6 +2547,8 @@ int gpiod_direction_input(struct gpio_desc *desc)
 	struct gpio_chip	*gc;
 	int			ret = 0;
 
+	deb_verbose("\n");
+
 	VALIDATE_DESC(desc);
 	gc = desc->gdev->chip;
 
@@ -2400,6 +2596,8 @@ static int gpiod_direction_output_raw_commit(struct gpio_desc *desc, int value)
 	int val = !!value;
 	int ret = 0;
 
+	deb_verbose("\n");
+
 	/*
 	 * It's OK not to specify .direction_output() if the gpiochip is
 	 * output-only, but if there is then not even a .set() operation it
@@ -2450,6 +2648,8 @@ static int gpiod_direction_output_raw_commit(struct gpio_desc *desc, int value)
  */
 int gpiod_direction_output_raw(struct gpio_desc *desc, int value)
 {
+	deb_verbose("\n");
+
 	VALIDATE_DESC(desc);
 	return gpiod_direction_output_raw_commit(desc, value);
 }
@@ -2471,6 +2671,8 @@ int gpiod_direction_output(struct gpio_desc *desc, int value)
 {
 	int ret;
 
+	deb_verbose("\n");
+
 	VALIDATE_DESC(desc);
 	if (test_bit(FLAG_ACTIVE_LOW, &desc->flags))
 		value = !value;
@@ -2542,6 +2744,8 @@ int gpiod_timestamp_control(struct gpio_desc *desc, int enable)
 {
 	struct gpio_chip *chip;
 
+	deb_verbose("\n");
+
 	VALIDATE_DESC(desc);
 	chip = desc->gdev->chip;
 	if (!chip->timestamp_control) {
@@ -2569,6 +2773,8 @@ int gpiod_timestamp_read(struct gpio_desc *desc, u64 *ts)
 	u64 gpio_ts;
 	int ret;
 
+	deb_verbose("\n");
+
 	VALIDATE_DESC(desc);
 	chip = desc->gdev->chip;
 	if (!chip->timestamp_read) {
@@ -2597,6 +2803,8 @@ int gpiod_set_config(struct gpio_desc *desc, unsigned long config)
 {
 	struct gpio_chip *gc;
 
+	deb_verbose("\n");
+
 	VALIDATE_DESC(desc);
 	gc = desc->gdev->chip;
 
@@ -2617,6 +2825,8 @@ int gpiod_set_debounce(struct gpio_desc *desc, unsigned debounce)
 {
 	unsigned long config;
 
+	deb_verbose("\n");
+
 	config = pinconf_to_config_packed(PIN_CONFIG_INPUT_DEBOUNCE, debounce);
 	return gpiod_set_config(desc, config);
 }
@@ -2637,6 +2847,8 @@ int gpiod_set_transitory(struct gpio_desc *desc, bool transitory)
 	int gpio;
 	int rc;
 
+	deb_verbose("\n");
+
 	VALIDATE_DESC(desc);
 	/*
 	 * Handle FLAG_TRANSITORY first, enabling queries to gpiolib for
@@ -2671,6 +2883,8 @@ EXPORT_SYMBOL_GPL(gpiod_set_transitory);
  */
 int gpiod_is_active_low(const struct gpio_desc *desc)
 {
+	deb_verbose("\n");
+
 	VALIDATE_DESC(desc);
 	return test_bit(FLAG_ACTIVE_LOW, &desc->flags);
 }
@@ -2682,6 +2896,8 @@ EXPORT_SYMBOL_GPL(gpiod_is_active_low);
  */
 void gpiod_toggle_active_low(struct gpio_desc *desc)
 {
+	deb_verbose("\n");
+
 	VALIDATE_DESC_VOID(desc);
 	change_bit(FLAG_ACTIVE_LOW, &desc->flags);
 }
@@ -2715,6 +2931,8 @@ static int gpiod_get_raw_value_commit(const struct gpio_desc *desc)
 	int offset;
 	int value;
 
+	deb_verbose("\n");
+
 	gc = desc->gdev->chip;
 	offset = gpio_chip_hwgpio(desc);
 	value = gc->get ? gc->get(gc, offset) : -EIO;
@@ -2726,6 +2944,8 @@ static int gpiod_get_raw_value_commit(const struct gpio_desc *desc)
 static int gpio_chip_get_multiple(struct gpio_chip *gc,
 				  unsigned long *mask, unsigned long *bits)
 {
+	deb_verbose("\n");
+
 	if (gc->get_multiple) {
 		return gc->get_multiple(gc, mask, bits);
 	} else if (gc->get) {
@@ -2750,6 +2970,8 @@ int gpiod_get_array_value_complex(bool raw, bool can_sleep,
 {
 	int ret, i = 0;
 
+	deb_verbose("\n");
+
 	/*
 	 * Validate array_info against desc_array and its size.
 	 * It should immediately follow desc_array if both
@@ -2856,6 +3078,8 @@ int gpiod_get_array_value_complex(bool raw, bool can_sleep,
  */
 int gpiod_get_raw_value(const struct gpio_desc *desc)
 {
+	deb_verbose("\n");
+
 	VALIDATE_DESC(desc);
 	/* Should be using gpiod_get_raw_value_cansleep() */
 	WARN_ON(desc->gdev->chip->can_sleep);
@@ -2877,6 +3101,8 @@ int gpiod_get_value(const struct gpio_desc *desc)
 {
 	int value;
 
+	deb_verbose("\n");
+
 	VALIDATE_DESC(desc);
 	/* Should be using gpiod_get_value_cansleep() */
 	WARN_ON(desc->gdev->chip->can_sleep);
@@ -2911,6 +3137,8 @@ int gpiod_get_raw_array_value(unsigned int array_size,
 			      struct gpio_array *array_info,
 			      unsigned long *value_bitmap)
 {
+	deb_verbose("\n");
+
 	if (!desc_array)
 		return -EINVAL;
 	return gpiod_get_array_value_complex(true, false, array_size,
@@ -2937,6 +3165,8 @@ int gpiod_get_array_value(unsigned int array_size,
 			  struct gpio_array *array_info,
 			  unsigned long *value_bitmap)
 {
+	deb_verbose("\n");
+
 	if (!desc_array)
 		return -EINVAL;
 	return gpiod_get_array_value_complex(false, false, array_size,
@@ -2956,6 +3186,8 @@ static void gpio_set_open_drain_value_commit(struct gpio_desc *desc, bool value)
 	struct gpio_chip *gc = desc->gdev->chip;
 	int offset = gpio_chip_hwgpio(desc);
 
+	deb_verbose("\n");
+
 	if (value) {
 		ret = gc->direction_input(gc, offset);
 	} else {
@@ -2981,6 +3213,8 @@ static void gpio_set_open_source_value_commit(struct gpio_desc *desc, bool value
 	struct gpio_chip *gc = desc->gdev->chip;
 	int offset = gpio_chip_hwgpio(desc);
 
+	deb_verbose("\n");
+
 	if (value) {
 		ret = gc->direction_output(gc, offset, 1);
 		if (!ret)
@@ -2999,6 +3233,8 @@ static void gpiod_set_raw_value_commit(struct gpio_desc *desc, bool value)
 {
 	struct gpio_chip	*gc;
 
+	deb_verbose("\n");
+
 	gc = desc->gdev->chip;
 	trace_gpio_value(desc_to_gpio(desc), 0, value);
 	gc->set(gc, gpio_chip_hwgpio(desc), value);
@@ -3017,6 +3253,8 @@ static void gpiod_set_raw_value_commit(struct gpio_desc *desc, bool value)
 static void gpio_chip_set_multiple(struct gpio_chip *gc,
 				   unsigned long *mask, unsigned long *bits)
 {
+	deb_verbose("\n");
+
 	if (gc->set_multiple) {
 		gc->set_multiple(gc, mask, bits);
 	} else {
@@ -3036,6 +3274,8 @@ int gpiod_set_array_value_complex(bool raw, bool can_sleep,
 {
 	int i = 0;
 
+	deb_verbose("\n");
+
 	/*
 	 * Validate array_info against desc_array and its size.
 	 * It should immediately follow desc_array if both
@@ -3141,6 +3381,8 @@ int gpiod_set_array_value_complex(bool raw, bool can_sleep,
  */
 void gpiod_set_raw_value(struct gpio_desc *desc, int value)
 {
+	deb_verbose("\n");
+
 	VALIDATE_DESC_VOID(desc);
 	/* Should be using gpiod_set_raw_value_cansleep() */
 	WARN_ON(desc->gdev->chip->can_sleep);
@@ -3159,6 +3401,8 @@ EXPORT_SYMBOL_GPL(gpiod_set_raw_value);
  */
 static void gpiod_set_value_nocheck(struct gpio_desc *desc, int value)
 {
+	deb_verbose("\n");
+
 	if (test_bit(FLAG_ACTIVE_LOW, &desc->flags))
 		value = !value;
 	if (test_bit(FLAG_OPEN_DRAIN, &desc->flags))
@@ -3182,6 +3426,8 @@ static void gpiod_set_value_nocheck(struct gpio_desc *desc, int value)
  */
 void gpiod_set_value(struct gpio_desc *desc, int value)
 {
+	deb_verbose("\n");
+
 	VALIDATE_DESC_VOID(desc);
 	/* Should be using gpiod_set_value_cansleep() */
 	WARN_ON(desc->gdev->chip->can_sleep);
@@ -3207,6 +3453,8 @@ int gpiod_set_raw_array_value(unsigned int array_size,
 			      struct gpio_array *array_info,
 			      unsigned long *value_bitmap)
 {
+	deb_verbose("\n");
+
 	if (!desc_array)
 		return -EINVAL;
 	return gpiod_set_array_value_complex(true, false, array_size,
@@ -3232,6 +3480,8 @@ int gpiod_set_array_value(unsigned int array_size,
 			  struct gpio_array *array_info,
 			  unsigned long *value_bitmap)
 {
+	deb_verbose("\n");
+
 	if (!desc_array)
 		return -EINVAL;
 	return gpiod_set_array_value_complex(false, false, array_size,
@@ -3247,6 +3497,8 @@ EXPORT_SYMBOL_GPL(gpiod_set_array_value);
  */
 int gpiod_cansleep(const struct gpio_desc *desc)
 {
+	deb_verbose("\n");
+
 	VALIDATE_DESC(desc);
 	return desc->gdev->chip->can_sleep;
 }
@@ -3259,6 +3511,8 @@ EXPORT_SYMBOL_GPL(gpiod_cansleep);
  */
 int gpiod_set_consumer_name(struct gpio_desc *desc, const char *name)
 {
+	deb_verbose("\n");
+
 	VALIDATE_DESC(desc);
 	if (name) {
 		name = kstrdup_const(name, GFP_KERNEL);
@@ -3285,6 +3539,8 @@ int gpiod_to_irq(const struct gpio_desc *desc)
 	struct gpio_chip *gc;
 	int offset;
 
+	deb_verbose("\n");
+
 	/*
 	 * Cannot VALIDATE_DESC() here as gpiod_to_irq() consumer semantics
 	 * requires this function to not return zero on an invalid descriptor
@@ -3293,17 +3549,22 @@ int gpiod_to_irq(const struct gpio_desc *desc)
 	if (!desc || IS_ERR(desc) || !desc->gdev || !desc->gdev->chip)
 		return -EINVAL;
 
+	deb_verbose("trace %d\n", __LINE__);
 	gc = desc->gdev->chip;
 	offset = gpio_chip_hwgpio(desc);
+	deb_verbose("trace %d\n", __LINE__);
 	if (gc->to_irq) {
-		int retirq = gc->to_irq(gc, offset);
+		int retirq = gc->to_irq(gc, offset); // to_irq is set to 'gpiochip_to_irq' -- WARNING in irq-gic-v3.c:1461 gic_irq_domain_translate
+	  deb_verbose("trace %d\n", __LINE__);
 
 		/* Zero means NO_IRQ */
 		if (!retirq)
 			return -ENXIO;
 
+		deb_verbose("return irq=%d\n", retirq);
 		return retirq;
 	}
+	deb_verbose("trace %d\n", __LINE__);
 #ifdef CONFIG_GPIOLIB_IRQCHIP
 	if (gc->irq.chip) {
 		/*
@@ -3314,6 +3575,7 @@ int gpiod_to_irq(const struct gpio_desc *desc)
 		return -EPROBE_DEFER;
 	}
 #endif
+	deb_verbose("trace %d\n", __LINE__);
 	return -ENXIO;
 }
 EXPORT_SYMBOL_GPL(gpiod_to_irq);
@@ -3330,6 +3592,8 @@ int gpiochip_lock_as_irq(struct gpio_chip *gc, unsigned int offset)
 {
 	struct gpio_desc *desc;
 
+	deb_verbose("\n");
+
 	desc = gpiochip_get_desc(gc, offset);
 	if (IS_ERR(desc))
 		return PTR_ERR(desc);
@@ -3384,6 +3648,8 @@ void gpiochip_unlock_as_irq(struct gpio_chip *gc, unsigned int offset)
 {
 	struct gpio_desc *desc;
 
+	deb_verbose("\n");
+
 	desc = gpiochip_get_desc(gc, offset);
 	if (IS_ERR(desc))
 		return;
@@ -3401,6 +3667,8 @@ void gpiochip_disable_irq(struct gpio_chip *gc, unsigned int offset)
 {
 	struct gpio_desc *desc = gpiochip_get_desc(gc, offset);
 
+	deb_verbose("\n");
+
 	if (!IS_ERR(desc) &&
 	    !WARN_ON(!test_bit(FLAG_USED_AS_IRQ, &desc->flags)))
 		clear_bit(FLAG_IRQ_IS_ENABLED, &desc->flags);
@@ -3411,6 +3679,8 @@ void gpiochip_enable_irq(struct gpio_chip *gc, unsigned int offset)
 {
 	struct gpio_desc *desc = gpiochip_get_desc(gc, offset);
 
+	deb_verbose("\n");
+
 	if (!IS_ERR(desc) &&
 	    !WARN_ON(!test_bit(FLAG_USED_AS_IRQ, &desc->flags))) {
 		/*
@@ -3426,6 +3696,8 @@ EXPORT_SYMBOL_GPL(gpiochip_enable_irq);
 
 bool gpiochip_line_is_irq(struct gpio_chip *gc, unsigned int offset)
 {
+	deb_verbose("\n");
+
 	if (offset >= gc->ngpio)
 		return false;
 
@@ -3452,6 +3724,8 @@ EXPORT_SYMBOL_GPL(gpiochip_reqres_irq);
 
 void gpiochip_relres_irq(struct gpio_chip *gc, unsigned int offset)
 {
+	deb_verbose("\n");
+	
 	gpiochip_unlock_as_irq(gc, offset);
 	module_put(gc->gpiodev->owner);
 }
@@ -3459,6 +3733,8 @@ EXPORT_SYMBOL_GPL(gpiochip_relres_irq);
 
 bool gpiochip_line_is_open_drain(struct gpio_chip *gc, unsigned int offset)
 {
+	deb_verbose("\n");
+
 	if (offset >= gc->ngpio)
 		return false;
 
@@ -3468,6 +3744,8 @@ EXPORT_SYMBOL_GPL(gpiochip_line_is_open_drain);
 
 bool gpiochip_line_is_open_source(struct gpio_chip *gc, unsigned int offset)
 {
+	deb_verbose("\n");
+
 	if (offset >= gc->ngpio)
 		return false;
 
@@ -3477,6 +3755,8 @@ EXPORT_SYMBOL_GPL(gpiochip_line_is_open_source);
 
 bool gpiochip_line_is_persistent(struct gpio_chip *gc, unsigned int offset)
 {
+	deb_verbose("\n");
+
 	if (offset >= gc->ngpio)
 		return false;
 
@@ -3495,6 +3775,8 @@ EXPORT_SYMBOL_GPL(gpiochip_line_is_persistent);
  */
 int gpiod_get_raw_value_cansleep(const struct gpio_desc *desc)
 {
+	deb_verbose("\n");
+
 	might_sleep_if(extra_checks);
 	VALIDATE_DESC(desc);
 	return gpiod_get_raw_value_commit(desc);
@@ -3514,6 +3796,8 @@ int gpiod_get_value_cansleep(const struct gpio_desc *desc)
 {
 	int value;
 
+	deb_verbose("\n");
+
 	might_sleep_if(extra_checks);
 	VALIDATE_DESC(desc);
 	value = gpiod_get_raw_value_commit(desc);
@@ -3545,6 +3829,8 @@ int gpiod_get_raw_array_value_cansleep(unsigned int array_size,
 				       struct gpio_array *array_info,
 				       unsigned long *value_bitmap)
 {
+	deb_verbose("\n");
+
 	might_sleep_if(extra_checks);
 	if (!desc_array)
 		return -EINVAL;
@@ -3571,6 +3857,8 @@ int gpiod_get_array_value_cansleep(unsigned int array_size,
 				   struct gpio_array *array_info,
 				   unsigned long *value_bitmap)
 {
+	deb_verbose("\n");
+
 	might_sleep_if(extra_checks);
 	if (!desc_array)
 		return -EINVAL;
@@ -3592,6 +3880,8 @@ EXPORT_SYMBOL_GPL(gpiod_get_array_value_cansleep);
  */
 void gpiod_set_raw_value_cansleep(struct gpio_desc *desc, int value)
 {
+	deb_verbose("\n");
+
 	might_sleep_if(extra_checks);
 	VALIDATE_DESC_VOID(desc);
 	gpiod_set_raw_value_commit(desc, value);
@@ -3610,6 +3900,8 @@ EXPORT_SYMBOL_GPL(gpiod_set_raw_value_cansleep);
  */
 void gpiod_set_value_cansleep(struct gpio_desc *desc, int value)
 {
+	deb_verbose("\n");
+
 	might_sleep_if(extra_checks);
 	VALIDATE_DESC_VOID(desc);
 	gpiod_set_value_nocheck(desc, value);
@@ -3633,6 +3925,8 @@ int gpiod_set_raw_array_value_cansleep(unsigned int array_size,
 				       struct gpio_array *array_info,
 				       unsigned long *value_bitmap)
 {
+	deb_verbose("\n");
+
 	might_sleep_if(extra_checks);
 	if (!desc_array)
 		return -EINVAL;
@@ -3650,6 +3944,8 @@ void gpiod_add_lookup_tables(struct gpiod_lookup_table **tables, size_t n)
 {
 	unsigned int i;
 
+	deb_verbose("\n");
+
 	mutex_lock(&gpio_lookup_lock);
 
 	for (i = 0; i < n; i++)
@@ -3675,6 +3971,8 @@ int gpiod_set_array_value_cansleep(unsigned int array_size,
 				   struct gpio_array *array_info,
 				   unsigned long *value_bitmap)
 {
+	deb_verbose("\n");
+
 	might_sleep_if(extra_checks);
 	if (!desc_array)
 		return -EINVAL;
@@ -3690,6 +3988,8 @@ EXPORT_SYMBOL_GPL(gpiod_set_array_value_cansleep);
  */
 void gpiod_add_lookup_table(struct gpiod_lookup_table *table)
 {
+	deb_verbose("\n");
+
 	mutex_lock(&gpio_lookup_lock);
 
 	list_add_tail(&table->list, &gpio_lookup_list);
@@ -3704,6 +4004,8 @@ EXPORT_SYMBOL_GPL(gpiod_add_lookup_table);
  */
 void gpiod_remove_lookup_table(struct gpiod_lookup_table *table)
 {
+	deb_verbose("\n");
+
 	mutex_lock(&gpio_lookup_lock);
 
 	list_del(&table->list);
@@ -3721,6 +4023,8 @@ void gpiod_add_hogs(struct gpiod_hog *hogs)
 	struct gpio_chip *gc;
 	struct gpiod_hog *hog;
 
+	deb_verbose("\n");
+
 	mutex_lock(&gpio_machine_hogs_mutex);
 
 	for (hog = &hogs[0]; hog->chip_label; hog++) {
@@ -3744,6 +4048,8 @@ static struct gpiod_lookup_table *gpiod_find_lookup_table(struct device *dev)
 	const char *dev_id = dev ? dev_name(dev) : NULL;
 	struct gpiod_lookup_table *table;
 
+	deb_verbose("\n");
+
 	mutex_lock(&gpio_lookup_lock);
 
 	list_for_each_entry(table, &gpio_lookup_list, list) {
@@ -3777,6 +4083,8 @@ static struct gpio_desc *gpiod_find(struct device *dev, const char *con_id,
 	struct gpiod_lookup_table *table;
 	struct gpiod_lookup *p;
 
+	deb_verbose("\n");
+
 	table = gpiod_find_lookup_table(dev);
 	if (!table)
 		return desc;
@@ -3842,6 +4150,8 @@ static int platform_gpio_count(struct device *dev, const char *con_id)
 	struct gpiod_lookup *p;
 	unsigned int count = 0;
 
+	deb_verbose("\n");
+
 	table = gpiod_find_lookup_table(dev);
 	if (!table)
 		return -ENOENT;
@@ -3887,6 +4197,8 @@ struct gpio_desc *fwnode_gpiod_get_index(struct fwnode_handle *fwnode,
 	char prop_name[32]; /* 32 is max size of property name */
 	unsigned int i;
 
+	deb_verbose("\n");
+
 	for (i = 0; i < ARRAY_SIZE(gpio_suffixes); i++) {
 		if (con_id)
 			snprintf(prop_name, sizeof(prop_name), "%s-%s",
@@ -3915,6 +4227,8 @@ int gpiod_count(struct device *dev, const char *con_id)
 {
 	int count = -ENOENT;
 
+	deb_verbose("\n");
+
 	if (IS_ENABLED(CONFIG_OF) && dev && dev->of_node)
 		count = of_gpio_get_count(dev, con_id);
 	else if (IS_ENABLED(CONFIG_ACPI) && dev && ACPI_HANDLE(dev))
@@ -3940,6 +4254,8 @@ EXPORT_SYMBOL_GPL(gpiod_count);
 struct gpio_desc *__must_check gpiod_get(struct device *dev, const char *con_id,
 					 enum gpiod_flags flags)
 {
+	deb_verbose("\n");
+
 	return gpiod_get_index(dev, con_id, 0, flags);
 }
 EXPORT_SYMBOL_GPL(gpiod_get);
@@ -3980,6 +4296,8 @@ int gpiod_configure_flags(struct gpio_desc *desc, const char *con_id,
 {
 	int ret;
 
+	deb_verbose("\n");
+
 	if (lflags & GPIO_ACTIVE_LOW)
 		set_bit(FLAG_ACTIVE_LOW, &desc->flags);
 
@@ -4150,6 +4468,8 @@ struct gpio_desc *fwnode_get_named_gpiod(struct fwnode_handle *fwnode,
 	struct gpio_desc *desc = ERR_PTR(-ENODEV);
 	int ret;
 
+	deb_verbose("\n");
+
 	if (!fwnode)
 		return ERR_PTR(-EINVAL);
 
@@ -4207,6 +4527,8 @@ struct gpio_desc *__must_check gpiod_get_index_optional(struct device *dev,
 {
 	struct gpio_desc *desc;
 
+	deb_verbose("\n");
+
 	desc = gpiod_get_index(dev, con_id, index, flags);
 	if (IS_ERR(desc)) {
 		if (PTR_ERR(desc) == -ENOENT)
@@ -4233,6 +4555,8 @@ int gpiod_hog(struct gpio_desc *desc, const char *name,
 	int hwnum;
 	int ret;
 
+	deb_verbose("\n");
+
 	gc = gpiod_to_chip(desc);
 	hwnum = gpio_chip_hwgpio(desc);
 
@@ -4264,6 +4588,8 @@ static void gpiochip_free_hogs(struct gpio_chip *gc)
 {
 	int id;
 
+	deb_verbose("\n");
+
 	for (id = 0; id < gc->ngpio; id++) {
 		if (test_bit(FLAG_IS_HOGGED, &gc->gpiodev->descs[id].flags))
 			gpiochip_free_own_desc(&gc->gpiodev->descs[id]);
@@ -4292,6 +4618,8 @@ struct gpio_descs *__must_check gpiod_get_array(struct device *dev,
 	struct gpio_chip *gc;
 	int count, bitmap_size;
 
+	deb_verbose("\n");
+
 	count = gpiod_count(dev, con_id);
 	if (count < 0)
 		return ERR_PTR(count);
@@ -4412,6 +4740,8 @@ struct gpio_descs *__must_check gpiod_get_array_optional(struct device *dev,
 {
 	struct gpio_descs *descs;
 
+	deb_verbose("\n");
+
 	descs = gpiod_get_array(dev, con_id, flags);
 	if (PTR_ERR(descs) == -ENOENT)
 		return NULL;
@@ -4428,6 +4758,8 @@ EXPORT_SYMBOL_GPL(gpiod_get_array_optional);
  */
 void gpiod_put(struct gpio_desc *desc)
 {
+	deb_verbose("\n");
+
 	if (desc)
 		gpiod_free(desc);
 }
@@ -4441,6 +4773,8 @@ void gpiod_put_array(struct gpio_descs *descs)
 {
 	unsigned int i;
 
+	deb_verbose("\n");
+
 	for (i = 0; i < descs->ndescs; i++)
 		gpiod_put(descs->desc[i]);
 
@@ -4452,6 +4786,8 @@ static int __init gpiolib_dev_init(void)
 {
 	int ret;
 
+	deb_verbose("\n");
+
 	/* Register GPIO sysfs bus */
 	ret = bus_register(&gpio_bus_type);
 	if (ret < 0) {
diff --git a/drivers/pinctrl/core.c b/drivers/pinctrl/core.c
index c73b34e03aae..4d4aa438b147 100644
--- a/drivers/pinctrl/core.c
+++ b/drivers/pinctrl/core.c
@@ -26,16 +26,38 @@
 #include <linux/pinctrl/pinctrl.h>
 #include <linux/pinctrl/machine.h>
 
-#ifdef CONFIG_GPIOLIB
+    #ifdef CONFIG_GPIOLIB
 #include "../gpio/gpiolib.h"
 #include <asm-generic/gpio.h>
-#endif
+    #endif
 
 #include "core.h"
 #include "devicetree.h"
 #include "pinmux.h"
 #include "pinconf.h"
 
+// #define GPIO_DEBUG
+
+#ifdef GPIO_DEBUG
+  /*
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+  #define deb_error(fmt, ...)    printk(KERN_ERR "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__ , kbasename(__FILE__), ##__VA_ARGS__)
+  */
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' -- " fmt, __func__, ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' -- " fmt, __func__, ##__VA_ARGS__)
+  #define deb_error(fmt, ...)    printk(KERN_ERR "GPIO func \'%s\' -- " fmt, __func__ , ##__VA_ARGS__)
+#else
+  #define deb_info(fmt, ...)
+  #define deb_debug(fmt, ...)
+  #define deb_error(fmt, ...)
+#endif
+
+#ifdef GPIO_DEBUG_VERBOSE
+  #define deb_verbose           deb_debug
+#else
+  #define deb_verbose(fmt, ...)
+#endif
 
 static bool pinctrl_dummy_state;
 
@@ -101,6 +123,9 @@ struct pinctrl_dev *get_pinctrl_dev_from_devname(const char *devname)
 {
 	struct pinctrl_dev *pctldev;
 
+	// removed because prints too often
+	deb_verbose("\n");
+
 	if (!devname)
 		return NULL;
 
@@ -123,16 +148,20 @@ struct pinctrl_dev *get_pinctrl_dev_from_of_node(struct device_node *np)
 {
 	struct pinctrl_dev *pctldev;
 
+	// removed because it prints too often
+	deb_verbose("\n");
+
 	mutex_lock(&pinctrldev_list_mutex);
 
 	list_for_each_entry(pctldev, &pinctrldev_list, node)
 		if (pctldev->dev->of_node == np) {
+		deb_debug("comparing %p and %p", pctldev->dev->of_node, np);  // debug never prints this because we have an empty list?
 			mutex_unlock(&pinctrldev_list_mutex);
 			return pctldev;
 		}
 
 	mutex_unlock(&pinctrldev_list_mutex);
-
+	deb_debug("Error: failed to find match");
 	return NULL;
 }
 
@@ -145,6 +174,8 @@ int pin_get_from_name(struct pinctrl_dev *pctldev, const char *name)
 {
 	unsigned i, pin;
 
+	deb_debug("\n");
+
 	/* The pin number can be retrived from the pin controller descriptor */
 	for (i = 0; i < pctldev->desc->npins; i++) {
 		struct pin_desc *desc;
@@ -168,6 +199,8 @@ const char *pin_get_name(struct pinctrl_dev *pctldev, const unsigned pin)
 {
 	const struct pin_desc *desc;
 
+	deb_debug("\n");
+
 	desc = pin_desc_get(pctldev, pin);
 	if (!desc) {
 		dev_err(pctldev->dev, "failed to get pin(%d) name\n",
@@ -186,6 +219,9 @@ static void pinctrl_free_pindescs(struct pinctrl_dev *pctldev,
 {
 	int i;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	for (i = 0; i < num_pins; i++) {
 		struct pin_desc *pindesc;
 
@@ -206,6 +242,9 @@ static int pinctrl_register_one_pin(struct pinctrl_dev *pctldev,
 {
 	struct pin_desc *pindesc;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	pindesc = pin_desc_get(pctldev, pin->number);
 	if (pindesc) {
 		dev_err(pctldev->dev, "pin %d already registered\n",
@@ -247,6 +286,9 @@ static int pinctrl_register_pins(struct pinctrl_dev *pctldev,
 	unsigned i;
 	int ret = 0;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	for (i = 0; i < num_descs; i++) {
 		ret = pinctrl_register_one_pin(pctldev, &pins[i]);
 		if (ret)
@@ -273,6 +315,9 @@ static inline int gpio_to_pin(struct pinctrl_gpio_range *range,
 				unsigned int gpio)
 {
 	unsigned int offset = gpio - range->base;
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	if (range->pins)
 		return range->pins[offset];
 	else
@@ -292,6 +337,9 @@ pinctrl_match_gpio_range(struct pinctrl_dev *pctldev, unsigned gpio)
 {
 	struct pinctrl_gpio_range *range;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	mutex_lock(&pctldev->mutex);
 	/* Loop over the ranges */
 	list_for_each_entry(range, &pctldev->gpio_ranges, node) {
@@ -319,13 +367,16 @@ pinctrl_match_gpio_range(struct pinctrl_dev *pctldev, unsigned gpio)
  * certain GPIO pin doesn't have back-end pinctrl device. If the return value
  * is false, it means that pinctrl device may not be ready.
  */
-#ifdef CONFIG_GPIOLIB
+    #ifdef CONFIG_GPIOLIB
 static bool pinctrl_ready_for_gpio_range(unsigned gpio)
 {
 	struct pinctrl_dev *pctldev;
 	struct pinctrl_gpio_range *range = NULL;
 	struct gpio_chip *chip = gpio_to_chip(gpio);
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	if (WARN(!chip, "no gpio_chip for gpio%i?", gpio))
 		return false;
 
@@ -353,7 +404,7 @@ static bool pinctrl_ready_for_gpio_range(unsigned gpio)
 }
 #else
 static bool pinctrl_ready_for_gpio_range(unsigned gpio) { return true; }
-#endif
+    #endif
 
 /**
  * pinctrl_get_device_gpio_range() - find device for GPIO range
@@ -372,6 +423,9 @@ static int pinctrl_get_device_gpio_range(unsigned gpio,
 {
 	struct pinctrl_dev *pctldev;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	mutex_lock(&pinctrldev_list_mutex);
 
 	/* Loop over the pin controllers */
@@ -403,6 +457,9 @@ static int pinctrl_get_device_gpio_range(unsigned gpio,
 void pinctrl_add_gpio_range(struct pinctrl_dev *pctldev,
 			    struct pinctrl_gpio_range *range)
 {
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	mutex_lock(&pctldev->mutex);
 	list_add_tail(&range->node, &pctldev->gpio_ranges);
 	mutex_unlock(&pctldev->mutex);
@@ -415,6 +472,9 @@ void pinctrl_add_gpio_ranges(struct pinctrl_dev *pctldev,
 {
 	int i;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	for (i = 0; i < nranges; i++)
 		pinctrl_add_gpio_range(pctldev, &ranges[i]);
 }
@@ -425,6 +485,9 @@ struct pinctrl_dev *pinctrl_find_and_add_gpio_range(const char *devname,
 {
 	struct pinctrl_dev *pctldev;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	pctldev = get_pinctrl_dev_from_devname(devname);
 
 	/*
@@ -447,6 +510,9 @@ int pinctrl_get_group_pins(struct pinctrl_dev *pctldev, const char *pin_group,
 	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
 	int gs;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	if (!pctlops->get_group_pins)
 		return -EINVAL;
 
@@ -464,6 +530,9 @@ pinctrl_find_gpio_range_from_pin_nolock(struct pinctrl_dev *pctldev,
 {
 	struct pinctrl_gpio_range *range;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	/* Loop over the ranges */
 	list_for_each_entry(range, &pctldev->gpio_ranges, node) {
 		/* Check if we're in the valid range */
@@ -493,6 +562,9 @@ pinctrl_find_gpio_range_from_pin(struct pinctrl_dev *pctldev,
 {
 	struct pinctrl_gpio_range *range;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	mutex_lock(&pctldev->mutex);
 	range = pinctrl_find_gpio_range_from_pin_nolock(pctldev, pin);
 	mutex_unlock(&pctldev->mutex);
@@ -509,13 +581,16 @@ EXPORT_SYMBOL_GPL(pinctrl_find_gpio_range_from_pin);
 void pinctrl_remove_gpio_range(struct pinctrl_dev *pctldev,
 			       struct pinctrl_gpio_range *range)
 {
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	mutex_lock(&pctldev->mutex);
 	list_del(&range->node);
 	mutex_unlock(&pctldev->mutex);
 }
 EXPORT_SYMBOL_GPL(pinctrl_remove_gpio_range);
 
-#ifdef CONFIG_GENERIC_PINCTRL_GROUPS
+    #ifdef CONFIG_GENERIC_PINCTRL_GROUPS
 
 /**
  * pinctrl_generic_get_group_count() - returns the number of pin groups
@@ -537,6 +612,9 @@ const char *pinctrl_generic_get_group_name(struct pinctrl_dev *pctldev,
 {
 	struct group_desc *group;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	group = radix_tree_lookup(&pctldev->pin_group_tree,
 				  selector);
 	if (!group)
@@ -560,6 +638,9 @@ int pinctrl_generic_get_group_pins(struct pinctrl_dev *pctldev,
 {
 	struct group_desc *group;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	group = radix_tree_lookup(&pctldev->pin_group_tree,
 				  selector);
 	if (!group) {
@@ -585,6 +666,9 @@ struct group_desc *pinctrl_generic_get_group(struct pinctrl_dev *pctldev,
 {
 	struct group_desc *group;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	group = radix_tree_lookup(&pctldev->pin_group_tree,
 				  selector);
 	if (!group)
@@ -630,6 +714,9 @@ int pinctrl_generic_add_group(struct pinctrl_dev *pctldev, const char *name,
 	struct group_desc *group;
 	int selector;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	if (!name)
 		return -EINVAL;
 
@@ -668,6 +755,9 @@ int pinctrl_generic_remove_group(struct pinctrl_dev *pctldev,
 {
 	struct group_desc *group;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	group = radix_tree_lookup(&pctldev->pin_group_tree,
 				  selector);
 	if (!group)
@@ -704,8 +794,8 @@ static void pinctrl_generic_free_groups(struct pinctrl_dev *pctldev)
 static inline void pinctrl_generic_free_groups(struct pinctrl_dev *pctldev)
 {
 }
-#endif /* CONFIG_GENERIC_PINCTRL_GROUPS */
-
+    #endif /* CONFIG_GENERIC_PINCTRL_GROUPS */
+ 
 /**
  * pinctrl_get_group_selector() - returns the group selector for a group
  * @pctldev: the pin controller handling the group
@@ -718,6 +808,9 @@ int pinctrl_get_group_selector(struct pinctrl_dev *pctldev,
 	unsigned ngroups = pctlops->get_groups_count(pctldev);
 	unsigned group_selector = 0;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	while (group_selector < ngroups) {
 		const char *gname = pctlops->get_group_name(pctldev,
 							    group_selector);
@@ -745,6 +838,9 @@ bool pinctrl_gpio_can_use_line(unsigned gpio)
 	bool result;
 	int pin;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	/*
 	 * Try to obtain GPIO range, if it fails
 	 * we're probably dealing with GPIO driver
@@ -781,6 +877,9 @@ int pinctrl_gpio_request(unsigned gpio)
 	int ret;
 	int pin;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	ret = pinctrl_get_device_gpio_range(gpio, &pctldev, &range);
 	if (ret) {
 		if (pinctrl_ready_for_gpio_range(gpio))
@@ -816,6 +915,8 @@ void pinctrl_gpio_free(unsigned gpio)
 	int ret;
 	int pin;
 
+	deb_debug("\n");
+
 	ret = pinctrl_get_device_gpio_range(gpio, &pctldev, &range);
 	if (ret) {
 		return;
@@ -838,6 +939,9 @@ static int pinctrl_gpio_direction(unsigned gpio, bool input)
 	int ret;
 	int pin;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	ret = pinctrl_get_device_gpio_range(gpio, &pctldev, &range);
 	if (ret) {
 		return ret;
@@ -864,6 +968,9 @@ static int pinctrl_gpio_direction(unsigned gpio, bool input)
  */
 int pinctrl_gpio_direction_input(unsigned gpio)
 {
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	return pinctrl_gpio_direction(gpio, true);
 }
 EXPORT_SYMBOL_GPL(pinctrl_gpio_direction_input);
@@ -878,6 +985,9 @@ EXPORT_SYMBOL_GPL(pinctrl_gpio_direction_input);
  */
 int pinctrl_gpio_direction_output(unsigned gpio)
 {
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	return pinctrl_gpio_direction(gpio, false);
 }
 EXPORT_SYMBOL_GPL(pinctrl_gpio_direction_output);
@@ -898,6 +1008,8 @@ int pinctrl_gpio_set_config(unsigned gpio, unsigned long config)
 	struct pinctrl_dev *pctldev;
 	int ret, pin;
 
+	deb_debug("\n");
+
 	ret = pinctrl_get_device_gpio_range(gpio, &pctldev, &range);
 	if (ret)
 		return ret;
@@ -916,6 +1028,9 @@ static struct pinctrl_state *find_state(struct pinctrl *p,
 {
 	struct pinctrl_state *state;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	list_for_each_entry(state, &p->states, node)
 		if (!strcmp(state->name, name))
 			return state;
@@ -928,6 +1043,9 @@ static struct pinctrl_state *create_state(struct pinctrl *p,
 {
 	struct pinctrl_state *state;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	state = kzalloc(sizeof(*state), GFP_KERNEL);
 	if (!state)
 		return ERR_PTR(-ENOMEM);
@@ -947,6 +1065,9 @@ static int add_setting(struct pinctrl *p, struct pinctrl_dev *pctldev,
 	struct pinctrl_setting *setting;
 	int ret;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	state = find_state(p, map->name);
 	if (!state)
 		state = create_state(p, map->name);
@@ -1009,6 +1130,9 @@ static struct pinctrl *find_pinctrl(struct device *dev)
 {
 	struct pinctrl *p;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	mutex_lock(&pinctrl_list_mutex);
 	list_for_each_entry(p, &pinctrl_list, node)
 		if (p->dev == dev) {
@@ -1032,6 +1156,9 @@ static struct pinctrl *create_pinctrl(struct device *dev,
 	const struct pinctrl_map *map;
 	int ret;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	/*
 	 * create the state cookie holder struct pinctrl for each
 	 * mapping, this is what consumers will get when requesting
@@ -1115,6 +1242,9 @@ struct pinctrl *pinctrl_get(struct device *dev)
 {
 	struct pinctrl *p;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	if (WARN_ON(!dev))
 		return ERR_PTR(-EINVAL);
 
@@ -1137,6 +1267,9 @@ EXPORT_SYMBOL_GPL(pinctrl_get);
 static void pinctrl_free_setting(bool disable_setting,
 				 struct pinctrl_setting *setting)
 {
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	switch (setting->type) {
 	case PIN_MAP_TYPE_MUX_GROUP:
 		if (disable_setting)
@@ -1157,6 +1290,9 @@ static void pinctrl_free(struct pinctrl *p, bool inlist)
 	struct pinctrl_state *state, *n1;
 	struct pinctrl_setting *setting, *n2;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	mutex_lock(&pinctrl_list_mutex);
 	list_for_each_entry_safe(state, n1, &p->states, node) {
 		list_for_each_entry_safe(setting, n2, &state->settings, node) {
@@ -1184,6 +1320,9 @@ static void pinctrl_release(struct kref *kref)
 {
 	struct pinctrl *p = container_of(kref, struct pinctrl, users);
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	pinctrl_free(p, true);
 }
 
@@ -1193,6 +1332,9 @@ static void pinctrl_release(struct kref *kref)
  */
 void pinctrl_put(struct pinctrl *p)
 {
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	kref_put(&p->users, pinctrl_release);
 }
 EXPORT_SYMBOL_GPL(pinctrl_put);
@@ -1207,6 +1349,9 @@ struct pinctrl_state *pinctrl_lookup_state(struct pinctrl *p,
 {
 	struct pinctrl_state *state;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	state = find_state(p, name);
 	if (!state) {
 		if (pinctrl_dummy_state) {
@@ -1225,6 +1370,9 @@ EXPORT_SYMBOL_GPL(pinctrl_lookup_state);
 static void pinctrl_link_add(struct pinctrl_dev *pctldev,
 			     struct device *consumer)
 {
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	if (pctldev->desc->link_consumers)
 		device_link_add(consumer, pctldev->dev,
 				DL_FLAG_PM_RUNTIME |
@@ -1242,6 +1390,9 @@ static int pinctrl_commit_state(struct pinctrl *p, struct pinctrl_state *state)
 	struct pinctrl_state *old_state = p->state;
 	int ret;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	if (p->state) {
 		/*
 		 * For each pinmux setting in the old state, forget SW's record
@@ -1289,6 +1440,8 @@ static int pinctrl_commit_state(struct pinctrl *p, struct pinctrl_state *state)
 unapply_new_state:
 	dev_err(p->dev, "Error applying setting, reverse things back\n");
 
+	deb_debug("\n");
+
 	list_for_each_entry(setting2, &state->settings, node) {
 		if (&setting2->node == &setting->node)
 			break;
@@ -1317,6 +1470,9 @@ static int pinctrl_commit_state(struct pinctrl *p, struct pinctrl_state *state)
  */
 int pinctrl_select_state(struct pinctrl *p, struct pinctrl_state *state)
 {
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	if (p->state == state)
 		return 0;
 
@@ -1340,6 +1496,9 @@ struct pinctrl *devm_pinctrl_get(struct device *dev)
 {
 	struct pinctrl **ptr, *p;
 
+	// printk removed because it triggers far to often
+	deb_verbose("\n");
+
 	ptr = devres_alloc(devm_pinctrl_release, sizeof(*ptr), GFP_KERNEL);
 	if (!ptr)
 		return ERR_PTR(-ENOMEM);
@@ -1360,6 +1519,9 @@ static int devm_pinctrl_match(struct device *dev, void *res, void *data)
 {
 	struct pinctrl **p = res;
 
+	// printk removed because it triggers far to often
+	deb_verbose("\n");
+
 	return *p == data;
 }
 
@@ -1373,6 +1535,9 @@ static int devm_pinctrl_match(struct device *dev, void *res, void *data)
  */
 void devm_pinctrl_put(struct pinctrl *p)
 {
+	// printk removed because it triggers far to often
+	deb_verbose("\n");
+
 	WARN_ON(devres_release(p->dev, devm_pinctrl_release,
 			       devm_pinctrl_match, p));
 }
@@ -1391,6 +1556,8 @@ int pinctrl_register_mappings(const struct pinctrl_map *maps,
 	int i, ret;
 	struct pinctrl_maps *maps_node;
 
+	deb_debug("\n");
+
 	pr_debug("add %u pinctrl maps\n", num_maps);
 
 	/* First sanity check the new mapping */
@@ -1459,6 +1626,8 @@ void pinctrl_unregister_mappings(const struct pinctrl_map *map)
 {
 	struct pinctrl_maps *maps_node;
 
+	deb_debug("\n");
+
 	mutex_lock(&pinctrl_maps_mutex);
 	list_for_each_entry(maps_node, &pinctrl_maps, node) {
 		if (maps_node->maps == map) {
@@ -1478,6 +1647,8 @@ EXPORT_SYMBOL_GPL(pinctrl_unregister_mappings);
  */
 int pinctrl_force_sleep(struct pinctrl_dev *pctldev)
 {
+	deb_debug("\n");
+
 	if (!IS_ERR(pctldev->p) && !IS_ERR(pctldev->hog_sleep))
 		return pinctrl_commit_state(pctldev->p, pctldev->hog_sleep);
 	return 0;
@@ -1490,6 +1661,8 @@ EXPORT_SYMBOL_GPL(pinctrl_force_sleep);
  */
 int pinctrl_force_default(struct pinctrl_dev *pctldev)
 {
+	deb_debug("\n");
+
 	if (!IS_ERR(pctldev->p) && !IS_ERR(pctldev->hog_default))
 		return pinctrl_commit_state(pctldev->p, pctldev->hog_default);
 	return 0;
@@ -1509,6 +1682,9 @@ int pinctrl_init_done(struct device *dev)
 	struct dev_pin_info *pins = dev->pins;
 	int ret;
 
+	// printk removed because it triggers far to often
+	deb_verbose("\n");
+
 	if (!pins)
 		return 0;
 
@@ -1534,6 +1710,9 @@ static int pinctrl_select_bound_state(struct device *dev,
 	struct dev_pin_info *pins = dev->pins;
 	int ret;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	if (IS_ERR(state))
 		return 0; /* No such state */
 	ret = pinctrl_select_state(pins->p, state);
@@ -1549,6 +1728,9 @@ static int pinctrl_select_bound_state(struct device *dev,
  */
 int pinctrl_select_default_state(struct device *dev)
 {
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	if (!dev->pins)
 		return 0;
 
@@ -1556,7 +1738,7 @@ int pinctrl_select_default_state(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(pinctrl_select_default_state);
 
-#ifdef CONFIG_PM
+    #ifdef CONFIG_PM
 
 /**
  * pinctrl_pm_select_default_state() - select default pinctrl state for PM
@@ -1564,6 +1746,9 @@ EXPORT_SYMBOL_GPL(pinctrl_select_default_state);
  */
 int pinctrl_pm_select_default_state(struct device *dev)
 {
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	return pinctrl_select_default_state(dev);
 }
 EXPORT_SYMBOL_GPL(pinctrl_pm_select_default_state);
@@ -1587,26 +1772,32 @@ EXPORT_SYMBOL_GPL(pinctrl_pm_select_sleep_state);
  */
 int pinctrl_pm_select_idle_state(struct device *dev)
 {
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	if (!dev->pins)
 		return 0;
 
 	return pinctrl_select_bound_state(dev, dev->pins->idle_state);
 }
 EXPORT_SYMBOL_GPL(pinctrl_pm_select_idle_state);
-#endif
+    #endif
 
-#ifdef CONFIG_DEBUG_FS
+    #ifdef CONFIG_DEBUG_FS
 
 static int pinctrl_pins_show(struct seq_file *s, void *what)
 {
 	struct pinctrl_dev *pctldev = s->private;
 	const struct pinctrl_ops *ops = pctldev->desc->pctlops;
 	unsigned i, pin;
-#ifdef CONFIG_GPIOLIB
+    #ifdef CONFIG_GPIOLIB
 	struct pinctrl_gpio_range *range;
 	struct gpio_chip *chip;
 	int gpio_num;
-#endif
+    #endif
+
+	// removed because it triggers far too often
+	deb_verbose("\n");
 
 	seq_printf(s, "registered pins: %d\n", pctldev->desc->npins);
 
@@ -1624,7 +1815,7 @@ static int pinctrl_pins_show(struct seq_file *s, void *what)
 
 		seq_printf(s, "pin %d (%s) ", pin, desc->name);
 
-#ifdef CONFIG_GPIOLIB
+    #ifdef CONFIG_GPIOLIB
 		gpio_num = -1;
 		list_for_each_entry(range, &pctldev->gpio_ranges, node) {
 			if ((pin >= range->pin_base) &&
@@ -1641,7 +1832,7 @@ static int pinctrl_pins_show(struct seq_file *s, void *what)
 			seq_printf(s, "%u:%s ", gpio_num - chip->gpiodev->base, chip->label);
 		else
 			seq_puts(s, "0:? ");
-#endif
+    #endif
 
 		/* Driver-specific info per pin */
 		if (ops->pin_dbg_show)
@@ -1662,6 +1853,9 @@ static int pinctrl_groups_show(struct seq_file *s, void *what)
 	const struct pinctrl_ops *ops = pctldev->desc->pctlops;
 	unsigned ngroups, selector = 0;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	mutex_lock(&pctldev->mutex);
 
 	ngroups = ops->get_groups_count(pctldev);
@@ -1707,6 +1901,8 @@ static int pinctrl_gpioranges_show(struct seq_file *s, void *what)
 	struct pinctrl_dev *pctldev = s->private;
 	struct pinctrl_gpio_range *range;
 
+	deb_debug("\n");
+
 	seq_puts(s, "GPIO ranges handled:\n");
 
 	mutex_lock(&pctldev->mutex);
@@ -1740,6 +1936,8 @@ static int pinctrl_devices_show(struct seq_file *s, void *what)
 {
 	struct pinctrl_dev *pctldev;
 
+	deb_debug("\n");
+
 	seq_puts(s, "name [pinmux] [pinconf]\n");
 
 	mutex_lock(&pinctrldev_list_mutex);
@@ -1773,6 +1971,8 @@ static inline const char *map_type(enum pinctrl_map_type type)
 		"CONFIGS_GROUP",
 	};
 
+	deb_debug("\n");
+
 	if (type >= ARRAY_SIZE(names))
 		return "UNKNOWN";
 
@@ -1785,6 +1985,8 @@ static int pinctrl_maps_show(struct seq_file *s, void *what)
 	int i;
 	const struct pinctrl_map *map;
 
+	deb_debug("\n");
+
 	seq_puts(s, "Pinctrl maps:\n");
 
 	mutex_lock(&pinctrl_maps_mutex);
@@ -1823,6 +2025,8 @@ static int pinctrl_show(struct seq_file *s, void *what)
 	struct pinctrl_state *state;
 	struct pinctrl_setting *setting;
 
+	deb_debug("\n");
+
 	seq_puts(s, "Requested pin control handlers their pinmux maps:\n");
 
 	mutex_lock(&pinctrl_list_mutex);
@@ -1870,6 +2074,9 @@ static void pinctrl_init_device_debugfs(struct pinctrl_dev *pctldev)
 	struct dentry *device_root;
 	const char *debugfs_name;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	if (pctldev->desc->name &&
 			strcmp(dev_name(pctldev->dev), pctldev->desc->name)) {
 		debugfs_name = devm_kasprintf(pctldev->dev, GFP_KERNEL,
@@ -1906,11 +2113,15 @@ static void pinctrl_init_device_debugfs(struct pinctrl_dev *pctldev)
 
 static void pinctrl_remove_device_debugfs(struct pinctrl_dev *pctldev)
 {
+	deb_debug("\n");
+
 	debugfs_remove_recursive(pctldev->device_root);
 }
 
 static void pinctrl_init_debugfs(void)
 {
+	deb_debug("\n");
+
 	debugfs_root = debugfs_create_dir("pinctrl", NULL);
 	if (IS_ERR(debugfs_root) || !debugfs_root) {
 		pr_warn("failed to create debugfs directory\n");
@@ -1930,22 +2141,30 @@ static void pinctrl_init_debugfs(void)
 
 static void pinctrl_init_device_debugfs(struct pinctrl_dev *pctldev)
 {
+	deb_debug("\n");
+
 }
 
 static void pinctrl_init_debugfs(void)
 {
+	deb_debug("\n");
+
 }
 
 static void pinctrl_remove_device_debugfs(struct pinctrl_dev *pctldev)
 {
-}
+	deb_debug("\n");
 
-#endif
+}
+    #endif
 
 static int pinctrl_check_ops(struct pinctrl_dev *pctldev)
 {
 	const struct pinctrl_ops *ops = pctldev->desc->pctlops;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	if (!ops ||
 	    !ops->get_groups_count ||
 	    !ops->get_group_name)
@@ -1967,6 +2186,8 @@ pinctrl_init_controller(struct pinctrl_desc *pctldesc, struct device *dev,
 	struct pinctrl_dev *pctldev;
 	int ret;
 
+	deb_debug("\n");
+
 	if (!pctldesc)
 		return ERR_PTR(-EINVAL);
 	if (!pctldesc->name)
@@ -1981,12 +2202,12 @@ pinctrl_init_controller(struct pinctrl_desc *pctldesc, struct device *dev,
 	pctldev->desc = pctldesc;
 	pctldev->driver_data = driver_data;
 	INIT_RADIX_TREE(&pctldev->pin_desc_tree, GFP_KERNEL);
-#ifdef CONFIG_GENERIC_PINCTRL_GROUPS
+    #ifdef CONFIG_GENERIC_PINCTRL_GROUPS
 	INIT_RADIX_TREE(&pctldev->pin_group_tree, GFP_KERNEL);
-#endif
-#ifdef CONFIG_GENERIC_PINMUX_FUNCTIONS
+    #endif
+    #ifdef CONFIG_GENERIC_PINMUX_FUNCTIONS
 	INIT_RADIX_TREE(&pctldev->pin_function_tree, GFP_KERNEL);
-#endif
+	#endif
 	INIT_LIST_HEAD(&pctldev->gpio_ranges);
 	INIT_LIST_HEAD(&pctldev->node);
 	pctldev->dev = dev;
@@ -2033,6 +2254,9 @@ pinctrl_init_controller(struct pinctrl_desc *pctldesc, struct device *dev,
 
 static int pinctrl_claim_hogs(struct pinctrl_dev *pctldev)
 {
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	pctldev->p = create_pinctrl(pctldev->dev, pctldev);
 	if (PTR_ERR(pctldev->p) == -ENODEV) {
 		dev_dbg(pctldev->dev, "no hogs found\n");
@@ -2073,6 +2297,8 @@ int pinctrl_enable(struct pinctrl_dev *pctldev)
 {
 	int error;
 
+	deb_debug("\n");
+
 	error = pinctrl_claim_hogs(pctldev);
 	if (error) {
 		dev_err(pctldev->dev, "could not claim hogs: %i\n",
@@ -2112,6 +2338,8 @@ struct pinctrl_dev *pinctrl_register(struct pinctrl_desc *pctldesc,
 	struct pinctrl_dev *pctldev;
 	int error;
 
+	deb_debug("\n");
+
 	pctldev = pinctrl_init_controller(pctldesc, dev, driver_data);
 	if (IS_ERR(pctldev))
 		return pctldev;
@@ -2140,6 +2368,8 @@ int pinctrl_register_and_init(struct pinctrl_desc *pctldesc,
 {
 	struct pinctrl_dev *p;
 
+	deb_debug("\n");
+
 	p = pinctrl_init_controller(pctldesc, dev, driver_data);
 	if (IS_ERR(p))
 		return PTR_ERR(p);
@@ -2166,6 +2396,8 @@ void pinctrl_unregister(struct pinctrl_dev *pctldev)
 {
 	struct pinctrl_gpio_range *range, *n;
 
+	deb_debug("\n");
+
 	if (!pctldev)
 		return;
 
@@ -2200,6 +2432,8 @@ static void devm_pinctrl_dev_release(struct device *dev, void *res)
 {
 	struct pinctrl_dev *pctldev = *(struct pinctrl_dev **)res;
 
+	deb_debug("\n");
+
 	pinctrl_unregister(pctldev);
 }
 
@@ -2207,6 +2441,8 @@ static int devm_pinctrl_dev_match(struct device *dev, void *res, void *data)
 {
 	struct pctldev **r = res;
 
+	deb_debug("\n");
+
 	if (WARN_ON(!r || !*r))
 		return 0;
 
@@ -2230,6 +2466,9 @@ struct pinctrl_dev *devm_pinctrl_register(struct device *dev,
 {
 	struct pinctrl_dev **ptr, *pctldev;
 
+	// removed because it triggers far too often
+	deb_verbose("\n");
+
 	ptr = devres_alloc(devm_pinctrl_dev_release, sizeof(*ptr), GFP_KERNEL);
 	if (!ptr)
 		return ERR_PTR(-ENOMEM);
@@ -2266,6 +2505,8 @@ int devm_pinctrl_register_and_init(struct device *dev,
 	struct pinctrl_dev **ptr;
 	int error;
 
+	deb_debug("\n");
+
 	ptr = devres_alloc(devm_pinctrl_dev_release, sizeof(*ptr), GFP_KERNEL);
 	if (!ptr)
 		return -ENOMEM;
@@ -2290,6 +2531,8 @@ EXPORT_SYMBOL_GPL(devm_pinctrl_register_and_init);
  */
 void devm_pinctrl_unregister(struct device *dev, struct pinctrl_dev *pctldev)
 {
+	deb_debug("\n");
+
 	WARN_ON(devres_release(dev, devm_pinctrl_dev_release,
 			       devm_pinctrl_dev_match, pctldev));
 }
@@ -2297,6 +2540,8 @@ EXPORT_SYMBOL_GPL(devm_pinctrl_unregister);
 
 static int __init pinctrl_init(void)
 {
+	deb_debug("\n");
+
 	pr_info("initialized pinctrl subsystem\n");
 	pinctrl_init_debugfs();
 	return 0;
diff --git a/drivers/pinctrl/tegra/pinctrl-tegra.c b/drivers/pinctrl/tegra/pinctrl-tegra.c
index f9ecbebe6442..99e22809aab6 100644
--- a/drivers/pinctrl/tegra/pinctrl-tegra.c
+++ b/drivers/pinctrl/tegra/pinctrl-tegra.c
@@ -34,14 +34,73 @@
 #define EMMC_DPD_PARKING(x)		(x << EMMC_PARKING_BIT)
 #define EMMC_PARKING_SET		0x1FFF
 
+// #define GPIO_DEBUG
+// #define GPIO_DEBUG_VERBOSE
+// #define GPIO_DEBUG_EXCEPTIONS
+
+// Compiler error directive
+#if defined(GPIO_DEBUG_EXCEPTIONS) && \
+    !(defined(CONFIG_TEGRA_GPIO_GUEST_PROXY) || defined(CONFIG_TEGRA_GPIO_HOST_PROXY))
+    #error "GPIO_DEBUG_EXCEPTIONS is defined, but neither CONFIG_TEGRA_GPIO_GUEST_PROXY nor CONFIG_TEGRA_GPIO_HOST_PROXY is defined."
+#endif
+
+#ifdef GPIO_DEBUG
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+#else
+  #define deb_info(fmt, ...)
+  #define deb_debug(fmt, ...)
+#endif
+
+#ifdef GPIO_DEBUG_VERBOSE
+  #define deb_verbose           deb_debug
+#else
+  #define deb_verbose(fmt, ...)
+#endif
+
+#define GPIO_NOPT_TEST0 0 
+
+// continuing in second part of second section (third byte)
+#define TEST_OFFSET      8
+// third byte (offset starts at second byte)
+#define GPIO_NOPT_TEST8  8+TEST_OFFSET      // tegra_pinctrl_set_mux
+#define GPIO_NOPT_TEST9  9+TEST_OFFSET      // tegra_pinctrl_gpio_save_config
+#define GPIO_NOPT_TEST10 10+TEST_OFFSET     // tegra_pinctrl_gpio_restore_config
+#define GPIO_NOPT_TEST11 11+TEST_OFFSET     // tegra_pinctrl_gpio_request_enable
+#define GPIO_NOPT_TEST12 12+TEST_OFFSET     // tegra_pinctrl_gpio_set_input
+#define GPIO_NOPT_TEST13 13+TEST_OFFSET     // tegra_pinctrl_gpio_set_tristate
+#define GPIO_NOPT_TEST14 14+TEST_OFFSET     // tegra_pinconf_group_set
+#define GPIO_NOPT_TEST15 15+TEST_OFFSET     // tegra_pinctrl_clear_parked_bits
+// in fourth byte
+#define GPIO_NOPT_TEST16 16+TEST_OFFSET     // tegra_pinctrl_resume
+
+#if defined(CONFIG_TEGRA_GPIO_GUEST_PROXY) || defined(CONFIG_TEGRA_GPIO_HOST_PROXY)
+#include <gpio-proxy.h>  // low level hooks for readl_x and writel_x
+#endif // CONFIG_TEGRA_GPIO_GUEST_PROXY and CONFIG_TEGRA_GPIO_HOST_PROXY
+
 static inline u32 pmx_readl(struct tegra_pmx *pmx, u32 bank, u32 reg)
 {
+	deb_debug("\n");
+
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+	if (!is_debug_exception(GPIO_NOPT_TEST0))
+		return readl_x(pmx->regs[bank] + reg);
+	else
+	#endif
 	return readl(pmx->regs[bank] + reg);
 }
 
 static inline void pmx_writel(struct tegra_pmx *pmx, u32 val, u32 bank, u32 reg)
 {
+	deb_debug("\n");
+
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+	if (!is_debug_exception(GPIO_NOPT_TEST0))
+	writel_relaxed_x(val, pmx->regs[bank] + reg);
+	else
+	#endif
 	writel_relaxed(val, pmx->regs[bank] + reg);
+
 	/* make sure pinmux register write completed */
 	pmx_readl(pmx, bank, reg);
 }
@@ -50,6 +109,8 @@ static int tegra_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)
 {
 	struct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);
 
+	// deb_debug("\n");
+
 	return pmx->soc->ngroups;
 }
 
@@ -58,6 +119,8 @@ static const char *tegra_pinctrl_get_group_name(struct pinctrl_dev *pctldev,
 {
 	struct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);
 
+	// deb_debug("\n");
+
 	return pmx->soc->groups[group].name;
 }
 
@@ -68,20 +131,24 @@ static int tegra_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,
 {
 	struct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);
 
+	// deb_debug("\n");
+
 	*pins = pmx->soc->groups[group].pins;
 	*num_pins = pmx->soc->groups[group].npins;
 
 	return 0;
 }
 
-#ifdef CONFIG_DEBUG_FS
+	#ifdef CONFIG_DEBUG_FS
 static void tegra_pinctrl_pin_dbg_show(struct pinctrl_dev *pctldev,
 				       struct seq_file *s,
 				       unsigned offset)
 {
+	// deb_debug("\n");
+
 	seq_printf(s, " %s", dev_name(pctldev->dev));
 }
-#endif
+       #endif
 
 static const struct cfg_param {
 	const char *property;
@@ -125,6 +192,8 @@ static int tegra_pinctrl_dt_subnode_to_map(struct pinctrl_dev *pctldev,
 	struct property *prop;
 	const char *group;
 
+	deb_debug("\n");
+
 	ret = of_property_read_string(np, "nvidia,function", &function);
 	if (ret < 0) {
 		/* EINVAL=missing, which is fine since it's optional */
@@ -201,6 +270,8 @@ static int tegra_pinctrl_dt_node_to_map(struct pinctrl_dev *pctldev,
 	struct device_node *np;
 	int ret;
 
+	deb_debug("\n");
+
 	reserved_maps = 0;
 	*map = NULL;
 	*num_maps = 0;
@@ -234,6 +305,8 @@ static int tegra_pinctrl_get_funcs_count(struct pinctrl_dev *pctldev)
 {
 	struct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);
 
+	deb_debug("\n");
+
 	return pmx->soc->nfunctions;
 }
 
@@ -242,6 +315,8 @@ static const char *tegra_pinctrl_get_func_name(struct pinctrl_dev *pctldev,
 {
 	struct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);
 
+	// deb_debug("\n");
+
 	return pmx->soc->functions[function].name;
 }
 
@@ -252,6 +327,8 @@ static int tegra_pinctrl_get_func_groups(struct pinctrl_dev *pctldev,
 {
 	struct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);
 
+	// deb_debug("\n");
+
 	*groups = pmx->soc->functions[function].groups;
 	*num_groups = pmx->soc->functions[function].ngroups;
 
@@ -267,6 +344,14 @@ static int tegra_pinctrl_set_mux(struct pinctrl_dev *pctldev,
 	int i;
 	u32 val;
 
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+	bool stash = kernel_is_on_guest;
+        if(kernel_is_on_guest && is_debug_exception(GPIO_NOPT_TEST8))
+	#endif
+          kernel_is_on_guest = false; // tmp value for this function
+          
+	// deb_debug("GPIO %s, device %s\n", pmx->dev->init_name);
+
 	g = &pmx->soc->groups[group];
 
 	if (WARN_ON(g->mux_reg < 0))
@@ -287,6 +372,9 @@ static int tegra_pinctrl_set_mux(struct pinctrl_dev *pctldev,
                 val |= (1 << g->sfsel_bit);
 	pmx_writel(pmx, val, g->mux_bank, g->mux_reg);
 
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+	kernel_is_on_guest = stash;
+	#endif // CONFIG_TEGRA_GPIO_GUEST_PROXY CONFIG_TEGRA_GPIO_HOST_PROXY     
 	return 0;
 }
 
@@ -300,6 +388,14 @@ static int tegra_pinctrl_gpio_save_config(struct pinctrl_dev *pctldev,
 	const unsigned *pins;
 	int ret;
 
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+	bool stash = kernel_is_on_guest;
+        if(kernel_is_on_guest && is_debug_exception(GPIO_NOPT_TEST9))
+	#endif
+          kernel_is_on_guest = false; // tmp value for this function  
+	
+	deb_debug("device %s\n", pmx->dev->init_name);
+	
 	for (group = 0; group < pmx->soc->ngroups; ++group) {
 		ret = tegra_pinctrl_get_group_pins(pctldev, group, &pins, &num_pins);
 		if (ret < 0 || num_pins != 1)
@@ -317,6 +413,9 @@ static int tegra_pinctrl_gpio_save_config(struct pinctrl_dev *pctldev,
 	if (g->mux_reg >= 0)
 		pmx->gpio_conf[offset] = pmx_readl(pmx, g->mux_bank, g->mux_reg);
 
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+	kernel_is_on_guest = stash;
+	#endif
 	return 0;
 }
 
@@ -330,6 +429,14 @@ static int tegra_pinctrl_gpio_restore_config(struct pinctrl_dev *pctldev,
 	const unsigned *pins;
 	int ret;
 
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+	bool stash = kernel_is_on_guest; 
+        if(kernel_is_on_guest && is_debug_exception(GPIO_NOPT_TEST10))
+	#endif
+          kernel_is_on_guest = false; // tmp value for this function
+
+	deb_debug("device %s\n", pmx->dev->init_name);
+
 	for (group = 0; group < pmx->soc->ngroups; ++group) {
 		ret = tegra_pinctrl_get_group_pins(pctldev, group, &pins, &num_pins);
 		if (ret < 0 || num_pins != 1)
@@ -347,6 +454,9 @@ static int tegra_pinctrl_gpio_restore_config(struct pinctrl_dev *pctldev,
 	if (g->mux_reg >= 0)
 		pmx_writel(pmx, pmx->gpio_conf[offset], g->mux_bank, g->mux_reg);
 
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+	kernel_is_on_guest = stash;
+	#endif
 	return 0;
 }
 
@@ -358,6 +468,8 @@ static const struct tegra_pingroup *tegra_pinctrl_get_group(struct pinctrl_dev *
        const unsigned int *pins;
        int ret;
 
+	deb_debug("\n");
+
        for (group = 0; group < pmx->soc->ngroups; ++group) {
                ret = tegra_pinctrl_get_group_pins(pctldev, group, &pins, &num_pins);
                if (ret < 0)
@@ -384,6 +496,14 @@ static int tegra_pinctrl_gpio_request_enable(struct pinctrl_dev *pctldev,
 	u32 value;
 	int ret;
 
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+	bool stash = kernel_is_on_guest; 
+        if(kernel_is_on_guest && is_debug_exception(GPIO_NOPT_TEST11))
+	#endif
+          kernel_is_on_guest = false; // tmp value for this function
+
+	deb_debug("device %s\n", pmx->dev->init_name);
+
 	ret = tegra_pinctrl_gpio_save_config(pctldev, range, offset);
 	if (ret)
 		return ret;
@@ -409,6 +529,9 @@ static int tegra_pinctrl_gpio_request_enable(struct pinctrl_dev *pctldev,
 	value &= ~BIT(g->sfsel_bit);
 	pmx_writel(pmx, value, g->mux_bank, g->mux_reg);
 
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+	kernel_is_on_guest = stash;
+	#endif
 	return 0;
 }
 
@@ -416,6 +539,8 @@ static void tegra_pinctrl_gpio_disable_free(struct pinctrl_dev *pctldev,
 					    struct pinctrl_gpio_range *range,
 					    unsigned int offset)
 {
+	deb_debug("\n");
+
 	tegra_pinctrl_gpio_restore_config(pctldev, range, offset);
 }
 
@@ -425,6 +550,14 @@ static int tegra_pinctrl_gpio_set_input(struct tegra_pmx *pmx,
 {
 	u32 value;
 
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+	bool stash = kernel_is_on_guest; 
+        if(kernel_is_on_guest && is_debug_exception(GPIO_NOPT_TEST12))
+	#endif
+          kernel_is_on_guest = false; // tmp value for this function
+
+	deb_debug("\n");
+
 	if (group->einput_bit < 0)
 		return 0;
 
@@ -440,6 +573,9 @@ static int tegra_pinctrl_gpio_set_input(struct tegra_pmx *pmx,
 
 	pmx_writel(pmx, value, group->mux_bank, group->mux_reg);
 
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+	kernel_is_on_guest = stash;
+	#endif
 	return 0;
 }
 
@@ -449,6 +585,14 @@ static int tegra_pinctrl_gpio_set_tristate(struct tegra_pmx *pmx,
 {
 	u32 value;
 
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+	bool stash = kernel_is_on_guest;	 
+        if(kernel_is_on_guest && is_debug_exception(GPIO_NOPT_TEST13))
+	#endif
+          kernel_is_on_guest = false; // tmp value for this function
+
+	deb_debug("\n");
+
 	if (group->tri_bank < 0 || group->tri_reg < 0 || group->tri_bit < 0)
 		return -EINVAL;
 
@@ -461,6 +605,9 @@ static int tegra_pinctrl_gpio_set_tristate(struct tegra_pmx *pmx,
 
 	pmx_writel(pmx, value, group->tri_bank, group->tri_reg);
 
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+	kernel_is_on_guest = stash;
+	#endif
 	return 0;
 }
 
@@ -472,6 +619,8 @@ static int tegra_pinctrl_gpio_set_direction(struct pinctrl_dev *pctldev,
 	const struct tegra_pingroup *group;
 	int ret;
 
+	deb_debug("Offset=%d\n", offset);
+
 	group = tegra_pinctrl_get_group(pctldev, offset);
 	if (!group)
 		return -EINVAL;
@@ -507,6 +656,8 @@ static int tegra_pinconf_reg(struct tegra_pmx *pmx,
 			     bool report_err,
 			     s8 *bank, s32 *reg, s8 *bit, s8 *width)
 {
+	deb_debug("\n");
+
 	switch (param) {
 	case TEGRA_PINCONF_PARAM_PULL:
 		*bank = g->pupd_bank;
@@ -661,6 +812,7 @@ static int tegra_pinconf_reg(struct tegra_pmx *pmx,
 static int tegra_pinconf_get(struct pinctrl_dev *pctldev,
 			     unsigned pin, unsigned long *config)
 {
+	deb_debug("\n");
 	dev_err(pctldev->dev, "pin_config_get op not supported\n");
 	return -ENOTSUPP;
 }
@@ -669,6 +821,7 @@ static int tegra_pinconf_set(struct pinctrl_dev *pctldev,
 			     unsigned pin, unsigned long *configs,
 			     unsigned num_configs)
 {
+	deb_debug("\n");
 	dev_err(pctldev->dev, "pin_config_set op not supported\n");
 	return -ENOTSUPP;
 }
@@ -685,6 +838,8 @@ static int tegra_pinconf_group_get(struct pinctrl_dev *pctldev,
 	s32 reg;
 	u32 val, mask;
 
+	deb_debug("\n");
+
 	g = &pmx->soc->groups[group];
 
 	ret = tegra_pinconf_reg(pmx, g, param, true, &bank, &reg, &bit,
@@ -717,6 +872,13 @@ static int tegra_pinconf_group_set(struct pinctrl_dev *pctldev,
 	s8 bank, bit, width;
 	s32 reg;
 	u32 val, mask;
+	
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+	bool stash = kernel_is_on_guest;
+        if(kernel_is_on_guest && is_debug_exception(GPIO_NOPT_TEST14))
+	#endif
+          kernel_is_on_guest = false; // tmp value for this function
+	deb_debug("\n");
 
 	g = &pmx->soc->groups[group];
 
@@ -762,18 +924,23 @@ static int tegra_pinconf_group_set(struct pinctrl_dev *pctldev,
 		pmx_writel(pmx, val, bank, reg);
 	} /* for each config */
 
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+	kernel_is_on_guest = stash;
+	#endif
 	return 0;
 }
 
-#ifdef CONFIG_DEBUG_FS
+	#ifdef CONFIG_DEBUG_FS
 static void tegra_pinconf_dbg_show(struct pinctrl_dev *pctldev,
 				   struct seq_file *s, unsigned offset)
 {
+	deb_debug("\n");
 }
 
 static const char *strip_prefix(const char *s)
 {
 	const char *comma = strchr(s, ',');
+	deb_debug("\n");
 	if (!comma)
 		return s;
 
@@ -791,6 +958,8 @@ static void tegra_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,
 	u32 val;
 	u8 idx;
 
+	deb_debug("\n");
+
 	g = &pmx->soc->groups[group];
 
 	for (i = 0; i < ARRAY_SIZE(cfg_params); i++) {
@@ -823,6 +992,8 @@ static void tegra_pinconf_config_dbg_show(struct pinctrl_dev *pctldev,
 	const char *pname = "unknown";
 	int i;
 
+	deb_debug("\n");
+
 	for (i = 0; i < ARRAY_SIZE(cfg_params); i++) {
 		if (cfg_params[i].param == param) {
 			pname = cfg_params[i].property;
@@ -832,7 +1003,7 @@ static void tegra_pinconf_config_dbg_show(struct pinctrl_dev *pctldev,
 
 	seq_printf(s, "%s=%d", strip_prefix(pname), arg);
 }
-#endif
+    #endif
 
 static const struct pinconf_ops tegra_pinconf_ops = {
 	.pin_config_get = tegra_pinconf_get,
@@ -865,6 +1036,14 @@ static void tegra_pinctrl_clear_parked_bits(struct tegra_pmx *pmx)
 	const struct tegra_pingroup *g;
 	u32 val;
 
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+	bool stash = kernel_is_on_guest; 
+        if(kernel_is_on_guest && is_debug_exception(GPIO_NOPT_TEST15))
+	#endif
+          kernel_is_on_guest = false; // tmp value for this function
+
+	deb_debug("\n");
+
 	for (i = 0; i < pmx->soc->ngroups; ++i) {
 		g = &pmx->soc->groups[i];
 		if (g->parked_bitmask > 0) {
@@ -883,6 +1062,9 @@ static void tegra_pinctrl_clear_parked_bits(struct tegra_pmx *pmx)
 			pmx_writel(pmx, val, bank, reg);
 		}
 	}
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+	kernel_is_on_guest = stash;
+	#endif
 }
 
 static size_t tegra_pinctrl_get_bank_size(struct device *dev,
@@ -891,6 +1073,8 @@ static size_t tegra_pinctrl_get_bank_size(struct device *dev,
 	struct platform_device *pdev = to_platform_device(dev);
 	struct resource *res;
 
+	deb_debug("\n");
+
 	res = platform_get_resource(pdev, IORESOURCE_MEM, bank_id);
 
 	return resource_size(res) / 4;
@@ -904,6 +1088,8 @@ static int tegra_pinctrl_suspend(struct device *dev)
 	size_t bank_size;
 	unsigned int i, k;
 
+	deb_debug("\n");
+
 	for (i = 0; i < pmx->nbanks; i++) {
 		bank_size = tegra_pinctrl_get_bank_size(dev, i);
 		regs = pmx->regs[i];
@@ -922,15 +1108,23 @@ static int tegra_pinctrl_resume(struct device *dev)
 	size_t bank_size;
 	unsigned int i, k;
 
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+	bool stash = kernel_is_on_guest;	 
+        if(kernel_is_on_guest && is_debug_exception(GPIO_NOPT_TEST16))
+	#endif
+          kernel_is_on_guest = false; // tmp value for this function
+
+	deb_debug("\n");
+
 	for (i = 0; i < pmx->nbanks; i++) {
 		bank_size = tegra_pinctrl_get_bank_size(dev, i);
 		regs = pmx->regs[i];
 		for (k = 0; k < bank_size; k++)
-			writel_relaxed(*backup_regs++, regs++);
+		writel_relaxed(*backup_regs++, regs++);
 	}
 
 	/* flush all the prior writes */
-	readl_relaxed(pmx->regs[0]);
+  readl_relaxed(pmx->regs[0]);
 	/* wait for pinctrl register read to complete */
 	rmb();
 
@@ -947,6 +1141,9 @@ static int tegra_pinctrl_resume(struct device *dev)
 		pmx_writel(pmx, val, 0, EMMC4_PAD_CFGPADCTRL_OFFSET);
 	}
 
+	#if defined(GPIO_DEBUG_EXCEPTIONS)
+	kernel_is_on_guest = stash;
+	#endif
 	return 0;
 }
 
@@ -961,6 +1158,8 @@ static bool tegra_pinctrl_gpio_node_has_range(struct tegra_pmx *pmx)
 	struct device_node *np;
 	bool has_prop = false;
 
+	deb_debug("\n");
+
 	if (of_property_read_bool(dev->of_node, "#gpio-range-cells"))
 		return true;
 
@@ -985,6 +1184,8 @@ int tegra_pinctrl_probe(struct platform_device *pdev,
 	int fn, gn, gfn;
 	unsigned long backup_regs_size = 0;
 
+	deb_debug("\n");
+
 	pmx = devm_kzalloc(&pdev->dev, sizeof(*pmx), GFP_KERNEL);
 	if (!pmx)
 		return -ENOMEM;
diff --git a/drivers/pinctrl/tegra/pinctrl-tegra114.c b/drivers/pinctrl/tegra/pinctrl-tegra114.c
index 135635f4e897..050a78ffb0e2 100644
--- a/drivers/pinctrl/tegra/pinctrl-tegra114.c
+++ b/drivers/pinctrl/tegra/pinctrl-tegra114.c
@@ -1845,8 +1845,26 @@ static const struct tegra_pinctrl_soc_data tegra114_pinctrl = {
 	.drvtype_in_mux = false,
 };
 
+// #define GPIO_DEBUG
+// #define GPIO_DEBUG_VERBOSE
+
+#ifdef GPIO_DEBUG
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+#else
+  #define deb_info(fmt, ...)
+  #define deb_debug(fmt, ...)
+#endif
+
+#ifdef GPIO_DEBUG_VERBOSE
+  #define deb_verbose           deb_debug
+#else
+  #define deb_verbose(fmt, ...)
+#endif
+
 static int tegra114_pinctrl_probe(struct platform_device *pdev)
 {
+	deb_debug("\n");
 	return tegra_pinctrl_probe(pdev, &tegra114_pinctrl);
 }
 
@@ -1865,6 +1883,7 @@ static struct platform_driver tegra114_pinctrl_driver = {
 
 static int __init tegra114_pinctrl_init(void)
 {
+	deb_debug("\n");
 	return platform_driver_register(&tegra114_pinctrl_driver);
 }
 arch_initcall(tegra114_pinctrl_init);
diff --git a/drivers/pinctrl/tegra/pinctrl-tegra124.c b/drivers/pinctrl/tegra/pinctrl-tegra124.c
index cfc75ca9ae2b..320486fd060b 100644
--- a/drivers/pinctrl/tegra/pinctrl-tegra124.c
+++ b/drivers/pinctrl/tegra/pinctrl-tegra124.c
@@ -2057,8 +2057,26 @@ static const struct tegra_pinctrl_soc_data tegra124_pinctrl = {
 	.drvtype_in_mux = false,
 };
 
+// #define GPIO_DEBUG
+// #define GPIO_DEBUG_VERBOSE
+
+#ifdef GPIO_DEBUG
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+#else
+  #define deb_info(fmt, ...)
+  #define deb_debug(fmt, ...)
+#endif
+
+#ifdef GPIO_DEBUG_VERBOSE
+  #define deb_verbose           deb_debug
+#else
+  #define deb_verbose(fmt, ...)
+#endif
+
 static int tegra124_pinctrl_probe(struct platform_device *pdev)
 {
+	deb_debug("\n");
 	return tegra_pinctrl_probe(pdev, &tegra124_pinctrl);
 }
 
@@ -2077,6 +2095,7 @@ static struct platform_driver tegra124_pinctrl_driver = {
 
 static int __init tegra124_pinctrl_init(void)
 {
+	deb_debug("\n");
 	return platform_driver_register(&tegra124_pinctrl_driver);
 }
 arch_initcall(tegra124_pinctrl_init);
diff --git a/drivers/pinctrl/tegra/pinctrl-tegra186.c b/drivers/pinctrl/tegra/pinctrl-tegra186.c
index d78447c55527..0feaad8022fd 100644
--- a/drivers/pinctrl/tegra/pinctrl-tegra186.c
+++ b/drivers/pinctrl/tegra/pinctrl-tegra186.c
@@ -918,8 +918,26 @@ static const struct tegra_pinctrl_soc_data tegra186_pinctrl = {
 	.sfsel_in_mux = true,
 };
 
+#define GPIO_DEBUG
+#define GPIO_DEBUG_VERBOSE
+
+#ifdef GPIO_DEBUG
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+#else
+  #define deb_info(fmt, ...)
+  #define deb_debug(fmt, ...)
+#endif
+
+#ifdef GPIO_DEBUG_VERBOSE
+  #define deb_verbose           deb_debug
+#else
+  #define deb_verbose(fmt, ...)
+#endif
+
 static int tegra186_pinctrl_probe(struct platform_device *pdev)
 {
+	deb_debug("\n");
 	return tegra_pinctrl_probe(pdev, &tegra186_pinctrl);
 }
 
@@ -940,12 +958,14 @@ static struct platform_driver tegra186_pinctrl_driver = {
 
 static int __init tegra186_pinctrl_init(void)
 {
+	deb_debug("\n");
 	return platform_driver_register(&tegra186_pinctrl_driver);
 }
 postcore_initcall_sync(tegra186_pinctrl_init);
 
 static void __exit tegra186_pinctrl_exit(void)
 {
+	deb_debug("\n");
 	platform_driver_unregister(&tegra186_pinctrl_driver);
 }
 module_exit(tegra186_pinctrl_exit);
diff --git a/drivers/pinctrl/tegra/pinctrl-tegra194.c b/drivers/pinctrl/tegra/pinctrl-tegra194.c
index 5c7fa1f1c45f..c7b6e114f282 100644
--- a/drivers/pinctrl/tegra/pinctrl-tegra194.c
+++ b/drivers/pinctrl/tegra/pinctrl-tegra194.c
@@ -1872,8 +1872,27 @@ static const struct tegra_pinctrl_soc_data tegra194_pinctrl = {
 	.sfsel_in_mux = true,
 };
 
+// #define GPIO_DEBUG
+// #define GPIO_DEBUG_VERBOSE
+
+#ifdef GPIO_DEBUG
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+#else
+  #define deb_info(fmt, ...)
+  #define deb_debug(fmt, ...)
+#endif
+
+#ifdef GPIO_DEBUG_VERBOSE
+  #define deb_verbose           deb_debug
+#else
+  #define deb_verbose(fmt, ...)
+#endif
+
+
 static int tegra194_pinctrl_probe(struct platform_device *pdev)
 {
+	deb_debug("\n");
 	return tegra_pinctrl_probe(pdev, &tegra194_pinctrl);
 }
 
@@ -1892,6 +1911,7 @@ static struct platform_driver tegra194_pinctrl_driver = {
 
 static int __init tegra194_pinctrl_init(void)
 {
+	deb_debug("\n");
 	return platform_driver_register(&tegra194_pinctrl_driver);
 }
 arch_initcall(tegra194_pinctrl_init);
diff --git a/drivers/pinctrl/tegra/pinctrl-tegra20.c b/drivers/pinctrl/tegra/pinctrl-tegra20.c
index cd605272c068..acd534f495ff 100644
--- a/drivers/pinctrl/tegra/pinctrl-tegra20.c
+++ b/drivers/pinctrl/tegra/pinctrl-tegra20.c
@@ -2236,6 +2236,23 @@ static const char *cdev2_parents[] = {
 	"dev2_osc_div", "hclk", "pclk", "pll_p_out4",
 };
 
+// #define GPIO_DEBUG
+// #define GPIO_DEBUG_VERBOSE
+
+#ifdef GPIO_DEBUG
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+#else
+  #define deb_info(fmt, ...)
+  #define deb_debug(fmt, ...)
+#endif
+
+#ifdef GPIO_DEBUG_VERBOSE
+  #define deb_verbose           deb_debug
+#else
+  #define deb_verbose(fmt, ...)
+#endif
+
 static void tegra20_pinctrl_register_clock_muxes(struct platform_device *pdev)
 {
 	struct tegra_pmx *pmx = platform_get_drvdata(pdev);
@@ -2249,6 +2266,7 @@ static void tegra20_pinctrl_register_clock_muxes(struct platform_device *pdev)
 
 static int tegra20_pinctrl_probe(struct platform_device *pdev)
 {
+	deb_debug("\n");
 	int err;
 
 	err = tegra_pinctrl_probe(pdev, &tegra20_pinctrl);
@@ -2275,6 +2293,7 @@ static struct platform_driver tegra20_pinctrl_driver = {
 
 static int __init tegra20_pinctrl_init(void)
 {
+	deb_debug("\n");
 	return platform_driver_register(&tegra20_pinctrl_driver);
 }
 arch_initcall(tegra20_pinctrl_init);
diff --git a/drivers/pinctrl/tegra/pinctrl-tegra210.c b/drivers/pinctrl/tegra/pinctrl-tegra210.c
index 01f200a4c789..8c9dad7e1b5f 100644
--- a/drivers/pinctrl/tegra/pinctrl-tegra210.c
+++ b/drivers/pinctrl/tegra/pinctrl-tegra210.c
@@ -1745,12 +1745,16 @@ static const struct tegra_pinctrl_soc_data tegra210_pinctrl = {
 	.drvtype_in_mux = true,
 };
 
+// #define GPIO_DEBUG
+
 static int tegra210_pinctrl_probe(struct platform_device *pdev)
 {
 	const struct tegra210_pinctrl_soc *soc;
 	struct tegra_pingroup *g;
 	int i;
 
+	printk(KERN_DEBUG "GPIO %s -- file %s", __func__, kbasename(__FILE__));
+
 	soc = of_device_get_match_data(&pdev->dev);
 	if (soc->lpdr_support) {
 		for (i = 0; i < tegra210_pinctrl.ngroups; ++i) {
@@ -1793,6 +1797,7 @@ static struct platform_driver tegra210_pinctrl_driver = {
 
 static int __init tegra210_pinctrl_init(void)
 {
+	printk(KERN_DEBUG "GPIO %s -- file %s", __func__, kbasename(__FILE__));
 	return platform_driver_register(&tegra210_pinctrl_driver);
 }
 arch_initcall(tegra210_pinctrl_init);
diff --git a/drivers/pinctrl/tegra/pinctrl-tegra30.c b/drivers/pinctrl/tegra/pinctrl-tegra30.c
index 60e087e5b7f5..1e5f56a4a1e1 100644
--- a/drivers/pinctrl/tegra/pinctrl-tegra30.c
+++ b/drivers/pinctrl/tegra/pinctrl-tegra30.c
@@ -2480,8 +2480,26 @@ static const struct tegra_pinctrl_soc_data tegra30_pinctrl = {
 	.drvtype_in_mux = false,
 };
 
+// #define GPIO_DEBUG
+// #define GPIO_DEBUG_VERBOSE
+
+#ifdef GPIO_DEBUG
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+#else
+  #define deb_info(fmt, ...)
+  #define deb_debug(fmt, ...)
+#endif
+
+#ifdef GPIO_DEBUG_VERBOSE
+  #define deb_verbose           deb_debug
+#else
+  #define deb_verbose(fmt, ...)
+#endif
+
 static int tegra30_pinctrl_probe(struct platform_device *pdev)
 {
+	deb_debug("\n");
 	return tegra_pinctrl_probe(pdev, &tegra30_pinctrl);
 }
 
@@ -2500,6 +2518,7 @@ static struct platform_driver tegra30_pinctrl_driver = {
 
 static int __init tegra30_pinctrl_init(void)
 {
+	deb_debug("\n");
 	return platform_driver_register(&tegra30_pinctrl_driver);
 }
 arch_initcall(tegra30_pinctrl_init);
diff --git a/include/gpio-proxy.h b/include/gpio-proxy.h
new file mode 100644
index 000000000000..d1c48f3ae929
--- /dev/null
+++ b/include/gpio-proxy.h
@@ -0,0 +1,220 @@
+#ifndef GPIO_PROXY_H
+#define GPIO_PROXY_H
+
+/* passthrough hooks for low level functions such as readl and writel
+ * functions are mainly intended for GPIO passthrough
+ */
+extern bool kernel_is_on_guest;
+
+#define GPIO_RW_TEST31 31    // last bit of 
+
+#define GPIO_GET_HOST_VALUES		'H' // signal code
+#define GPIO_HOST_VALUE_SECURE				1
+#define GPIO_HOST_VALUE_BASE					2
+// #define GPIO_HOST_VALUE_GTE_REGS		3
+// #define GPIO_HOST_VALUE_GPIO_RVAL	4
+
+struct tegra_gpio_local_values {
+	void __iomem *secure;
+	void __iomem *base;
+	// void __iomem *gte_regs;
+	// struct tegra_gpio_saved_register *gpio_rval;
+	bool initialised;
+};
+
+inline u32 readl_redirect( void * addr, unsigned char type);
+inline void writel_redirect( u32 value, void * addr, unsigned char type);
+void __iomem *tegra186_gpio_get_base_redirect(unsigned char id, unsigned int pin);
+
+extern const unsigned char rwl_std_type;
+extern const unsigned char rwl_raw_type;
+extern const unsigned char rwl_relaxed_type;
+
+// ifdef directives are assumed to be defined in the files that include gpio-proxy.h, this file 
+#if defined(GPIO_DEBUG_EXCEPTIONS)
+
+extern uint32_t debug_exceptions;
+extern bool is_debug_exception(int off);
+
+#else
+#define is_debug_exception(...) false
+#endif
+
+#if defined(GPIO_DEBUG_EXCEPTIONS)
+
+static inline u32 readl_both_local( void * addr) {
+  u32 ret, ret_l;
+  deb_verbose("\n");
+  ret_l = readl(addr);
+  if(kernel_is_on_guest && !is_debug_exception(GPIO_RW_TEST31)) {
+    ret = readl_redirect(addr, rwl_std_type);
+    if( ret_l != ret ) deb_debug("return values differ %d/%d", ret_l , ret);
+  }
+  return ret_l; 
+}
+
+static inline u32 readl_both( void * addr) {
+  u32 ret, ret_l;
+  deb_verbose("\n");
+  ret_l = readl(addr);
+  if(kernel_is_on_guest && !is_debug_exception(GPIO_RW_TEST31)) {
+    ret = readl_redirect(addr, rwl_std_type);
+    if( ret_l != ret ) deb_debug("return values differ %d/%d", ret_l , ret);
+  }
+  return ret_l; 
+}
+
+static inline void writel_both( u32 value, void * addr) {
+  deb_verbose("\n");
+  writel(value, addr);
+  if(kernel_is_on_guest && !is_debug_exception(GPIO_RW_TEST31)) {
+    writel_redirect(value, addr, rwl_std_type);
+  }
+};
+
+static inline u32 __raw_readl_both( void * addr) {
+  u32 ret, ret_l;
+  deb_verbose("\n");
+  ret_l = __raw_readl(addr);
+  if(kernel_is_on_guest && !is_debug_exception(GPIO_RW_TEST31)) {
+    ret = readl_redirect(addr, rwl_raw_type);
+    if( ret_l != ret ) deb_debug("return values differ %d/%d", ret_l , ret);
+  }
+  return ret_l; 
+};
+
+static inline void __raw_writel_both( u32 value, void * addr) {
+  deb_verbose("\n");
+  __raw_writel(value, addr);
+  if(kernel_is_on_guest && !is_debug_exception(GPIO_RW_TEST31)) {
+    writel_redirect(value, addr, rwl_raw_type);
+  }
+};
+
+static inline u32 readl_relaxed_both( void * addr) {
+  u32 ret, ret_l;
+  deb_verbose("\n");
+  ret_l = readl_relaxed(addr);
+  if(kernel_is_on_guest && !is_debug_exception(GPIO_RW_TEST31)) {
+    ret = readl_redirect(addr, rwl_relaxed_type);
+    if( ret_l != ret ) deb_debug("return values differ %d/%d", ret_l , ret);
+  }
+  return ret_l; 
+};
+
+static inline void writel_relaxed_both( u32 value, void * addr) {
+  deb_verbose("\n");
+  writel_relaxed(value, addr);
+  if(kernel_is_on_guest && !is_debug_exception(GPIO_RW_TEST31)) {
+    writel_redirect(value, addr, rwl_relaxed_type);
+  }
+};
+
+static inline u32 readl_x( void * addr) {
+  u32 ret;
+  deb_verbose("\n");
+  if(kernel_is_on_guest && !is_debug_exception(GPIO_RW_TEST31)) {
+    ret = readl_redirect(addr, rwl_std_type);
+  }
+  else {
+    ret = readl(addr);
+  }
+  return ret; 
+};
+
+static inline void writel_x( u32 value, void * addr) {
+  deb_verbose("\n");
+  if(kernel_is_on_guest && !is_debug_exception(GPIO_RW_TEST31)) {
+    writel_redirect(value, addr, rwl_std_type);
+  }
+  else {
+    writel(value, addr);
+  }
+};
+
+static inline u32 __raw_readl_x( void * addr) {
+  u32 ret;
+  deb_verbose("\n");
+  if(kernel_is_on_guest && !is_debug_exception(GPIO_RW_TEST31)) {
+    ret = readl_redirect(addr, rwl_raw_type);
+  }
+  else {
+    ret = __raw_readl(addr);
+  }
+  return ret; 
+};
+
+static inline void __raw_writel_x( u32 value, void * addr) {
+  deb_verbose("\n");
+  if(kernel_is_on_guest && !is_debug_exception(GPIO_RW_TEST31)) {
+    writel_redirect(value, addr, rwl_raw_type);
+  }
+  else {
+    __raw_writel(value, addr);
+  }
+};
+
+static inline u32 readl_relaxed_x( void * addr) {
+  u32 ret;
+  deb_verbose("\n");
+  if(kernel_is_on_guest && !is_debug_exception(GPIO_RW_TEST31)) {
+    ret = readl_redirect(addr, rwl_relaxed_type);
+  }
+  else {
+    ret = readl_relaxed(addr);
+  }
+  return ret; 
+};
+
+static inline void writel_relaxed_x( u32 value, void * addr) {
+  deb_verbose("\n");
+  if(kernel_is_on_guest && !is_debug_exception(GPIO_RW_TEST31)) {
+    writel_redirect(value, addr, rwl_relaxed_type);
+  }
+  else {
+    writel_relaxed(value, addr);
+  }
+};
+
+// these passthroughs are not necessary because the functions above are called in the passthrough version of this code
+/*
+static inline u32 pmx_readl( void * addr) { return 0; };
+static inline void pmx_writel( u32 value, void * addr) {};
+static inline u32 tegra_gpio_readl( void * addr) { return 0;};
+static inline void tegra_gpio_writel( u32 value, void * addr) {};
+static inline u32 tegra_gte_readl( void * addr) { return 0; };
+static inline void tegra_gte_writel( u32 value, void * addr) {};
+*/
+// note: adding more higher level functions migth take latency off the lower level functions
+
+// struct used to transfer setup values from host setup. Needed when guest accesses host. 
+
+#else
+
+static inline u32 readl_x( void * addr) {
+    return readl(addr);
+};
+
+static inline void writel_x( u32 value, void * addr) {
+    writel(value, addr);
+};
+
+static inline u32 __raw_readl_x( void * addr) {
+    return __raw_readl(addr);
+};
+
+static inline void __raw_writel_x( u32 value, void * addr) {
+    __raw_writel(value, addr);
+};
+
+static inline u32 readl_relaxed_x( void * addr) {
+    return readl_relaxed(addr);
+};
+
+static inline void writel_relaxed_x( u32 value, void * addr) {
+    writel_relaxed(value, addr);
+};
+
+#endif // GPIO_DEBUG_EXCEPTIONS
+
+#endif // GPIO_PROXY_H
diff --git a/include/linux/gpio.h b/include/linux/gpio.h
index 68193b32eb73..44a827979aad 100644
--- a/include/linux/gpio.h
+++ b/include/linux/gpio.h
@@ -56,7 +56,7 @@ struct gpio {
 #ifdef CONFIG_GPIOLIB
 
 #ifdef CONFIG_ARCH_HAVE_CUSTOM_GPIO_H
-#include <asm/gpio.h>
+
 #else
 
 #include <asm-generic/gpio.h>
